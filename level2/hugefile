<TITLE>CS360 NOTES</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 NOTES</H1>
<Pre>
                   360 NOTES on TCP/IP

1. IP stands for Internet Protocol. TCP (Transmission Control Protocol) is a 
   protocol built on top of IP. TCP/IP is the backbone of InterNet. Currently 
   there are 2 versions of IP, known as IPv4 and IPv6. IPv4 uses 32-bit address
   and IPv6 uses 128-bit address. The discussion here is based on IPv4, which 
   is still the predominat version IP in use.

2. Host and IP address:
   A host is a machine that runs IP. Every host is identified by a unique 
   32-bit number called the IP address. For human convenience, this 32-bit 
   number is usually expressed in a "dotted" notation, such as 134.121.64.1  
   A host is also known by a host name, e.g. dns1.eecs.wsu.edu. Host name and 
   IP address are "equivalent" in the sense that, given one, we can find the 
   other (by a Domain-Name-Server, DNS). 

   An IP address is divided into two parts: | networkID | hostID |.
   Depending on networkID, IP addresses are classified as

                                             Decimal Notation:
   Class A : |0xxxxxxx|    24 bits          |    1-126
             | netID  |    host ID          |

   Class B : |10| 14 bits   |   16 bits     |    128-191  
             |   NetID      |   HostID      |
   
   Class C : |110 21 bits            |8 bits|    192-223
             |       netID           |host  |
   ------------------------------------------------------- 
   Class D : |1110x|  multicast group ID    |
   Class E : |11110|  reserved              |

   Data packets intended for an IP address are first sent to a "Router" with 
   the same NetworkID.  That router will forward the packets to a specific
   host by using the HostID.

3. What is IP ?  
   IP is a protocol for sending/receiving data packets between hosts. IP 
   operates in a best-effort manner, i.e. it just sends the packets out, but 
   does NOT guarantee that they will be delivered to their destinations, NOR 
   in order. So, IP may be unreliable. 

4. IP Packet Format:
   An IP packet consists of

      | Header |SourceIP|DestIP|<-----  DATA ---->|
         12       4        4   | upto 64K-24 bytes|
        
   The Header part contains more information, e.g. total length, TCP/UDP, TTL, 
   check-sum for error detection, etc. about the packet so that a receiving
   host would know what to do with the packet. For example, an IP packet is
   simply dropped if its check-sum indicates an error or its TTL has expired.

5. Routers:
   IP hosts may be located far apart. It is usually not possible to send data 
   packets from one host to the other DIRECTLY. "Routers" are special IP hosts 
   that receive and forward packets. Therefore, IP packets may go through 
   many routers, or "hops",  before arriving at a destination. 


6. UDP (User DataGram Protocol)
   UDP operates on top of IP. It is used to send/receive "datagrams". Like
   IP, UDP doe NOT guarantee reliability but it is fast and efficient. It is 
   used in situations where reliablility is not essential.
   Example:

      ping mail.wsu.edu     OR    ping 134.121.1.8
   
   ping is a program that sends a UDP packet to a host, which "echo" the UDP 
   packet back to the sender with a round-trip time.
      
7. TCP (Transmission Control Protocol)
   TCP also operates on top of IP but guarantees reliable data transfer. It is
   a connection-oriented protocol for sending/receiving "data streams". 

   A common analogy is that UDP is similar to "telegram" (or USPS), and TCP is
   similar to "telephone".

8. Port Number:
   At each IP host, many applications may be using UDP/TCP at the same time. 
   Each application is uniquely identified by a triple
        Application = (HostIP, Protocol, PortNumber)
   where Protocol is either UDP or TCP, and PortNumber is a unique 2-byte 
   unsiged integer assigned to the application. In order to use UDP or TCP at 
   a host, an application (process) must choose or obtain a PortNumber first. 
   The first 1024 port numbers (0 to 1023) are reserved.  

9. Network and Host (byte) Order:
   Machines may use either "big-endian" or "little-endian" byte-ordering. On 
   the "Internet", data are always in "network order", which is "big-endian".

   A set of library functions htons()/htonl(), ntohs()/ntohl() are used to 
   convert data between host-order and network-order. 

10. Server-Client Model:
    In network programming, we typically run a Server at a host first. The 
    Server waits for Client requests and serves the requests. In UDP, the 
    Server simply waits for "datagrams" from a Client. In TCP, the Server 
    waits for a Client to "connect".

    Then, we run the Client from a client host, In UDP, the client simply sends
    each request as a UDP datagram to the Server. Then it receives a reply 
    datagram from the Server. In TCP, the Client requests to connect to the 
    Server first. Then the Server and Client can exchange "continuous" streams
    of data.

In the following, we shall show how to do network programming using TCP.

11. Network Programming:
    Unix (Linux) Kernel provides TCP/IP support. User interface to TCP/IP is
    through "sockets". To the user (program), creating a socket is similar to 
    opening a file for RW. It returns a file descriptor so that the same 
    read()/write() system calls can be used to transfer data.   

12. Sockets Programming

    First, we need the following C structs defined in netdb.h and sys/socket.h

12-1.The socket address data structure:

    struct sockaddr_in {
       u_short        sin_family; /* protocol identifier; usually AF_INET */
       u_short        sin_port;   /* port number. 0 means let kernel choose */
       struct in_addr sin_addr;   /* IP address. INADDR_ANY=the current host.*/
       char           sin_zero[8];}; /* Unused, always zero */
    }

    struct in_addr {
        u_long s_addr;
    };

12-2. The hostent struct in &lt;netdb.h&gt; is as shown (man gethostbyname):
        
        struct hostent {
               char    *h_name;        // DOT name string of host
               char    **h_aliases;    // alias list 
               int     h_addrtype;     // host address type
               int     h_length;       // length of address
               char    **h_addr_list;  // list of addresses (long IP address)
        }
        #define h_addr  h_addr_list[0]  // for backward compatibility 

        // NOTE: h_addr is defined as a char * but it points at the IP_address,
        //       which is a 4-byte number in network (big-endian) order.
        // ulong NIP = *(ulong *)h_addr is the IP_address in network order.
        // ulong HIP = ntohl(NIP) is NIP in host order (INTEL=little-endian).
        // inet_ntoa(NIP) converts NIP to a string in DOT notation.

13. An ECHO Server/Client Program using TCP

    Shown below are the C source files of an ECHO server and a client.
    These files are also available in ~samples/LAB4/. 

    First, run the server at a host as        server [hostname]
    where hostname is either the DNS name or IP address of the host machine. 
    If no hostname is given, the default "localhost" (127.0.0.1) will be used.

    The Server first displays the server's hostname, IP address and port number
    Then it waits for a client to connect.

    Next, run the client at another host as   client ServerName ServerPort

    (You may also run both on the SAME host but in separate X-windows).

    After connecting to the server, the client asks the user for an input 
    string, sends it to the server, which simply echos the string back.

    When the client ends (by Enter or Control-C), the server loops back
    to accept another connection, etc.

    The sequence of actions between the server and the client are shown
    in the following diagram.

                                ACTIONS OF 
            Server                                       Client:
   --------------------------------      ---------------------------------
1. Display hostname, IP, Port#      ===> 1. MUST know Server's name|IP,Port#
2. Construct a server_addr struct        2. Construct a server_addr struct 
3. Create a TCP socket with Port#        3. Create a TCP socket sock
4. Bind socket to server_addr info             
5. Listen at socket by listen() syscall
6. newsock = accept()               <==  4. connect() to Server via sock
   ------------------------------------------------------------------------
                           Send/Receive Data
7. READ from newsock      <------------------  WRITE to  sock
   WRITE to  newsock      ------------------>  READ from sock
   ------------------------------------------------------------------------
8. loop to 6 to accept next client             close(sock);

//**************************************************************************
//           This Server-Client package uses TCP sockets.
//              This is the ECHO SERVER server.c file. 
//**************************************************************************

#define  MAX 256

#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;

// Define variables:
struct sockaddr_in  server_addr, client_addr, name_addr;
struct hostent *hp;

int  sock, newsock;                  // socket descriptors
int  serverPort;                     // server port number
int  r, length, n;                   // help variables

// Server initialization code:

int server_init(char *name)
{
   printf("==================== server init ======================\n");   
   // get DOT name and IP address of this host

   printf("1 : get and show server host info\n");
   hp = gethostbyname(name);
   if (hp == 0){
      printf("unknown host\n");
      exit(1);
   }
   printf("    hostname=%s  IP=%s\n",
               hp->h_name,  inet_ntoa(*(long *)hp->h_addr));
  
   //  create a TCP socket by socket() syscall
   printf("2 : create a socket\n");
   sock = socket(AF_INET, SOCK_STREAM, 0);
   if (sock < 0){
      printf("socket call failed\n");
      exit(2);
   }

   printf("3 : fill server_addr with host IP and PORT# info\n");
   // initialize the server_addr structure
   server_addr.sin_family = AF_INET;                  // for TCP/IP
   server_addr.sin_addr.s_addr = htonl(INADDR_ANY);   // THIS HOST IP address  
   server_addr.sin_port = 0;   // let kernel assign port

   printf("4 : bind socket to host info\n");
   // bind syscall: bind the socket to server_addr info
   r = bind(sock,(struct sockaddr *)&server_addr, sizeof(server_addr));
   if (r < 0){
       printf("bind failed\n");
       exit(3);
   }

   printf("5 : find out Kernel assigned PORT# and show it\n");
   // find out socket port number (assigned by kernel)
   length = sizeof(name_addr);
   r = getsockname(sock, (struct sockaddr *)&name_addr, &length);
   if (r < 0){
      printf("get socketname error\n");
      exit(4);
   }

   // show port number
   serverPort = ntohs(name_addr.sin_port);   // convert to host ushort
   printf("    Port=%d\n", serverPort);

   // listen at port with a max. queue of 5 (waiting clients) 
   printf("6 : server listening ....\n");
   listen(sock, 5);
   printf("===================== init done =======================\n");
}

main(int argc, char *argv[])
{
   char *hostname, line[MAX];

   if (argc < 2)
      hostname = "localhost";
   else
      hostname = argv[1];
 
   server_init(hostname); 

   // Try to accept a client request
   while(1){
     printf("server: accepting new connection ....\n"); 

     // Try to accept a client connection as descriptor newsock
     length = sizeof(client_addr);
     newsock = accept(sock, (struct sockaddr *)&client_addr, &length);
     if (newsock < 0){
        printf("server: accept error\n");
        exit(1);
     }
     printf("server: accepted a client connection from\n");
     printf("-----------------------------------------------\n");
     printf("        IP=%s  port=%d\n", inet_ntoa(client_addr.sin_addr.s_addr),
                                        ntohs(client_addr.sin_port));
     printf("-----------------------------------------------\n");

     // Processing loop
     while(1){
       n = read(newsock, line, MAX);
       if (n==0){
           printf("server: client died, server loops\n");
           close(newsock);
           break;
      }
      
      // show the line string
      printf("server: read  n=%d bytes; line=[%s]\n", n, line);

      strcat(line, " ECHO"); // ASSUME line[MAX] still has room for " ECHO"

      // send the echo line to client 
      n = write(newsock, line, MAX);

      printf("server: wrote n=%d bytes; ECHO=[%s]\n", n, line);
      printf("server: ready for next request\n");
    }
 }
}


//*********************** ECHO CLIENT client.c file *************************

#define MAX 256

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;


// Define variables
struct hostent *hp;              
struct sockaddr_in  server_addr; 

int sock, r;
int SERVER_IP, SERVER_PORT; 

int client_init(char *argv[])
{
  printf("======= clinet init ==========\n");

  printf("1 : get server info\n");
  hp = gethostbyname(argv[1]);
  if (hp==0){
     printf("unknown host %s\n", argv[1]);
     exit(1);
  }

  SERVER_IP   = *(long *)hp->h_addr;
  SERVER_PORT = atoi(argv[2]);

  printf("2 : create a TCP socket\n");
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock<0){
     printf("socket call failed\n");
     exit(2);
  }

  printf("3 : fill server_addr with server's IP and PORT#\n");
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = SERVER_IP;
  server_addr.sin_port = htons(SERVER_PORT);

  // Connect to server
  printf("4 : connecting to server ....\n");
  r = connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
  if (r < 0){
     printf("connect failed\n");
     exit(1);
  }

  printf("5 : connected OK to \007\n"); 
  printf("---------------------------------------------------------\n");
  printf("hostname=%s  IP=%s  PORT=%d\n", 
          hp->h_name, inet_ntoa(SERVER_IP), SERVER_PORT);
  printf("---------------------------------------------------------\n");

  printf("========= init done ==========\n");
}


main(int argc, char *argv[ ])
{
  int n;
  char line[MAX], ans[MAX];

  if (argc < 3){
     printf("Usage : client ServerName SeverPort\n");
     exit(1);
  }

  client_init(argv);

  printf("********  processing loop  *********\n");
  while (1){
    printf("input a line : ");
    bzero(line, MAX);                // zero out line[ ]
    fgets(line, MAX, stdin);         // get a line (END with \n) from stdin 
    line[strlen(line)-1] = 0;        // kill \n at end
    if (line[0]==0)                  // exit if NULL line
       exit(0);

   // Send ENTIRE line to server
    n = write(sock, line, MAX);
    printf("client: wrote n=%d bytes; line=(%s)\n", n, line);

    // Read a line from sock and show it
    n = read(sock, ans, MAX);
    printf("client: read  n=%d bytes; echo=(%s)\n",n, ans);
  }
}



13-1. Run the above Server/Client programs. 
      The source files of server.c/clinet.c are in ~samples/LAB4/ directory.
      Download them, cc and run.

      Modify them to do computations, e.g. client sends 2 numbers to server, 
      which returns the SUM.

13-2. 
The above Server/Client code may be used as the basis for TCP-orineted network
programming. You may adapt it for different applications by simply changing the
data contents and the ways they process the data.

                    Example:
============================================================================== 
Instead of numbers, the Client may send a "command" string, such as

           pwd  
           ls  [pathname]
           cd  [pathname]
           get filename  
           put filename
           
The Server executes the command and sends results back to the Client. 

Simlarly, you may implement mkdir, rmdir, creat, rm operations at the Server. 
==============================================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab Assignment #2 </H1>

<Pre>

Given the C program:

main(int argc, char *argv[], char *env[])
{
  int a,b,c;
  printf("enter main\n");
  a=1; b=2; c=3;

     //****** DO (1): Write C code here to print the ************* 
     (1). argv[] strings
     (2).  env[] strings

  A(a,b);
  printf("exit main\n");
}

int A(int x, int y)
{
  int d,e,f;
  printf("enter A\n");
  d=3; e=4; f=5;
  B(d,e);
  printf("exit A\n");
}

int B(int x, int y)
{
  int g,h,i;
  printf("enter B\n");
  g=6; h=7; i=8;
  C(g,h);
  printf("exit B\n");
}

int C(int x, int y)
{
  int p,q,r;
  printf("enter C\n");
  p=9; q=10; r=11;

    / Write C and assembly code to 
    ********* DO (2)-(4) AS SPECIFIED BELOW *************/

  printf("exit C\n");
}
=============================================================================

(1). Call an assembly function
             getfp:   
                     pushl %ebp
                     movl  %esp, %ebp
                     ...............
     which returns the current frame pointer fp=%ebp. As shown by the diagram,
     fp is the head pointer of a link list of the stack frames, which ends 
     with a 0.

       HIHG                                                  LOW
        ---------------------------------------------------------
          0        fp0       fpM       fpA        fpB     fpC
        ---------------------------------------------------------  
          ^         ^         ^         ^          ^       ^ 
         fp0       fpM       fpA       fpB        fpC      fp

(2). Print in HEX the stack contents from fp to fp0 in the form

              Address      Contents
             ---------    ----------

             ---------    ---------- 

(3). On a hard copy of the outputs, IDENTIFY and EXPLAIN the stack contents 
     in terms of the function stack frames, i.e. local variables, parameters, 
     return address, etc. 


4: Long Jump:
   In the above calling sequence, it is possible to return from C() directly 
   to, say main(), by a long jump, as shown below:

4-1: First, define global variables

       int mainFP, mainPC;  /* for saving main()'s FP and PC */

       main()
       { 
           int r;

4-2: /**** Save long jump return point ****/
         if ( r = setjump() )

             /*********************************************
              Implement setjump() in such a way that it
              saves main's FP into mainFP, setjump()'s return
              PC into mainPC, and returns to here with a 0;
             **********************************************/    
         { 
             printf("back via long jump: r=%d\n",r);
             exit(1);
         }
4-3: /***** Normal call out ******/
         /* call A() -> B() -> C() as before */
         printf("noraml return\n");
       }


4-4:  In one of the called functions, e.g. C():

       int C()
       { .......................;

         printf("long jump back to main? {y|n) ");
        
         /**************************************
           If the answer is 'y' call the function
                 longjump(100);  
           which returns to main() via the saved 
           globals (mainFP, mainPC), and return a 
           nonzero value, e.g. 100.
          **************************************/
       }

           
-------------------  DO #3  ---------------------------
3-5: Implement the functions IN ASSEMBLY:
         int setjump();
         int longjump(int returnValue);
     and DEMO your long jump in LAB.

NOTE: YOU MUST IMPLEMENT these in ASSEMBLY !!!!
=======================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab #2 Pre-Work</H1>

<Pre>
            DUE : in Lab 

1. A binary executable file, a.out, consists of

           |header| TEXT | DATA |<== BSS ===>|

The Unix command    size a.out   shows the size of TEXT, DATA, BSS of a.out.

Use the following C program, t1.c, to generate t2.c, t3.c,.. t6.c as specified
below. 
        //********** t1.c file ************
          int g;                              
          main()                              
          {                                   
             int a,b,c; 
             a = 1; b = 2; 
             c = a + b;
             printf("c=%d\n", c);
          }                                

t2.c: Change the global variable  g  to  int g=3;
t3.c  Change the global variable  g  to  int g[10000];
t4.c  Change the global variable  g  to  int g[10000] = {4);
t5.c  Change the local variables of main() to
                 int a,b,c, d[10000];
t6.c. Change the local variables of main() to
                 int a,b,c, d[10000]={5];
t7.c  Change the local variables of main() to
                 static int a,b,c, d[10000];
t8.c  Change the local variables of main() to
                 static int a,b,c, d[10000]={6};
           
(A). For each case, use cc to generate a.out. Then use  ls -l a.out to get 
     a.out size, and run size a.out to get its section sizes. Record the
     observed sizes in a table:

          Case  | a.out |  TEXT  |  DATA  |  BSS   |
        --------------------------------------------
          (1)   |       |        |        |        |
        --------------------------------------------  
          (2)
        --------------------------------------------
          (3)
        --------------------------------------------
          (4)
        --------------------------------------------
          (5)
        --------------------------------------------        
          (6)
        --------------------------------------------
          (7)
        --------------------------------------------        
          (8)
        --------------------------------------------

                  ANSWER THESE QUESTIONS:

   1. Variables in C may be classified as

          globals ---|--- UNINITIALIZED  globals;
                     |---   INITIALIZED  globals;

          locals  ---|--- AUTOMATIC locals;
                     |--- STATIC    locals;
          

   In terms of the above classifications and the variables g, a, b, c, d,

      Which variables are in DATA? ______________________________________
      Which variables are in BSS ? ______________________________________

   2. In terms of the TEXT, DATA and BSS sections,
      Which sections are in a.out, which section is NOT in a.out?
      WHY?______________________________________________________

  (B). For each case, use   cc -static t.c   to generate a.out.
       Record the sizes again and compare them with the sizes in (A).
       WHAT DO YOU SEE?_________________________________________________

       WHY?______________________________________________________________


2. Given the C function, test.c:
     int g;
     int sub(int x, int y)
     {
        int a, b;
        g = 1;
        x = 2; y = 3;
        a = 4; b = 5;
        return 6;
     }

Use cc -S test.c to generate test.s   Examine the test.s file

ABSWER these questions: WHAT ARE THE addresses OF
(1). g?______________________________________________________
(2). parameters x, y ________________________________________
(3). locals a, b     ________________________________________
(3). Which CPU register contains the return value?___________       
<html>
<Body bgcolor="#00cccc" text="#000000">
<pre>

     CS360 Lab Assignment #4 : File Operations across Networks
               
                   WORK IN 2-person teams
                  DUE & DENO : to be posted


A. OBJECTIVE:
   Network Programming using TCP.
   Unix system calls for file operations.

B. PRE Lab (Do these on your own).:
   Donwload the server.c and client.c files from samples/LAB4/ direcotry.
   cc and run the server and client programs.

   Modify the programs to do the following:
      Client: input 2 numbers, send them to server and get the answer.
      Server: Add the two numbers and send the result back to client.

C. REQUIREMENTS:
   Modify the server/client programs in samples/LAB4/ to do the following:

     Client : input a command:
              ----------------  
              pwd
              ls   [pathname]
              cd    pathname
              mkdir pathname
              rmdir pathname       
              rm    pathname       (rm pathname file)
              get   pathname       (cp pathname file to client side)
              put   pathname       (cp pathanme file to server side)
              quit                 (Client exits)
           -----------------
           send command to Server.
           receive reply (results) from Server.

     Also,implement the (local) commands
         lpwd, lls, lcd, lmkdir. lrmdir, lrm
     which the Client executes LOCALLY.

     Server:
             get a command from Client;
             perform the command;
             send reply to Client;

C. HELP Hints:

   Make each command a fixed-length string, e.g. of LEN=128 bytes.
   REASON: a TCP socket contains a "stream" of data. Each read operation
           reads whatever is available in the socket. Using fixed-length 
           items simplifies reading inidvidual command strings.

D. Sample Solutions
   in samples/LAB4/ : lab4.server  and lab4.client

<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H2>360 LAB Pre-Work #6</H2>
<Pre>
                   CS 360 LAB #5 Pre_work
          PART 1 only:   DUE Wed Oct 15, in LAB 
===============================================================================

1. Given: kcmkfs.c file in samples/LAB5

   Write YOUR own C code for 

         get_block(int dev, char *buf, int blk);
         put_block(int dev, char *buf, int blk);

   where dev is an opened file descriptor of a "DEVICE", such as a FD. 

         set_bit(char buf[], int bit);
         clr_bit(char buf[], int bit):
         
         make_bmap();
         make_imap();

   to make the program kcmkfs.c complete. DEMO YOUR WORK on Wednesday,3-19


2. ASSUME: mkfs /dev/fd0 1440  OR  kcmkfs /dev/fd0 1440 184   
   Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode info
6. dir.c    : dir_entries of the root directory.
-------------------------------------------------------------------------


//Sample dir.c code

<PRE>

#include &lt;fcntl.h&gt;
#include &lt;linux/ext2_fs.h&gt;

// define shorter TYPES
typedef struct ext2_group_desc    GD;
typedef struct ext2_super_block   SUPER;
typedef struct ext2_inode         INODE;
typedef struct ext2_dir_entry_2   DIR;  

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 


char buf[1024], rbuf[1024];
int fd, blk, i;

int get_block(int blk, char *buf)
{
  // read disk blk into buf[ ]
}

main()
{
  char *cp, temp[256];

  fd=open("/dev/fd0", O_RDONLY);

  get_block(5, buf);      // get root inode block
  ip = (INODE *)buf + 1;  // it's inode #2

  for (i=0; i<12; i++){   // ASSUME dir has only direct blocks
    blk = ip->i_block[i];
    printf("i_block[%d] = %d\n", i, blk);  // print blk number
    if (blk==0)
       break;

    get_block(blk, rbuf); // get block contents into rbuf[] 
    
    dp = (DIR *)rbuf;     // as DIR entries
    cp = rbuf;            
 
   while(cp &lt; &rbuf[1024]){
      bzero(temp, 256);
      strncpy(temp, dp->name, dp->name_len);

      // print DIR entry info
      printf("%4d %4d %4d  %s\n", dp->inode, dp->rec_len, dp->name_len, temp);
      // In addition to printing, CAN YOU SEARCH FOR A name STRING? 
      // OR SEARCH FOR A INOODE NUMBER?
      
      cp += dp->rec_len;
      dp = (DIR *)cp;
   }
  }
}







<html>
<Body bgcolor="#00cccc" text="#000000">
<H1>CS360 Lab Assignment #3 : sh Simulator</H1>
<pre>

                DUE & DENO : To be posted

A. OBJECTIVE:
   Understand how Unix sh works by using fork/wait/exec.
   String operations

B. REQUIREMENTS:
   Write a C program, mysh, which simulates the Unix sh for command processing.
   Your mysh should run as follows:

1. Prompt for an input line, which is of the form
          cmd arg1 arg2 arg3 .... argn
   where cmd is a command.

   For simplicity, do NOT consider sh scripts files.
   Valid commands include only "echo", "cd", "exit", and ANY Unix binary 
   executables, e.g. ls, date, pwd, cat, cp, mv, cc ... you name it !!!


2. Handle simple commands:
     cmd = "cd"   :  chdir(arg1) OR chdir($HOME) if no arg1;
     cmd = "echo" :  echo the remaining line;
     cmd = "exit" :  exit(1) to terminate;  

   NOTE: chdir(pathname) is a syscall to change CWD.
         $HOME is the home directory; YOU must find its value from *env[ ].

3. For all other commands:
      fork a child process;
      wait for the child to terminate;
      print child's exit status code
      continue step 1;

4. Child process:
   4-1. Handle I/O redirection:
          cmd  arg1 arg2 ...  <  infile    // take inputs from infile
          cmd  arg1 arg2 ...  >  outfile   // send outputs to outfile
          cmd  arg1 arg2 ...  >> outfile   // APPEND outputs to outfile
        For simplicity, assume at most ONE I/O redirection per line.

   4-2. Execute cmd by execve(), passing parameters 
                char *myargv[], char *env[]
        to the cmd file, 
        where myargv[0]->cmd, myargv[1]->arg1, ....., ending with NULL pointer

        NOTE: if cmd begins with /, execute it directly.
              otherwise, try to execute pathdir/cmd for every pathdir in $PATH


5. SAMPLE SOLUTION:
   
   ~samples/LAB3/lab3.bin          (down load and run under Linux)

===========================  I/O Redirections ===============================

6. I/O Redirections:

6-1. Stream FILEs and File Descriptors:
   Recall that the sh process has 3 stream FILEs: stdin, stdout, stderr.
   When sh forks a child, the child process also has the same FILE streams.
   Each of the FILE streams corresponds to an opened file in the Unix kernel.
   Each opened file has a unique file descriptor (number). The file descriptors
   of stdin, stdout, stderr are 0,1,2, respectively.

6-2. Stream I/O and System Call:
   When a process executes        scanf("formatString", &item);
   it tries to input an item from stdin, which points to a FILE struct.If the
   FILE struct's buffer is empty, it issues a system call to the Unix kernel,
   to READ data from the file descriptor 0, which is mapped to the terminal
   (/dev/ttyX) of the sh process.

                      REDIRECT INPUT: 
   If we let stdin point to the FILE struct of a diffferent file that's 
   opened for input, then every scanf() would read inputs from the new file.
   So, if we do
              fclose(stdin);
   which erases the FILE struct pointed by stdin, casuing stdin to be NULL, 
   followed by
              stdin = fopen("filename", "r");
   which fopens filename for READ and let stdin point at the new FILE struct,
   then scanf() would get inputs from the file filename.
   
   The FILE struct of stdin contains a file descriptor 0. If we replace the 
   file descriptor 0 with a newly opened file, we would achieve the same 
   effect. Thus, if we do 
           close(0);    // system call to close file descriptor 0
           open("filename", O_RDONLY);  // open filename for READ, which
                                        // will replace fd 0
   Then, every scanf() call will get inputs from the opened file.


   Similarly, when a process executes      printf("formatString", item);
   it tries to write to stdout, which points to a FILE struct. If the FILE
   struct's buffer is full, it issues system call to the Unix kernel to
   write data to file descriptor 1, which is mapped to the terminal screen.

                       REDIRECT OUTPUT: 
   If we 
          fclose(stdout);
   which erase the FILE struct of stdout, followed by
          stdout = fopen("filenmae", "w");
   which opens filename for WRITE and let stdout point to the FILE struct,
   then printf() would send outputs to filename. More directly, we may keep
   stdout and its FILE struct but let file descriptor 1 point at a different
   file. Thus, if we
          close(1);
          open("filename", O_WRONLY|O_CREAT, 0644); 
   which change file descriptor 1 to point to a file, then the outputs will 
   go to that file instead of the screen. 
  
   When a process dies (in Kernel), it cloes all opened files, (causing
   data to be written out to disk ..

6-3 Use man open to read more on how to issue syscalls 
        open(), read(), write(), close(), 
    and (I/O library functions)
       fopen(), fclose()
              









<Title>460 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 Notes #5</H1>
<Pre>
         360 Notes on Process Management in Unix

1. Read Unix man pages on
        fork, exec, wait, exit,  
        kill, signal,  

2. Process:
   A process is a sequence of executions regarded as a single entity by the 
   Unix kernel. Each process has a unique pid and a ppid, which identify the
   process and its parent process, respectively. Processes in Unix form a 
   family tree. They compete for CPU time to run. 

3. Process Origin:
   How does a process begin? As explained before, when Unix starts, it creates
   a process P0 by brutle force. P0 creates (by fork) a child process P1, which 
   is the INIT process. P1 forks many children processes, one on each terminal 
   as the LOGIN process on that terminal. Each LOGIN process opens 3 stream FILEs, 
   stdin, stdout, stderr. It displays login: to its stdout and waits for a user to 
   login. After a user login, the LOGIN process becomes the user process. Typically, 
   the user process execute sh, so it's known as the sh process. 
   When sh sees an a.out command, it forks a child process to execute a.out. The sh 
   process "waits" until the child process dies. Then it prompts for another command.  

4. Process Image:
   In Unix, a process executes in two different modes; Kernel mode or User 
   mode, denoted by Kmode or Umode, for short. In each mode, a process has
   an "execution image", as shown by the following figure.

                  Images of Process i:
       ------------------------------------------ 
       Kmode :    Kcode_i  Kdata_i   Kstack_i
       ==========================================
       Umode :    Ucode_i  Udata_i   Ustack_i
       ------------------------------------------
   The index i indicates these are the images of process i. In general, the 
   Umode images of different processes are all different. While in Kmode they 
   share the same Kcode and Kdata, which are those of the Unix Kernel. However,
   Each process still has its own Kstack.
    
   A process migrates between Kmode and Umode many many times during its life
   time.

   Every process comes into existence and begins execution in Kmode. In fact,
   it does everything of interest, including to die (or terminate), in Kmode. 
   While in Kmode, it can come to Umode easily (by changing CPU's status from 
   K to U mode) However, once in Umode it cannot change CPU's status  
   arbitrarily. A Umode process can enter Kmode in only one of 3 ways:

   (1). Interrupts : Interrupts are hardware signals to the CPU. When an
                     interrupt occurs, CPU will enter Kmode to handle the 
                     interrupt, which causes the process to enter Kmode. 
   (2). Traps: Traps are error conditions, such as invalid address, illegal 
               instruction, divide by 0, etc. recognized by the CPU, causing it
               to enter Kmode to deal with the error. Since traps are caused by
               the executing process on the CPU, the process typically dies
               (with a dreadful message such as "Segmentation Fault").

   (3). System Calls:
        System call (or syscall for short) is a mechanism that allows a process
        to enter Kmode to execute Kernel functions. When the Kernel function 
        finishes, it comes back to Umode with a return value, which is normally
        0 for success or -1 for error. In case of error, the global int 
        variable errno (in errno.h) contains an ERROR code which further 
        identifies the error.

        In the following, we shall discuss these syscalls:
           fork(), wait(), exec(), exit(), chdir(), open(), close() 

5. Process Management in Unix:

5-1. fork():  Usage:   int pid = fork();
     fork() creates a child process and returns the child's pid or -1 if error.
     The following diagram shows the actions of fork().


               PROCi                      |      PROCj
              --------                    |      -------
    Kmode :    Kcodei   kfork(){....}     |                    ( When Pj runs:)
               Kdatai        ^       |    |                          |
               kstacki       |       |    |      Kstackj             V
   ========================  |  ==== | ===========================   | =======
    Umode :    Ucodei  pid=fork(); <-     |      Ucodej  pid=fork();<-
               Udatai                     |      Udataj
               Ustacki                    |      Ustackj


   (1). The left hand side shows the images of a process Pi, which issues
        the syscall   pid=fork();    
   (2). Pi goes to Kmode to execute the corresponding kfork() function, in 
        which it creates a child process PROCj with Kstackj and Umode image of
        Pj, as shown in the right hand side of the diagram.
 
        The Umode image of Pj is an IDENTICAL copy of Pi's Umode image.

        Thus, Pj's Ucodej also has the statement
                   pid=fork();

   (3). After creating Pj, Pi returns to the statement  
              pid = fork();
        in Ucodei with the child's pid = j.

   (4). When Pj begins to run, it exits Kmode and returns to the same statement
              pid = fork();
        with a 0 value in ITS OWN Umode image. 

   Example 1: Consider the C program:

        main()
        {
           int pid;
           printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid()); 

           pid = fork();   // fork syscall; parent returns child pid, 
                           //               child returns 0

           if (pid < 0){   // fork() may fail. e.g. no more PROC in Kernel
               perror("fork faild");
               exit(1);
           }
           
           if (pid){ // PARENT EXECUTES THIS PART 
                  printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid());
           } 
           else{ // child executes this part
                  printf("I am    %d  my parent=%d\n", getpid(), getppid());
           }
        }


5-2. pid = wait(int *howDidChildDie);

     wait() returns a dead child's pid and its exit code=[exit#|sig#]
            As usual, it returns -1 if error, e.g. caller has no child.

     Note:  if caller has more than one child, wait() returns ANY dead child.
               exit# is the exit(VALUE) used by child to die,
               sig#  is the (signal) number that caused the child to die.
            ONLY one of the numbers will be present, WHY?

     main()
     {
       int pid, status;
       pid = fork();
       if (pid){ // PARENT:
           printf("PARENT %d WAITS FOR CHILD %d TO DIE\n", getpid(),pid);
           pid=wait(&status);
           printf("DEAD CHILD=%d, HOW=%04x\n", pid, status);
       }
       else{// child:
           printf("child %d dies by exit(VALUE)\n", getpid());
           exit(100);  //OR {int a,b; a=b/0;} ==> see how does it die
       }
     }

5-3. Execution Order:
     After fork(), the child process competes with all other processes
     for CPU time to run. Which process will run next depends on their 
     scheduling prioirty, which changes dynamically.
 
     main()
     {
        int pid;
        pid=fork();
        if (pid){ // PARENT
           printf("PARENT %d DYING\n", getpid());
        }
        else{ // child
               printf("child %d sleeps for 2 seconds\n");
               sleep(2); // sleep for 2 seconds ==> PARENT DIES FIRST
               printf("child %d my parent=%d\n", getpid(), getppid());
        }
     }

5-4. Parent Process
     When a process dies (in Kmode), it becomes a ZOMBIE, i.e. its PROC is 
     marked as ZOMBIE and contains information, such as exit code. When the 
     parent process finds a ZOMBIE child (by wait() syscall), it collects the 
     needed information from the ZOMBIE PROC and finally lay the dead body to 
     rest, i.e. set the ZOMBIE PROC to FREE for recycle again. Thus, a process
     MUST have a parent at all times. However, because of the (independent) 
     process execution order, a process with children may die first. Similar 
     to humman society, such children are called orphans. The natural question
     is: who should be the "parent" of such orphans? In humman society, they 
     would be sent to grandma's house. But what if gradma also died? In Unix,
     the parent of all orphans is P1. Thus, P1 wears many hats:
     It's the grand dad of ALL user processes. It's the head of an orphange, 
     and it's also the manager of a morgue (which buries DEAD bodies). 
                  
5-4. nice(VALUE); 
     Decrease caller's scheduling priority by VALUE, allowing other processes
     to run first.

6. Change Execution Image:

   A process may use exec() to change its USER mode image to another 
   (executable) file. The exec() library functions have several members:
 
     int execl( const char *path, const char *arg, ...);
     int execlp(const char *file, const char *arg, ...);
     int execle(const char *path, const char *arg , ..., char *const envp[]);
     int execv( const char *path, char *const argv[]);
     int execvp const char *file, char *const argv[]);

   All of them eventually issue the syscall

     int execve(const char *filename, char *const argv[], char *const envp[]);

   which is the basis of the C function

         main(int argc, char *argv[], char *env[])


   If successful, exec("filename",....) replaces the current Umode image with
   a new image generated from the executable filename. It's the SAME process 
   but with a new Umode image. The old Umode image is abandoned and therefore
   never returned to, unless exec() fails, e.g. filename is non-executable.

   This is similar to a person who goes to Heaven (Kernel) from where he/she
   builds a new house on Earth (Umode), burns down the old house (IRS allows 
   only one house per person?) and returns to the new house to begin a new life
   there. Naturally, the person must return to the same old house if the new
   house cannot be built.
    
Example #1 : Use execl(), which is of the form 
                     
             execl("a.out", "a.out", string1, string2, ..., 0);

----------- cc to a.out ---------------------------------
 main(int argc, char *argv[])
{
  printf("THIS IS %d IN %s\n", getpid(), argv[0]);
  execl("b.out", "b.out", "hi", 0);
  printf("SHOUDL NOT SEE THIS LINE\n");
}  

----------- cc to b.out ---------------------------------
main(int argc, char *argv[])
{
  printf("this is %d in %s\n", getpid(), argv[0]);
  while(1);
}
----------------------------------------------------------


7. Signals and Signal Handling:

(1). A signal is a number from 1 to 31, as defined in &lt;asm/signal.h&gt;

(2). Signal Sources:
     traps      : errors recognized by CPU as "traps", e.g. 
                  divide by 0, illgal instruction, invalid address, ....
     interrupts : Control_C, HangUp, ...
     pre-defined: death_of_child,...
     sent by other processes via kill()

(2). kill(pid, signal#): send signal# to pid; signal#=1 to 31.

     main()
     {
       int pid, status;
       pid=fork();
       if (pid){// PARENT
                  kill(pid, 8);
                  pid=wait(&status);
                  printf("dead child=%d, how=%4x\n", pid, status);
                 }
       else{ // child
             while(1);  // while happily looping, child will die by sig# 8
           }
      }
============================================================================


(3). signal(sig#, ACTION); install a signal handler for sig#, 
            where ACTION = 0 ==> default action by Unix Kernel;
                           1 ==> ignore the signal (except #9)
                           &catcher() in user space.

#include &ltsignal.h&gt
#include &ltsys/time.h&gt

/**********************************************************
struct itimerval {
                struct timeval it_interval;
                struct timeval it_value;   
            };

struct timeval {
                long tv_sec;               
                long tv_usec;              
            };

int  setitimer(int which,  const  struct  itimerval  *value, struct
              itimerval *ovalue);
**************************************************************/

struct itimerval t;

int h, m, s;

void catcher(sig) int sig;
{
  printf("in catcher, sig=%d\n", sig);
}

main()
{

 t.it_interval.tv_sec = 1;    // interval=1 second
 t.it_interval.tv_usec= 0;

 t.it_value.tv_sec = 2;       // after 2 seconds 
 t.it_value.tv_usec= 0;

   signal(SIGALRM, (void *)catcher);   // install catcher for signal 14

   setitimer(ITIMER_REAL,&t,0);        // set interval timer REAL mode

 while(1);                             // sits here in a loop;

} 

<Title>360 Week 2 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes on Assembly Programming</H1>

<Pre>
   
              360 NOTES on Assembly Programming

1. Implement C functions in Assembly:

Example 1: Functions for getting CPU registers

main()
{
   int ebp, esp;
   ebp = get_ebp();
   esp = get_esp();
   printf("ebp=%8x   esp=%8x\n", ebp, esp);
}

=============================

	.global get_esp, get_ebp

get_esp:
         movl	%esp, %eax
         ret

get_ebp:
	movl	%ebp, %eax
	ret
=============================
EXERCISE: Write assembly functions for getting ebx, ecx, edx, esi and edi


Examples 2. A function that computes the sum of 2 integers

main()
{ 
  int a,b,c;
  a = 100; b = 200;
  c = mysum(a,b);
  printf("c=%d\n", c);
}

==========================
# int mysum(int x, int y)

        .global mysum
mysum:
# establish stack frame
        pushl	%ebp
        movl	%esp, %ebp

        movl	 8(%ebp), %eax
        addl	12(%ebp), %eax     
         
# return to main
        leave       # same as  { movl %ebp,%esp;  pop %ebp }
        ret


2. Call C functions from Assembly:

Example 3: Access global variables
 
int a, b;

main()
{
   a = 100;  b = 200;
   sub();
}

===================================

        .global sub, a, b, printf
sub:
        pushl   %ebp
        movl    %esp, %ebp

        pushl   b
        pushl   a
        pushl   $fmt
        call    printf
        addl    $12, %esp
        
        movl    %ebp, %esp
        popl    %ebp
        ret

fmt:	.asciz	"a=%d  b=%d\n" 
====================================

Example 4: Assembly function format:

# entry:
          pushl  %ebp
          movl   %esp, %ebp 
----------------------------------

    # Actual code of fucntion 

----------------------------------
# exit:    leave
           ret
   <Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>
                
<Pre>
                     HOWTO cat_cp_mv

int cat_file()
{
  ask for a pathname to cat

  mycat(pathname);

}

// with open() and read(), mycat() is almost trivial
 
int mycat(pathname) char *pathname;
{
 fd = myopen(pathname, 0);  // call OUR own myopen() to open file for READ

 loop:
       read 1 BLOCK, printf() to show the chars;
       UNTIL end file

 myclose(fd);
 
 return(0);
}


NOTE: For simplicity, consider cp (or mv) of a SINGLE file only.
      However, files may have DOUBLE-INDIRECT BLOCKs !!!!

int cp_file()
{
    ask for 2 pathnames, src and dest, for cp src to dest.
    
    call mycp(src, dest) to do the actual cp
}


int mycp(char *src, char *dest)
{
   AS USUAL, NEVER cp a file to itself !!

   open src for READ   ==> fd
   creat f2 if not exists;
   open dest for WRITE ==> gd; 
   loop:
         n = read(fd, buf, nbytes);
         write(gd, buf, n);
   while (n>0)
   close fd;
   close gd;
}




int mv_file()
{
    ask for 2 pathnames src and dest for mv  src to dest

    return mymv(src, dest);
}


int mymv(char *srcf1, char *dest)
{
  Case 1: same dev:
          Listen to lecture

  Case 2: differnet dev (with mounted FS):
          mycp(src, dest);
          rm src;
}







<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Project Help #2</H1>

<Pre>

                 Simulator Data Structure Diagram

   KEEP A COPY OF THIS DIAGRAM FOR REFERENCE when designing your algorithms.


1. RunningPtr

     |
     V        |---- PointerToCWD ------|
              |                        |
2  PROC[]     |    3. OFT[ ]           V 4.MINODE[]              Disk dev
 ===========  |    ===========          ============       ===================
  nextProcPtr |     mode                  INODE            |         INODE   |
  pid, ppid   |     refCount             -------           =================== 
  uid, gid    |     MinodePtr            dev,ino
  cwd --------|     offset               refCount          
                  ===========            dirty
  fd[10]                                 mounted
  ------                                 mTablePtr -----------
  ------                                 filename[]          |
  ------                                                     |
  ------                                ============         |  
 ==========                               INODE              |
                                         -------             |
                                         dev,ino             |
                                         refCount            |  
                                         dirty               |
                                         mounted             |
                                         mTablePtr           |
                                         filename[]          |
                                        ============         |
                                                             |
            PointAtRootInode                                 |
                   ^                                         V
                   |                                    PointAtMountTable[0]
                   |      5.   MuntTable[ ]
                   |  ------- 0 --------- 1 ----------
                   |  | dev          |            |
                   |--| MinodePtr    |            |
                      |............. |            |
                      | deviceName   |            |
                      | MinodePath   |            |
                      |              |            |
                      | nblocks      |            |
                      | ninodes      |            |
                      ---------------------------------  



This diagram shows the data structures of the file system simulator.

1. is a PROC pointer pointing at the PROC structure of the current running 
   process.  Each process has a Currnet Working Directory, cwd, which is
   initialized to point at the in-memory root inode.

2. is the PROC structure of processes. Everything in the simulator is performed
   by the current ruuning process.

3. is the Open File Table (OFT). Each OFT entry represents an instance of an 
   opened file. We shall discuss OFT later when dealing with Level-2.

4. is the in-memory inodes array, MINODE[100]. Each minode entry contains a 
   sub-structure INODE, which is the INODE struct on Disk.  Whenever a file
   (regular or DIR) is referenced, its inode must be brought into memory. In 
   order to ensure ONLY ONE copy of every inode in memory, a needed inode will
   be loaded into a MINODE slot. The (dev, ino) field identifies where the 
   inode came from (for writing it back to disk). The refCount keeps track of
   how many processes are using this minode. The dirty field tells whether the
   INODE has been modified or not. If an minode is dirty, the last user of the
   minode must write the INODE back to disk. The mounted flag says whether 
   this DIR has been mounted on or not. If mounted on, the mTablePtr points at
   the MountTable entry.

5. is the MountTable (MT). Each entry represetns a device that has been 
   mounted (on a DIR).  When a file system starts, it must mount a device on
   the Root DIR /. That device is called the root device. So the first thing
   our simulator does is also to mount-root.  As shown, MT[0] represents the
   root device. The dev field identifies which device this is. The MinodePtr
   points at the DIR that's mounted on. (in 4, the DIR also points back to the
   mounted device). Knowing the dev, we can always access the device to get 
   its Superblock, bitmaps, rootInode, etc. For convenience, some often
   used information are kept in the MountTable for quick reference, e.g. 
   nblocks, ninodes. Here is an exmple of their usage: If process wants to 
   release an inode, it calls dealloc(ino) to deallocate the inumber of the 
   inode. The caller may pass in an ino > actual number of inodes (hence 
   exceeds the range of the inodes bitmap). We can check the ino against 
   ninodes to avoid tunning the worng bits on in the bitmap. Similarly for 
   nblocks. 



<html>
<body>
<pre>

                NOTES #11 EXT2 File System on FD

Under Linux, the command  mkfs /dev/fd0 1440  makes an EXT2 file system on a 
1.44MB floppy disk. It also reports some statistics, such as block size=1024, 
184 inodes, 1440 blocks, etc. Linux's mkfs creates an EXT2 file system with a
default lost+found directory. You may use the commands  
        mount /dev/fd0 /mnt;  rm -r /mnt/*;   umount /mnt
to make the file system empty.
 
The layout of an EXT2 file system on a floppy disk is 

   |Boot|Super| Gd |Bmap|Imap|Inodes blocks .....|data blocks ..........|
      0    1    2    3     4    5  ..............| .....................|

The block contents are explained below.

Block#0: Boot Block:
  B0 is the boot block, which is not used by the file system.

Block#1: Super Block:
  B1 is the Superblock, described by the super_block structure, where only the
  essential fields are (shown and) explained. You may ignore the other fields.

struct ext2_super_block {
  unsigned long  s_inodes_count;       // total number of inodes
  unsigned long  s_blocks_count;       // total number of blocks
  unsigned long  s_r_blocks_count;     
  unsigned long  s_free_blocks_count;  // current number of free blocks
  unsigned long  s_free_inodes_count;  // current number of free inodes 
  unsigned long  s_first_data_block;   // first data block in this group
  unsigned long  s_log_block_size;     // 0 for 1KB block size
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;   // 8192 blocks per group 
  unsigned long  s_frags_per_group;
  unsigned long  s_inodes_per_group;    
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_count;          // number of times mounted 
  short          s_max_mnt_count;      // mount limit
  unsigned short s_magic;              // 0xEF53
  // A FEW MORE non-essential fields
};

Block#2: Group Descriptor Block
EXT2 divides disk blocks into GROUPs. Each group contains 8192 (contiguous)
blocks. Each group is described by a group_desc structure of 32 bytes:

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;          // Bmap block number
  unsigned long  bg_inode_bitmap;          // Imap block number
  unsigned long  bg_inode_table;           // Inodes begin block number
  unsigned short bg_free_blocks_count;     // THESE are OBVIOUS
  unsigned short bg_free_inodes_count;
  unsigned short bg_used_dirs_count;        

  unsigned short bg_pad;                   // ignore these 
  unsigned long  bg_reserved[3];
};

A FD has only 1440 blocks. So, B2 contains only 1 group_desc structure (The
rest are 0's).

Block#3: Block Bitmap (Bmap):
A bitmap is a sequence of bits used to represent some kind of items, e.g. disk
blocks or inode structures. Bitmaps are used to allocate/deallocate items. In a
bitmap, a 0 bit means the corresponding item is FREE, and a 1 bit means the 
corresponding item is in USE. A FD has 1440 blocks but block#0 is NOT used by
the file system. So, the Bmap has only 1439 valid bits in B3. The exact values 
of Bmap will be shown later.

Block#4: Inode Bitmap (Imap)
An inode is a data structure used to represent a file. A file system is created
with a finite number of inodes. The status of the inodes are represented by a
a bitmap, called the Imap, in B4. 
In an EXT2 FS, the first 10 inodes are reserved. Thus, the Imap of an empty FS
starts with TEN 1's, followed by 0's.

Block#5: Inodes (begin) Block
In Unix, every file is represented by a UNIQUE inode structure of 128 bytes, 
defined as follows.

struct ext2_inode {
  //*************************************************************************
  unsigned short i_mode;                      // will be explained in detail 
  unsigned short i_uid;                       // ownerID
  unsigned long  i_size;                      // file size in bytes
  unsigned long  i_atime;                     // time fields  
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;                       // groupID
  unsigned short i_links_count;               // link count
  unsigned long  i_blocks;                    // IGNORE
  unsigned long  i_flags;                     // IGNORE
  unsigned long  i_reserved1;                 // IGNORE
  unsigned long  i_block[15];                 // See details below
  //**************************************************************************

  // IGNORE THE FOLLOWING
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsigned long  i_reserved2[2
}

The fields i_block[15] record the disk blocks (numbers) of a file, which are 

    DIRECT blocks : i_block[0] to i_block[11], which point to direct blocks.
    INDIRECT block: I_block[12] points to a block, which contians 256 (ulong) 
                    block numbers.
    DOUBLE INDIRECT block: 
                    I_block[13] points to a block, which points to 256 blocks,
                    each of which point to 256 blocks.
    TRIPLE INDIRECT block: 
                    I_block[14] points to a block, which points to 256 blocks,
                    each of which points to 256 blocks, each of which points to
                    256 blocks.
    
The total number of inodes is always a multiple of 8 (so that every inodes 
block is full). The number of inode blocks is therefore
                    (total number of inodes)/8. 
For example, if the number of inodes is 184, then the inode blocks include 
B5, B6, B7, ...., B27.


Data Blocks:
Immediately after the inode blocks are the data blocks. In the example of 184
inodes, the first real data block is B28, which is i_block[0] of the root
directory /.


EXT2 Directory Entries:
A directory contains dir_entry sturctures. In EXT2, component file names can 
vary form 1 to 255 chars long. So the dir_entries also have varying length. 

struct ext2_dir_entry_2 {
	unsigned long  inode;        // Inode number; count from 1, NOT from 0
	unsigned short rec_len;      // This entry length in bytes
	unsigned char  name_len;     // Name length in bytes
	unsigned char  file_type;    // for future use
	char   name[EXT2_NAME_LEN];  // File name: 1-255 chars, no NULL byte
};

                  HOW TO STEP THROUGH dir_entries:

Example: Assume the root directory / contains entries 
                this  is  aVeryLongName short
Then the 0th data block (i_block[0] in its inode) of this DIR file contains:
 
|2 12 1.|2 12 2..|11 12 4this|12 12 2is|13 24 13aVeryLongName|14 952 5short   |

Each record has a rec_len and a name_len field, which will be explained later.

First, read the block into a char buf[1024].
Let DIR *dp and char *cp BOTH point at buf;
Use dp-> to access the fields of the record, e.g. print the name

                    TO MOVE TO THE NEXT entry:
        cp += dp->rec_len;       // advance cp by rec_len BYTEs
        dp = (shut-up)cp;        // pull dp along to the next record

This way, you can step through ALL the record entries of a DIR file.


************************ Mailman's Algorithm by KCW *************************
Each inode is determined uniquely by its POSITION (counting from 0,1,2,...) in
the inode area. The position PLUS 1 is called the inode number (i_number or 
ino for short), which counts from 1. (A 0 i_number means no inode). In an EXT2
FS, the root inode is inode #2.
                       
                             QUESTION:
----------------------------------------------------------------------------
 Given an i_number, such as 123, how to find the inode in the inode blocks?
 i.e. which inode block?  which inode in that inode block?
 This problem has a more general form:

                         Mailman's Algorithm:
 A city has M blocks, numbered 0,1,2,..,M-1. Each block has N houses, numbered 
 0,1,..,N-1.
 Each house has a unique BLOCK address in the form
                BA = (BLOCK, HOUSE)
 A house also has a unique LINEAR address 
                LA = 0,1,2,..,N-1, N,N+1,......

                            PROBLEM:
 Given a linear address LA, e.g. 123, determine its BLOCK address, and vice 
 versa. The solution is called the Mailman's algorithm:
 
 IF everything counts from 0,the algorithm is very simple:

                    BA = (LA / N, LA % N)
                    LA = N*BLOCK + HOUSE

 It is so simple that you may ask: What's all the fuss about?
 QUESTION: WHAT IF they do not count from 0?
============================================================================
Applications of Mailman's Algorithm:

1. Test, Set, Clear BITs in C:
   Consider  char buf[1024]; buf[] has 1024 bytes, known as buf[i], i=0,1,2,.. 
   It also has 8192 BITs numbered 0,1,2,....

   Given a bit number BIT, e.g. 1234, which byte i contains the bit, and which 
   bit j is it in that byte?
   Solution:
               i = BIT / 8
               j = BIT % 8

   To TST a bit at BIT:  if ( buf[i] & (1 << j) )

   To SET a bit at BIT:  buf[i] |=  (1 << j);
     
   To CLR a bit at BIT:  buf[i] &= ~(1 << j);
 
2. Convert i_number to inode:
   In an EXT2 FS, inodes begin in the inode_table block (block 5 for FD).
   Each inode has a unique i_number = 1,2,.....

   Given an i_number, e.g. 1234, determine which disk block# contains that
   inode, and which inode# is it in that block?

   We need to know the block# because READ/WRITE real disk is always in block,
   can't just read/write an item inside a disk block.    

   Soution:  block# = (i_number - 1)/INODES_PER_BLOCK + inode_table;
             inode# = (i_number - 1)%INODES_PER_BLOCK;

   TRY TO ANSWER FOR YOURSELF: WHY i_number-1? and WHY + inode_table
   
3. Convert disk block# to CHS = (cyl, head, sector) of a REAL disk:
   A FD has 80 cylinders, each cylinder has 2 tracks (heads), each track has
   18 sectors. A hard disk just has many MORE cylinders, heads and sectors.
 
   Given a (linear) block#, e.g. 1234, determine its (cyl, head, sector) on
   the disk. Some disk drivers takes only (cyl,head,sector) for disk I/O.
*****************************************************************************

All the struct types are defined in 
&ltlinux/ext2_fs.h&gt

==========================================================================
#include &ltstdio.h&gt
#include &ltfcntl.h&gt
#include &ltlinux/ext2_fs.h&gt

// define shorter TYPES, save typing efforts
typedef struct ext2_super_block SUPER;
typedef struct ext2_group_desc  GD;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

==============================================================================

                            EXERCISES

ASSUME: mkfs /dev/fd0 1440
Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode
6. dir.c    : dir_entries of the root directory.
-------------------------------------------------------------------------

<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Linux EXT2 File System</H1>

<Pre>

The Second Extended File system (EXT2)

1. Groups

An EXT2 disk partition is divided into groups (of 8K blocks). Each group 
contains in the order: 

    Superblock 

    Group Descriptors 

    Block bitmap of the group

    Inode bitmap of the group

    Inodes of the group

    Data blocks of the group 


2. The EXT2 Superblock

  The Superblock contains information about the entire file system.
Amongst other information it contains:

Magic Number 
    This allows the mounting software to check that this is indeed the 
    Superblock for an EXT2 file system. For the current version of EXT2 this 
    is 0xEF53. 
Revision Level 
    The major and minor revision levels allow the mounting code to determine 
    whether or not this file system supports features that are only available 
    in particular revisions of the file system. There are also feature
    compatibility fields which help the mounting code to determine which new 
    features can safely be used on this file system, 
Mount Count and Maximum Mount Count 
    Together these allow the system to determine if the file system should be 
    fully checked. The mount count is incremented each time the file system is
    mounted and when it equals the maximum mount count the warning message 
    ``maximal mount count reached, running e2fsck is recommended'' is 
    displayed, 
Block Group Number 
    The Block Group number that holds this copy of the Superblock, 
Block Size 
    Block size used by the file system.
Blocks per Group 
    The number of blocks in a group. Like the block size this is fixed when 
    the file system is created, 
Free Blocks 
    The number of free blocks in the file system, 
Free Inodes 
    The number of free Inodes in the file system, 
First Inode 
    This is the inode number of the first inode in the file system. 

The detailed structure of an ext2fs superblock is [include/linux/ext2_fs.h]: 

struct ext2_super_block {
  unsigned long  s_inodes_count;
  unsigned long  s_blocks_count;
  unsigned long  s_r_blocks_count;
  unsigned long  s_free_blocks_count;
  unsigned long  s_free_inodes_count;
  unsigned long  s_first_data_block;
  unsigned long  s_log_block_size;
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;
  unsigned long  s_frags_per_group;
  unsigned long  s_inodes_per_group;
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_count;
  short          s_max_mnt_count;
  unsigned short s_magic;
  unsigned short s_state;
  unsigned short s_errors;
  unsigned short s_pad;
  unsigned long  s_lastcheck;
  unsigned long  s_checkinterval;
  unsigned long  s_reserved[238];
};

s_inodes_count 
    the total number of inodes on the fs. 

s_blocks_count 
    the total number of blocks on the fs. 

s_r_blocks_count 
    the total number of blocks reserved for the exclusive use of the superuser.

s_free_blocks_count 
    the total number of free blocks on the fs. 

s_free_inodes_count 
    the total number of free inodes on the fs. 

s_first_data_block 
    the position on the fs of the first data block. Usually, this is block 
    number 1 for fs containing 1024 bytes blocks and is number 0 for other fs. 

s_log_block_size 
    used to compute the logical block size in bytes. The logical block size is
    in fact 1024 << s_log_block_size. 

s_log_frag_size 
    used to compute the logical fragment size. The logical fragment size is in
    fact 1024 << s_log_frag_size if s_log_frag_size is positive and 1024 >> 
    -s_log_frag_size if s_log_frag_size is negative. 

s_blocks_per_group 
    the total number of blocks contained in a group. 

s_frags_per_group 
    the total number of fragments contained in a group. 

s_inodes_per_group 
    the total number of inodes contained in a group. 

s_mtime 
    the time at which the last mount of the fs was performed. 

s_wtime 
    the time at which the last write of the superblock on the fs was performed.

s_mnt_count 
    the number of time the fs has been mounted in read-write mode without 
    having been checked. 

s_max_mnt_count 
    the maximum number of time the fs may be mounted in read-write mode before
    a check must be done. 

s_magic 
    a magic number that permits the identification of the file system. It is 
    0xEF53 for a normal ext2fs and 0xEF51 for versions of prior to 0.2b. 

s_state 
    the state of the file system. It contains an or'ed value of EXT2_VALID_FS
    (0x0001) which means: unmounted cleanly; and EXT2_ERROR_FS (0x0002) which 
    means: errors detected by the kernel code. 

s_errors 
    indicates what operation to perform when an error occurs. See section 
    Error Handling 

s_pad 
    unused. 

s_lastcheck 
    the time of the last check performed on the fs. 

s_checkinterval 
    the maximum possible time between checks on the fs. 

s_reserved 
    unused. 

Times are measured in seconds since 00:00:00 GMT, January 1, 1970. 



3. The EXT2 Group Descriptor

  Each Group is described by a data structure called the Group Descriptor.
Like the Superblock, all the group descriptors for all of the Block Groups are
duplicated in each Block Group in case of file system corruption. 

Each Group Descriptor contains the following information: 

Blocks Bitmap 
    The block number of the block allocation bitmap for this Block Group. 
    This is used during block allocation and deallocation, 
Inode Bitmap 
    The block number of the inode allocation bitmap for this Block Group. 
    This is used during inode allocation and deallocation, 
Inode Table 
    The block number of the starting block for the inode table for this Block 
    Group. Each inode is represented by the EXT2 inode data structure 
    described below. 
Free blocks count, Free Inodes count, Used directory count 

The group descriptors are placed one after another and together they make the 
group descriptor table. Each Blocks Group contains the entire table of group 
descriptors after its copy of the Superblock. Only the first copy (in Block
Group 0) is actually used by the EXT2 file system. The other copies are there,
like the copies of the Superblock, in case the main copy is corrupted. 

On disk, the group descriptors immediately follow the superblock and each 
descriptor has the following layout: 

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;
  unsigned long  bg_inode_bitmap;
  unsigned long  bg_inode_table;
  unsigned short bg_free_blocks_count;
  unsigned short bg_free_inodes_count;
  unsigned short bg_used_dirs_count;
  unsigned short bg_pad;
  unsigned long  bg_reserved[3];
};

bg_block_bitmap 
    points to the blocks bitmap block for the group. 

bg_inode_bitmap 
    points to the inodes bitmap block for the group. 

bg_inode_table 
    points to the inodes table first block. 

bg_free_blocks_count 
    number of free blocks in the group. 

bg_free_inodes_count 
    number of free inodes in the group. 

bg_used_dirs_count 
    number of inodes allocated to directories in the group. 

bg_pad 
    padding. 

The information in a group descriptor pertains only to the group it is 
actually describing. 


4. Block and Inode Bitmaps

The ext2 file system uses bitmaps to keep track of allocated blocks and inodes.
The blocks bitmap of each group refers to blocks ranging from the 0th block
to the last block in the group. The inode bitmap of each group refer to inodes
ranging from the 0th inode (inumber couts from 1) to the last inode of the
group. A 0 bit means that block/inode is FREE, and a 1 bit means it has been
allocated.


5. Inodes

   An inode is a structure that uniquely describes a file. In the EXT2 file
system, every file and directory is described by one and only one inode. 
The EXT2 inodes for each Block Group are kept in the inode table together with
a bitmap that allows the system to keep track of allocated and unallocated 
inodes. It contains the following fields: 

mode 
    This holds two pieces of information; what does this inode describe and 
    the permissions that users have to it. For EXT2, an inode can describe one
    of file, directory, symbolic link, block device, character device or FIFO. 
Owner Information 
    The user and group identifiers of the owners of this file or directory. 
    This allows the file system to correctly allow the right sort of accesses, 
Size 
    The size of the file in bytes, 
Timestamps 
    The time that the inode was created and the last time that it was modified,


The detailed inode structure is as follows.

struct ext2_inode {
  unsigned short i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[EXT2_N_BLOCKS];
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsigned long  i_reserved2[2];
};

i_mode 
    type of file (character, block, link, etc.) and access rights on the file. 

i_uid 
    uid of the owner of the file. 

i_size 
    logical size in bytes. 

i_atime 
    last time the file was accessed. 

i_ctime 
    last time the inode information of the file was changed. 

i_mtime 
    last time the file content was modified. 

i_dtime 
    when this file was deleted. 

i_gid 
    gid of the file. 

i_links_count 
    number of links pointing to this file. 

i_blocks 
    number of blocks allocated to this file counted in 512 bytes units. 

i_flags 
    flags (see below). 

i_reserved1 
    reserved. 

i_block 
    pointers to blocks (see below). 

i_version 
    version of the file (used by NFS). 

i_file_acl 
    control access list of the file (not used yet). 

i_dir_acl 
    control access list of the directory (not used yet). 

i_faddr 
    block where the fragment of the file resides. 

i_frag 
    number of the fragment in the block. 

i_size 
    size of the fragment. 

i_pad1 
    padding. 

i_reserved2 
    reserved. 

As can be seen, an inode contains, EXT2_N_BLOCKS (15) pointers to block. 
Of theses pointers, the first EXT2_NDIR_BLOCKS (12) are direct pointers to 
data blocks. The following entry points to a block of pointers to data 
(indirect). The following entry points to a block of pointers to blocks of 
pointers to data (double indirection). The following entry points to a block 
of pointers to a block of pointers to a block of pointers to data
(triple indirection).

For SPECIAL files (I/O devices such as /dev/fd0, /dev/hda1, etc.) they
do not need data block pointers. Only iblock[0] contains the device's
(major, minor) ID numbers.


The inode flags may take one or more of the following or'ed values: 

EXT2_SECRM_FL 0x0001 
    secure deletion. This usually means that when this flag is set and we 
    delete the file, random data is written in  the blocks previously allocated
    to the file. 

EXT2_UNRM_FL 0x0002 
    undelete. When this flag is set and the file is being deleted, the file 
    system code must store enough information to ensure the undeletion of the 
    file (to a certain extent). 

EXT2_COMPR_FL 0x0004 
    compress file. The content of the file is compressed, the file system code
    must use compression/decompression algorithms when accessing the data of 
    this file. 

EXT2_SYNC_FL 0x0008 
    synchronous updates. The disk representation of this file must be kept in 
    sync with it's in core representation. Asynchronous I/O on this kind of 
    file is not possible. The synchronous updates only apply to
    the inode itself and to the indirect blocks. Data blocks are always written
    asynchronously on the disk. 

Some inodes have a special meaning: 

EXT2_BAD_INO 1 
    a file containing the list of bad blocks on the file system. 

EXT2_ROOT_INO 2 
    the root directory of the file system. 

EXT2_ACL_IDX_INO 3 
    ACL inode. 

EXT2_ACL_DATA_INO 4 
    ACL inode. 

EXT2_BOOT_LOADER_INO 5 
    the file containing the boot loader. (Not used yet it seems.) 

EXT2_UNDEL_DIR_INO 6 
    the undelete directory of the system. 

EXT2_FIRST_INO 11 
    this is the first inode that does not have a special meaning. 


6. Directories

A directory is a file containing a list of entries of the following format: 

struct ext2_dir_entry_2 {
        unsigned long  inode;                  /* Inode number */
        unsigned short rec_len;                /* Directory entry length */
        unsigned char  name_len;               /* Name length */
        unsigned char  file_type;            
        char    name[EXT2_NAME_LEN];           /* File name */
};


inode 
    points to the inode of the file. 

rec_len 
    length of the entry record. 

name_len 
    length of the file name. 

name 
    name of the file. This name may have a maximum length of EXT2_NAME_LEN 
    bytes (255 bytes as of version 0.5). 

As in all Unix file systems. the first two entries in a directory are "." and
".." which represent to the current directory and the parent directory.


Whenever possible, ext2 uses the following rules to allocate new inodes and 
data blocks: 

    the inode for a new file is allocated in the same group of the inode of 
    its parent directory. 

    inodes are allocated equally between groups. 

    a new block is allocated in the same group as its inode. 

    allocate consecutive sequences of blocks. 
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #6</H1>

<Pre>
                   CS360 NOTES on FILE OPERATIONS

1. File Operations in Unix consists of 5 levels, from LOW to HIGH:
   
1.1. Hardware Level:
     This is the lowest level of file operations. It prepares the hardware 
     device, e.g. disk drive, for file systems
     Examples: fdisk : divide a hard disk into partitions.
               mkfs  : create a file system on a disk, also known as format.
               fsck  : check and repair file systems.
     Many "comercial" file system tools, such as DiskManager, DiskDoctor, etc.
     belong to this catagory.

1.2. System Call Level:
     Every Operating System provides support for BASIC file operations. 
     Unix has the following file operation functions in its kernel:

          kmount(), kumount();            (for mount/umount file systems)

          Kmkdir(), Krmdir(), Kchdir(),   (obvious)
          klink(),  kunlink(),ksymlink(), (for link/remove files) 
          Kchmod(), Kchown(), ktouch()    (change file MODE, owner, time)  

          Kcreat(), Kopen(),              (create/open file for R,W,RW,..) 
          Kread(),  Kwrite(),             (read/write opened files) 
          Klseek();                       (change R/W byte position)
          Kclose()                        (close opened files)

          kopendir(), kreaddir(), kclosedir(), (READ directories)
          kreadlink();                    (READ symbolic link files)

          kstat(),  kfstat(), klstat(),   (get file status/information)

     The prefix K emphasizes that these are functions inside the Unix Kernel.

     
                        SYSTEM CALLS:

     Processes use System Calls (syscall for short) to access Kernel functions.
     More will be on this later.  For the time being, consider how to READ a 
     file.
     
     Assume myfile is an existing file. The following C program shows HOW TO
     READ the file (contents).

           #include    &lt;fcntl.h&gt;
           int fd, n;   char myBuffer[1024]; 
           main()
           {
              fd = open("myfile", flags, mode); where flag = O_RDONLY|O_WRONLY|O_RDWR|many others
                                                      mode = permission bits for new file

              if (fd < 0)                  fd is called a FileDescriptor.
                 exit(1);                  if fd < 0, open() call has failed.
                   
              n = read(fd, myBuffer, nbytes);  where nbytes = number of bytes you wish to read.
                                               data will be read into myBuffer[]. 
                                               n = ACTUAL # of bytes read.
              
             lseek(fd, (long)POSITION, 0);     This moves the read Pointer to POSITION bytes from 
                                               the file beginning. NOTE: It's a LONG.
 
             close(fd);                        This closes an opened file.

           }


Examples:  
          #define BLKSIZE 1024

          int fd; char buffer[BLKSIZE];

          fd = open("/dev/fd0", 0);       /* open floppy drive 0 for READ */
          lseek(fd, (long)BLKSIZE, 0);    /* skip 1024 bytes ==> to BLOCK#1 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          lseek(fd, (long)4*BLKSIZE, 0)   /* move to beginning of Block#4 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          .........................

     The functions open(), read(), write(), lseek(), close() in a User mode 
     program are Library functions.  Each such Library function will issue a
     syscall, causing the process to switch from User mode to Kernel mode.
     Once in K mode, the process will be directed to the corresponding Kenrel
     function, e.g. open() goes to Kopen(), read() goes to Kread(), etc.  
     When the process finishes executing the Kernel function, it exits Kernel 
     and returns to User mode.

     Every syscall causes the process to enter K mode and then back to U mode.
     Switching between Umode and Kmode takes a lot of actions (and time). Data
     transfer between Kmode and Umode is especially "expensive". Although it is
     permissible to issue
                         read(fd, buffer, 1);
     syscall to read just ONE byte, it is NOT wise to do so because that one 
     byte would come with a terrible price. Every time you have to cross the 
     boarder to enter the wonderful world of Kernel, do as much as you can 
     rather than in piece meal in order to make the journey worthwhile. In the
     case of READ/WRITE files, the best way is to match what the Kernel does. 
     The kernel reads/writes disks by BLOCK size, which ranges from 1KB to
     8KB. For instance, in Linux, the default BLOCK size is 4KB for hard disks
     and 1KB for floppy disks. 

1.3  Library I/O Functions:
    
     Syscalls allow us to read/write chunks of data, which are just a sequence
     of bytes. They do not know, nor care, about the meaning of the data. 
     However, a user (program) often needs to read/write individual chars or
     lines. If so, the user program would have to do these from/to a beffered 
     data area by itself. Most users would consider this "too much"!

     The C library provides a set of standard I/O functions for convenience, as
     well as for run-time efficiency. The library I/O functions include:

     FILE I/O      :  fopen(), fread(); fwrite(), fseek(), fclose();
                      fflush(), 
     char mode I/O :  getc(), putc(), getchar(), putchar(), ungetc()
     line mode I/O :  gets(), puts(), fgets(), fputs();

     formatted I/O :  scanf(), fscanf(), sscanf();
                      printf(), fprintf(), sprintf()

     With the exceptions of sscanf()/sprintf(), which read/write memroy 
     locations, all other library I/O functions are built on top of syscalls 
     in that they ultimately issue syscalls for "actual" data transfer through
     the Operating System Kernel.

1.4. User Commands Level:

     Instead of writing programs, users may use Unix commands to manipulate
     files. Examples of user commands are

            mkdir, rmdir, cd, pwd, ls;
            rm, cat, cp, mv, chmod, .....

     Each user command is in fact an executable program (except cd), which 
     typically calls library I/O functions, which in turn issue syscalls to 
     invoke the corresponding kernel functions. Thus, the processing sequence 
     is either
            Command ==> Library I/O function ==> Syscall ==> | Kernel Function
        or
            Command ===========================> Syscall ==> | Kernel Function

1.5. sh Script Files:

     Although much more convenient than syscalls, commands must be entered
     manually, which is often tedious and time-consuming.

     sh scripts are files written in the sh programming language. The sh 
     language includes all valid Unix commands. It also includes additional 
     statements (if, do, for, while, case, etc.) to control the executions.  
     In practice, sh scripts are used extensively in Unix system programming.
     In addition to sh, many other script languages, such as Perl, are also in
     wide use. sh programming will be covered later. 


<tITLE>CS460</TITLE>

<BODY bgcolor="#00CCCC" TEXT="#000000" LINK="#990000" VLINK="#0000FF" ALINK="#3300FF"> 

<H1>CS360 CLASS NOTES</H1>
<H2>
<P>
<img src="redball.gif" alt ="*">
<A HREF="planF08.html">Course Plan : Fall, 2008</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_final_signup.html">Final Demo Signup</a>

<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_460_ta.html">TA Information</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_grade.html">Lab Grades</a>
<P>
<img src="redball.gif" alt=*">
<A HREF="ta_files/cs360_grade_exam.html">Exam Grades</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes1.html">Notes #1: Introduction to Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="lab1.html">Lab Assignment #1</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes2.html">Notes #2 : Program Development</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes3.html">Notes #3 : Function Calls</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LAB2Pre.html">Lab#2 Pre-work</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="ass.html">Notes #4 : Assembly Programming</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LAB2.html">Lab Assignment #2</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="PROC.html">Notes #5 : Process Management in Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LABsh.html">Lab Assignment #3 : sh Simulator</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="fileops.html">Notes #6 : File Operations</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="syscall.html">Notes #7 : System Calls</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="libio.html">Notes #8 : Library I/O Functions</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="pre4.html">Lab #4 Pre-Work; DUE : in Lab, Sept. 24, 2008</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="IP.07.html">Notes #9 : Newtork Programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4.tcp.html">LAB #4 : File Operations across Networks</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="sh.html">Notes #10 : sh programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fs.html">Notes #11 : EXT2 File System Info</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fd.html">Notes #12 : EXT2 FS on Floppy Disk</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB5pre.html">LAB #5 Pre-work (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="lab508.html">LAB #5 show block (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="review.html">REVIEW FOR EXAM #1</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="proj08.html">Project Specification</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="project.help.html">Project Organization</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="diagram.html">Project Data Structures</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="util.html">Project HELP: Utility functions</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="mkdir_creat.html">Project HELP: HOW TO mkdir_creat</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="stat_ls_cd_pwd.html">Project HELP: HOW TO cd_stat_ls_pwd</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="rmdir_rm.html">Project HELP: HOW TO rmdir_rm</a>
<h2>Project Level-2 Help Files</h2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="open_close.html">Project HELP: HOW TO open_close files</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="read_ext2.html">Project HELP: HOW TO read</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="write_ext2.html">Project HELP: HOW TO write</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="cat_cp_mv.html">Project HELP: HOW TO cat_cp_mv</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="mount_umount.html">Project HELP: HOW TO mount_umount</a>




<TITLE>CS360 LAB ASSIGNMENT #1</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 LAB ASSIGNMENT #1</H1>
<Pre>
                     CS360 ASSIGNMENT #1
              DUE & DEOM: Week of Sept 1, 2008

1. OBJECTIVES
   Partition table, fdisk, structures in C, read/write special files

2 Partition Table:

A disk is usually divided into several partitions. The partitions are recorded
in a partition table in the very first sector of the disk, called the Master Boot 
Record (MBR). Each sector is 512 bytes long. Inside the MBR, the partition table 
begins at the offset 0x1BE. The Partitin Table contains 4 entries, each 16 bytes 
long as defined in the following C structure.

struct partition {
	unsigned char drive;            /* 0x80 - active */

	unsigned char head;             /* starting head */
	unsigned char sector;           /* starting sector */
	unsigned char cylinder;         /* starting cylinder */

	unsigned char sys_type;         /* partition type */

	unsigned char end_head;         /* end head */
	unsigned char end_sector;       /* end sector */
	unsigned char end_cylinder;     /* end cylinder */

	unsigned long start_sector;     /* starting sector counting from 0 */
	unsigned long nr_sectors;       /* nr of sectors in partition */
};

As can be seen, sector and cylinder are all unsiged chars (8 bits). However, the
cylinder value is actually 10 bits. The highest 2 bits of cylinder value are in  
the leftmost 2 bits of sector, which is only 6 bits.
 
Each partition has a type, which indicates the kind of file system of the 
partition. Consult Linux's fdisk to see the partition types.

If a partition is EXTEND type (type==5), the partition may be further divided 
into more partitions. The extended partitions forms a link-list as the 
following diagram shows. 

Assume P4 is EXT type:
P4's beginSector = MBR
                    P5's beginSector
                    P6's MBR's sector# = MBR
                         (r.e. to P4)     P6's begin sector#
                                          P7's MBR r.e. to P4 --> etc.

Since use fdisk on any hard disk is risky, we shall use a floppy disk for this
assignment. Download the file ~cs360/samples/LAB1/floppyImage.gz to Linux. 
Uncompress and dump it to flopy disk by
                gunzip floppyImage.gz           ( unzip to floppyImage ) 
                dd if=floppyImage  of=/dev/fd0  ( dump to a FD         )

Then, run       fdisk /dev/fd0  
                 'p' : to print the partition table
                 'q' : to quit fdisk
to see the partition table on the floppy disk. 


                      REQUIREMENTS

Write a C progrom to display the partition table of the FLOPPY disk in 
(1). RAW form, i.e. as per the partiton struct entries (%20), then 
(2). Linux fdisk 'p' output form (%40),
(3). including ALL the extend partitions (%40) <== YOU BETTER DO THIS !!!!.

Turn in a floppy disk containing your work. Also, sign up for demonstration
in SLOAN 327 on Wednesday.
==============================================================================

3. HELP INFO: UNIX System calls for reading/writing files
                   int fd = open("filename", mode);
                   lseek(fd, (long)position, 0); 
                   read(fd, buffer, nbytes);
                   write(fd, buffer, nbytes);
                   close(fd);

The following C program writes/reads floppy disk sectors

#include &ltfcntl.h&gt
char buf[512];
int sector;

main()
{
   int fd, r;
   sector = 10;                           // sector # 10 (count from 0)  

   fd = open("/dev/fd0", O_WRONLY);       // open /dev/fd0 for WRITE
   strcpy(buf, "cs360 is fun");           // create a string in buf[]
   lseek(fd, (long)sector*512, 0);        // seek to the sector 10
   r = write(fd, buf, 512);               // write 512 bytes to fd
   printf("r=%d bytes written\n", r);     // show number of bytes written
   close(fd);                             // close the file descriptor fd

   fd = open("/dev/fd0", O_RDONLY);       // open /dev/fd0 for READ
   lseek(fd, (long)sector*512, 0);        // seek to sector 10           
   r = read(fd, buf, 512);                // read 512 bytes into buf
   printf("r=%d read  buf=%s\n", r, buf); // show result
   close(fd);                             // close opened file
}

4. Sample Solution:
   ~cs360/samples/LAB1/lab1.bin






<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Oct. 15, 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can easily determine whether it's a DIR.
   
   (READ how to use S_ISDIR(), S_ISREG() macros by  man stat)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       -------------------------------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB5:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Week of Oct. 13 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can easily determine whether it's a DIR.
   
   (Remember S_ISDIR(), S_ISREG() ?)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       -------------------------------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB6:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #8</H1>

<Pre>
           CS 360 NOTES #8  Library I/O Functions

1. WHY Library I/O functions?

   Although system calls are the basis for read/write files, they are often
   inconvenient to use. For examples, users may wish to read/write files in 
   logical units most suited to the application, e.g. as lines, chars, etc. 

   Library I/O functions are provided for this purpose. Although not 
   absolutely essential, they provide added convenience and overall 
   efficiency.

2. What are Library I/O functions?

   Almost every OS that supports C also provides Library functions for
   file I/O.  In Unix, Library I/O functions are built on top of the 
   syscall functions. In order to illustrate their intimate relationship, 
   we first list a few of them:
      
    Syscall Functions:  open(),  read(),  write(), lseek(),  close();
    Library Functions; fopen(), fread(), fwrite(), fseek(), fclose();

   From their strong similrities, you can almost guess that every library 
   I/O function has its root in a corresponding syscall function. This is
   indeed the case as fopen() relies on open(), fread() makes use of read(),
   etc. The following C programs illutrate their usage.
       
        System Calls                      Library I/O Functions 
  -----------------------------------|----------------------------------------
   #include &lt;fcntl.h&gt;                |     #include &lt;stdio.h&gt;
                                     | 
   int fd, gd;                       |     FILE *fp, *gp;
   char buf[BLKSIZE];                |     char buf[BLKSIZE];
                                     |
   main()                            |     main()  
   {                                 |     {
     int n, total=0;                 |        int n, total=0;
     fd = open("file1", O_RDONLY);   |        fp = fopen("file1", "r");
     if (fd < 0) exit(1);            |        if (fp == NULL) exit(1); 
     gd = open("file2", O_WRONLY);   |        gp = fopen("file2", "w");
     if (gd < 0) exit(2);            |        if (gp == NULL) exit(2);
     while (n=read(fd, buf, BLKSIZE))|        while (n=fread(buf,1,BLKSIZE,fp))
     {                               |        {
        write(gd, buf, n);           |             fwrite(buf, 1, n, gp);
        total += n;                  |             total += n;
     }                               |        }
     printf("total=%d\n:,total);     |        printf("total = %d\n", total);
                                     |
     close(fd); close(gd);           |        fclose(fp); fclose(gd);
   }                                 |    }  
   ----------------------------------------------------------------------------

    Both programs copy file1 to file2. Since you already know how syscalls
    work, we shall only discuss the program that uses Library I/O functions.

    (1). fopen() uses a string for Mode, where "r" stands for READ, "w" for 
         WRITE. It returns a pointer to a FILE structure. The FILE structure 
         contains a buffer, whose size usually matches that of BLKSIZE. In 
         addition, it also has pointers, counters and status variables for 
         manipulating the buffer.

         fopen() first allocates and initialize a FILE structure in (heap area
         of) the UserImage. It then issues an open() syscall for the file. If 
         the open() syscall succeeds, it records the returned fd in the FILE 
         structure, and returns a pointer to the FILE structure. Otherwise, it
         frees the FILE structure and returns a NULL pointer.

         It is important to note that the FILE structure, which is allocated/
         freed dynamically, is in the process' UserImage. This means that calls
         to Library I/O functions are ordinary function calls, not syscalls.  
         
    (2). The programs terminates if any of the fopen() calls has failed. As 
         mentioned above, fopen() returns a NULL pointer on failure.

    (3). Then it uses a while loop to copy the file.  Each iteration of the
         while loop tries to read BLKSIZE bytes from the source file, and 
         write n bytes to the target file, where n is the returned value from 
         fread().

         The general forms of fread() and fwrite() are

                 n = fread(buffer, size, nitems, FILEptr);
                 n = fwrite(buffer,size, nitems, FILEptr);
         
         where size is the data object size in bytes,  nitems is the number of 
         data objects to be READ or WRITTEN, and n is the actual number of 
         objects read or written. These functions are intended for R/W 
         structured data objects. For example, suppose that the buffer area 
         contains data objects of the type
                     struct OBJECT{.....}
         We may use 
                 n = fwrite(buffer, sizeof(struct OBJEC), M, FILEptr);
         to wirte M objects to a file.  Similarly,
                 n = fread(buffer, sizeof(struct OBJECT), N, FILEptr);
         reads N such objects from a file.

         The above program tries to read/write BLKSIZE bytes at a time. So, it
         has size = 1 and nitems = BLKSIZE. As a matter of fact, any comination
         of size and nitems such that size*nitems = BLKSIZE would also works. 
         However, using a size > 1 may cause problem on the last fread() 
         because the file may have fewer than size bytes left. In that case, 
         the returned n is zero but there are still bytes remaining. To deal 
         with the "tail" part of the surce file, we may add the following 
         lines of code after the while loop:
                 
                 fseek(fp, (long)total, 0);
                 n = fread(buf, 1, size, fp);
                     fwrite(buf,1, n, gp);
                 total += n;
         
         fseek() works in exactly the same way as lseek(). It positions the 
         file's R/W pointer to the byte location total. From there, we read 
         the file as 1-byte objects. This will read all the remaining bytes 
         and write them to the target file.

    (4). After the copying is done, both files are closed by calling fclose().


3. Algorithms of fread(), fwrite() and fclose()

3-1. The algorithm of fread() is as follows:

     (1). On the first call to fread(), the FILE structure's buffer is empty.
          fread() uses the saved file descriptor fd to issue a
                  n = read(fd, fbuffer, BLKSIZE);
          syscall to fill the local fbuffer. Then, it initializes fbuffer's 
          pointers, counters and status variables to indicate that there is a 
          block full of data in the local buffer.
          It then tries to satisfy the fread() call from the local buffer by 
          copying data to the program's buffer area. If the local buffer does 
          not have enough data, it issues additional read() syscalls to fill 
          the local buffer, until the needed number of bytes is satisfied (or 
          end of file is reached). After copying data to the program's buffer 
          area, it updates the local buffer's pointers, counters, etc. getting
          ready for next fread() request.  It then returns the acutal number of
          objects read to the calling place.

     (2). On each subsequent call to fread(), it tries to satisfy the call from
          the FILE structure's local buffer. It issues a read() syscall to 
          refill the local buffer whenever the buffer becomes empty.

          Thus, fopen() accepts calls from user program on one side and issues
          read() syscalls to the Kenrel on the other. Except for the read() 
          syscalls, all processing of fread() are performed in the User Mode. 
          It enters the Kernel mode only when needed and it does so in a way 
          that matches the Kernel's behavior for best efficiency. It provides 
          automatic buffering mechanism so that user programs do not have to 
          worry about such detailed operations.

3-2 fwrite():
 
     The algorithm of fwrite() is similar to that of fread() except for the 
     data movement direction.  Initially the FILE structure's local buffer is 
     empty. On each call to fwrite(), it writes data to the local buffer, and 
     adjust the buffer's pointers, counters and status variable to keep track 
     of the number of bytes in the buffer. If the buffer becomes full, it 
     issues a write() syscall to write the entire buffer to Kernel. 
     
3-3. USE syscalls OR Library Functions?
          
     Based on the above discussion, we can now answer the question of whether 
     to use syscalls or Libray functions to do file I/O?

     fread() relies on read() to copy data from Kernel to the local buffer,
     from which it copies data to the program's buf area. In contrast, read() 
     copies data from Kernel directly to the program's buf area.  Thus, for 
     read/write data in units of BLKSIZEs, read() is inherently more efficient
     than fread() because it only needs one copying operation instead of two. 
     Therefore, in the above C programs, the one that uses syscalls is actually
     more efficient than the other that uses Library I/O functions.  However, 
     if the read/write is not in units of BLKSIZE, fread() and fwrite() may be
     far more efficient. For example, if we insists on R/W one byte at a time,
     fread() and fwrite() would be far better because they enter Kernel Mode 
     only to fill or flush the local buffer, not on every byte. Here, we have 
     implicitly assumed that entering Kernel mode is more expensive than 
     staying in User mode. This is indeed true. 

3-4. Algorithm of fclose():

     fclose() first flushes the local buffer if the file was opened for WRITE.
     Then it issues a close() syscall to close the file descriptor.  Finally 
     it frees the FILE structure and resets the FILE pointer to NULL.

3-5. Other Modes for fopen():

     The Mode parameter in fopen() may be specified as

       "r", "w", "a" : for READ, WRITE, APPEND, or with a +, which means to 
                       create the file if it does not exist.
       "r+" : for R/W, without truncating the file.
       "w+" : for R/W, but truncate the file first.
       "a+" : for R/W by appending.

     However, when a file is fopened for both R/W, there may be restrictions on
     the use of mixed fread() and fwrite() calls. The specification requires 
     that at least one fseek() or ftell() be used between every pair of fread()
     and fwrite(). 

     Example: This program yields different results when run under HP Unix and 
              Linux.

              #include &lt;stdio.h&gt;
              FILE fp; char buf[1024]; 
              main()
              { 
                  fp = fopen("t.c", "r+");   /* for both R/W */
                  fread(buf, 1, 20, fp);     /* read 20 bytes */ 
                  fwrite(buf,1, 20, fp);     /* write to the same file */
              }


     Linux gives the right result, which modifies the bytes from 20 to 39. But
     HP Unix appends 40 bytes to the end of the original file.

     The difference stems from the non-uniform treatment of R/W pointers in the
     two systems.  Recall that fread()/fwrite() issue read()/write() syscalls
     to fill/flush the local buffer.  While read()/write() use the R/W pointer 
     in the file's OFTE, fread()/fwrite() use the local buffer's R/W pointer in
     the FILE structure.  Without a fseek() to synchronize these two pointers,
     the results depend on how are they used in the implementations. In order 
     avoid any inconsistencies, follow the man pages. For the example program, 
     the results become idnetical (and correct) if you insert a line

                  fseek(fp, (long)20, 0);

     between the fread() and fwrite().

4. Additional Library I/O functions:

4-1. Line mode I/O:
          retString = fgets(buf,nchars,fp); 
          retString = fputs(string,fp);
     Examples:
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          char buf[256]; char *s="this is a string";
          main()
          {
             fp = fopen("source", "r");
             gp = fopen("target", "w");
             fgets(buf, 256, fp);    /* read a line of upto 255 chars to buf */
             fputs(buf, 256, gp);    /* write string to target file */

          }
    
     When fp is stdin or stdout, fgets() and fputs() are shortened to
             gets(buf);     /* assume char buf[] is big enough */
             puts(string);  /* print string to stdout */

4-2. Char Mode I/O:
          int c;         /* NOTE the int type */       
          c = getc(fp);  /* get a char from fp, return EOF on end of file */
              ungetc(c, fp); /* push c back to stream */

          putc(c, fp);   /* put a char to fp */
     
     The reason for the int type of c is that the EOF symbol is usually an int
     value. 

   For fp = stdin or stdout,  c = getchar();  putchar(c); may be used instead.
   For run time efficiency, getchar() and putchar() are often NOT the shortened
   versions of getc() and putc(). Instead, they may be implemented as Macros
   in order to avoid an extra function call.
   Examples:

     (1). /* file copy using getc(), putc() */
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          main()
          {
            int c;  /* for testing EOF */
            fp=fopen("source", "r");
            gp=fopen("target", "w");
            while ( (c=getc(fp)) != EOF )
               putc(c,gp);
            fclose(fp); fclose(gp);
          }

    (2). /* Linux's man pages contain lots of 0x08 code. It is used as follows:
             0x08TT0x08HH0x08II0x08SS  high light the word THIS.
             t_0x08h_0x08a_0x08t_0x08  display the _ under that.
             However, a _ not immediately followed by 0x08 is part of the text.

             The following program eliminates the 0x08 code from the outputs 
             of man. EXPLAIN HOW DOES IT WORK ? */

             #include &lt;stdio.h&gt;
             main()
             {  int c, nextc;
                while ( (c=getchar()) != EOF ){
                   if (c == 0x08){
                       c = getchar();
                       continue;
                   }
                   if (c == '_'){
                       nextc=getchar();
                       if (nextc == 0x08)
                       continue;
                       ungetc(nextc,stdin);
                   }
                   putchar(c); 
                }
             }


4-3. FORMATTED I/O:
     These are perhaps the most commonly used I/O functions.
     Foratted Inputs: ( FMT=format string )
                      scanf(FMT, &items);    /* from stdin */     
                     fscanf(fp, FMT, &items);
                     sscanf(buf,FMT, &items);  
     Formatted Outputs:     
                      printf(FMT, items);   /* to stdouot */
                     fprintf(fp, FMT, items);
                     sprintf(buf,FMT, items);
     
     Note that sscanf() and sprintf() are not really I/O functions but
     string assemble/extraction funcions.
      

4-4. Other Functions:

     fseek(), ftell(), rewind()
     feof(), ferr(), fileno()

     freopen(), fdopen()
     setbuf(), setvbuf()
     popen()
   





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 HELP #5</H1>

<Pre>
   
            360 PROJECT HELP :  HOWTO_MKDIR_CREATE

make_dir()
{
1. Ask for a pahtname, e.g. /a/b/c  or a/b/c, etc.

2.  if (pathname[0] == '/') 
        dev = root->dev;
     else
        dev = cwd->dev;
3. Let  
     parent = dirname(pathname);   parent= "/a/b"
     child  = basename(pathname);  child = "c"

4. Get the In_MEMORY minode of parent:

         ino  = getino(&dev, parent);
         pip  = iget(dev, ino); 

   Then, verify :
         parent INODE is a DIR AND
         child des NOT exists in the parent directory;
               
5. Call 
          r = mymkdir(pip, child);
 
6.  return(r);

} 


int mymkdir(MINODE *pip, char *name)
{
1. pip points at the parent minode[] of "/a/b", name is a string "c") 

2. allocate an inode and a disk block for the new directory;
       call   inumber=ialloc(dev),      bnumber=balloc(dev)
   where dev=pip->dev, i.e. SAME dev as the parent directory.

3. call mip = iget(dev,inumber) to load the inode into a minode[] (in order to
   wirte contents into the intended INODE in memory).

4. Write contents into mip->INODE, including:
        (same as the root directory in mkfs)
        INOODE.i_block[0] = bnumber; 
        all other INODE.i_block[] = 0;
        mip->dirty = 1;  /* mark dirty */

5. call  iput(mip);  
   which should write the new INODE out to disk.

  // C CODE:
  //**********************************************************************
  mip = iget(dev,inumber);

  mip->INODE.i_mode = 0x41ED;		/* DIR and permissions */
  mip->INODE.i_uid  = running->uid;	/* Owner Uid */
  mip->INODE.i_gid =  running->gid;	/* Group Id */
  mip->INODE.i_size = 1024 ;		/* Size in bytes */

  mip->INODE.i_links_count = 2;	/* Links count */

  mip->INODE.i_atime=mip->INODE.i_ctime=mip->INODE.i_mtime = time(0L); 

  mip->INODE.i_blocks = 2;     	/* Blocks count in 512-byte blocks */
  mip->dirty = 1;               /* mark dirty */

  for (i=0; i<15; i++)
    mip->INODE.i_block[i] = 0;
  mip->INODE.i_block[0] = znumber; 

  iput(mip);
  //**********************************************************************


6. Write the . and .. entries into a buf[ ] of BLOCK_SIZE; 
   write buf[] to the disk block allocated to this directory;

// C CODE:
//****************************************************************  
  dp = (DIR *)buf;

  dp->inode = inumber;		/* Inode number */
  strncpy(dp->name, ".", 1);    /* File name */
  dp->name_len = 1;		/* Name length */
  dp->rec_len = 12;		/* Directory entry length */

  cp = buf; 
  cp += dp->rec_len;            /* advance by rec_len */
  dp = (DIR *)cp;

  dp->inode = parent->ino;      /* Inode number of parent DIR */
  dp->name_len = 2;		/* Name length */
  strncpy(dp->name, "..", 2);   /* File name */
  dp->rec_len = BLOCK_SIZE - 12;/* last DIR entry length to end of block */

  put_block(dev, bnumber, buf);


7. Finally, enter name into parent's directory 
   Read parent's data block into buf[];

     !!! LISTEN TO LECTURE CAREFULLY ON HOW TO DO THESE !!!:

// EXT2 DIR entries: Each DIR entry has rec_len and name_len.
// (1). rec_len = name_len+8 raised to the next multiple of 4 bytes.
//      So,       ideal_len = [(name_len + 8 + 3)/4] * 4
// (2). When deleting an entry, first zero out its inode number, then absorb
        its rec_len to the previous entry's rec_len ==> which effectively
        "hides" the deleted entry.

        If the deleted entry is the first in a data block, then there is no
        previous entry to absorb its rec_len. However, the entry is "deleted"
        since its inode number is zero. The idel_len of such entries is 0.

// (3). (2) ==> when entering a name into DIR, should look for an entry whose
//      rec_len - ideal_len >= new entry's ideal_len. Then, reduce this entry's
//      rec_len to its ideal_len and enter the new entry in the remaining space

//      The new entry's rec_len = remain = this entry's (rec_len - ideal_len).
// (4). When scaning a DIR block, must check for block ending; allocate new
//      data block if needed.


(As said before, you may assume directories only have direct data blocks.)
        
8. Write parent's data block back to disk;

9. inc parent inodes's link count by 1; touch its atime and mark it DIRTY

10. iput(pip);

}  

creat_file()
{
  This is similar to mkdir() except : its inode's mode field is set to
  a REGULAR file, permission bits to (default) rw-r--r--, and no data 
  block is allocated for it.
} 


int mycreat(parent,name) MINODE *parent; char *name;
{
    Same as my_mkdir() except NO data block and do NOT inc parent's link count.
}  




<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 HELP INFO</H1>
<Pre>
   
                 HOWTO_MOUNT_UMOUNT

// ASSUME: newfs  is a file containing an EXT2 filesys image.

mount()    /*  Usage: mount filesys mount_point OR mount */
{

1. Ask for filesys (a pathname) and mount_point (a pathname also).
   If mount with no parameters: display current mounted filesystems.

2. Check whether filesys is already mounted: 
   (you may store the name of mounted filesys in the MOUNT table entry). 
   If already mounted, reject;
   else: allocate a free MOUNT table entry (whose dev == 0 means FREE).

3. open filesys for RW; use its fd number as the NEW dev;
   Check whether it's an EXT2 filesys: if not, reject.

4. find the ino, and then the minode of mount_point:
    call  ino  = get_ino(&dev, pathname);  to get ino:
    call  mip  = iget(dev, ino);           to load its inode into memory;    

5. Check mount_point is a DIR.  
   Check mount_point is NOT busy (e.g. can't be someone's CWD)

6. Record NEW dev in the MOUNT table entry;

   (For convenience, store the filsys name in the Mount table, and also
                     store its ninodes, nblocks)

7. Mark mount_point's minode as being mounted on and let it point at the
   MOUNT table entry, which points back to the mount_point minode.

8. return 0;

}
  

umount(filesys) char *filesys;
{

1. Search the MOUNT table to check filesys is indeed mounted.

2. Check whether any file is still active in the mounted filesys;
      e.g. someone's CWD or opened files are still there,
   if so, the mounted filesys is BUSY ==> cannot be umounted yet.
   HOW to check?      ANS: by checking all minode[].dev

3. Find the mount_point's inode (which should be in memory while it's mounted 
   on).  Reset it to "not mounted"; then 
         iput()   the minode.  (because it was iget()ed during mounting)

4. return(0);

}  
  

                  IMPLICATIONS of mount:

With mounting, you must modify the
 
               ino = get_ino(&dev, pathname)

function to support "cross mounting point" operations.

Assume :    mount newfs /a/b/c   ==> newfs has been mounted on /a/b/c.
 
Case 1: When traversing the pathname /a/b/c/x/y, once you reach /a/b/c,
        you should see that /a/b/c has been MOUNTed on (because its mounted
        flag = 1). You should

        Use the minode's mountTable pointer to locate the MOUNT table entry.
        From newfs's  dev number, you can get its / inode into memory.
        THEN, continue to look for x/y under this / inode.

Case 2: Assume that you are at the directory
               /a/b/c/x/
        and you are trversing upward. e.g.
               cd  ../../
        which will cross mount point at /a/b/c.
        THINK ABOUT HOW TO HANDLE THIS CASE. LISTEN TO LECTURE.

<TITLE>CS360 NOTES#2</Title>
<Body bgcolor="#00CCCC" text="#000000">

<H1>CS360 NOTES #1 : Introduction to Unix</H1>

<Pre>

1. The Unix File System Tree:
   The Unix file system is organized as a tree, as shown below.


            |--> bin 

            |--> dev

            |--> etc

     / ---> |--> lib

            |--> sbin
                           |--> bin
            |--> tmp       |--> include --> .h files 
                           |--> lib
            |--> usr ----->|--> local
                           |--> man
            |--> user      |--> X11 ------>
       
            |--> vmunix 


   Each NODE of the tree is a FILE. Unix files have the following types:

2. Unix File Types:

   (1). Directory files : 
        These are directories. A directory may contain other directories 
        and (non-directory) files.

   (2). Non-directory files : 
        Non-directory files are either REGULAR or SPECIAL files (SEE BELOW).
        Note that Non-directory files can only appear as leaf-nodes in the 
        tree.

        (2).1  REGULAR files : 
               Regular files are also called ORDINARY files. They contain 
               either ordinary text or executable binary codes.

        (2).2  SPECIAL files : 
               Special files are entries in the /dev directory. They represent
               I/O devices, and are further classified as . 

               CHAR  special files, e.g. /dev/tty0, /dev/modem.
               BLOCK special files, e.g. /dev/fd0,  /dev/hda.
               Other types such as Network special files.

   (3). Soft LINK files:
        These are Regular files whose contents are pathnames of other 
        files. As such they are used to reference other files.
        Example: the Unix command
                 ln   -s   aVeryLongFileName   myLink
        sets up  myLink  as a soft-link to  aVeryLongFileName.  Access to 
        myLink will be re-directed to the actual file aVeryLongFileName.

3. Pathname:

   The ROOT node of a Unix file system tree, symbolized by /, is called the 
   "root directory".

   Each node of the tree is represented by a PATHNAME of the form

             /a/b/c/d    OR    a/b/c/d

   So, each Unix file is specified by a pathname.

*   A pathname is ABSOLUTE if it begins with a /.  
*   A pathname is RELATIVE if it does not begin with a /. 
 
    A relative pathname starts from the Current Working Directory (CWD).
    When a user login to Unix, the CWD is usually set to his/hers HOME 
    directory.  The CWD can be changed by using the cd  command.  
    The pwd command prints the absolute pathname of the CWD.
            
4. Contents of Directories Under / :  

   /bin : commonly used system commands, e.g ls, date,...
   /dev : Special files.
   /etc : Unix system maintenance files.
   /lib : Unix system libraries.
   /sbin: Unix system administration commands.
   /tmp : temporary files.
   /usr : /usr/bin:      more executable files such as  cc,  gzip.
          /usr/include : .h files
          /usr/lib:      specific library files.
          /usr/man     : on-line manual directory.
          /usr/X11     : X-Window system.

   /user: user home directories.
   /vmunix : bootable Unix system image file.


5. Login Process:

(1). User Account:
     Each user is assigned an account by the system administrator. In a stand-
     alone Unix system, user accounts are maintained in a file named     
                        /etc/passwd.
     In a network system composed of many Unix machines, such information is 
     usually maintained on a Server machine, which provides other Unix machines
     with a single copy of the user account information. 
 
     A user account typically contains the following fields, separated by :

     root:aXuoPkB4hz:0:0:root:/root:/bin/bash
     kwang:Pir2NYB4Bqi9I:501:100:k.c.wang,cs faculty:/home/kwang:/bin/bash
     ----- ----------------- --- ------------------- ----------- --------------
  username: password :gid:uid:    full name      : HOME dir  : programToExecute

(2). Login Process:
     
     A PROCESS is a sequence of executions regarded as a single entiry by the 
     system. In Unix, every activity is carried out by a process.  
     When Unix starts, it generates a special process, P1, which executes the 
     file   /etc/init.  For this reason, P1 is also called the INIT process. 
     It is the parent of all user processes in the following manner:

     P1 reads some system configuration files to find out the terminals 
     supported by the system.  For each terminal, it generates a child process 
     on that terminal. Then, it waits for any of the terminal process to 
     terminate.  When a terminal process terminates (by user logout), P1 
     regenerates another child process on that terminal. 

     Each child process opens 3 (stream) FILEs on its own terminal. These FILEs
     are known as 

          stdin : the terminal's Keyboard, for inputs;
          stdout: the terminal's Display, for outputs;
          stderr: also the Display, for error outputs;

     Then the child process executes /etc/getty, which displays the message  
          login:  
     on its stdout, awaiting a user to login.  
     At this moment, the login process is not yet associated with any user.

     When a user tries to login, the login process validates his/her username 
     and password in /etc/passwd. If the user has a valid account, the login 
     process takes on the user's uid and gid, thereby becoming the user's 
     process.  It then sets the CWD to the user's HOME directory and executes 
     the program specified in the user's account. That program is usually a 
     version of the Unix shell, e.g. bash, csh, etc.
    
     The Unix shell is a command interpreter.  It displays a prompt
         %     (OR some other symbol, which can be set by the usr)
     and waits for the user to input commands.

     A command is simply an executable program. When the user enters a command,
     the sh process (i.e. the user process that's executing the sh) will

       (1). generate a child process to perform the command;
       (2). wait for the child process to terminate;
       (3). prompt the user for commands again;  
            The sh process terminates when it sees logout or END_OF_FILE.
   
     NOTE that the command is NOT executed by sh itself but by a child process.

     Using this feature of sh, a user can start many processes, each performing
     a different task.  For example, the command (line)

            %   ls & date & a.out  &
                --   ----   ----- ----- 
                C1    C2     C3   NoWait

     will start 3 children processes, C1, C2, C3, which execute ls, date, a.out
     respectively, and cause the sh to prompt again without waiting for any of
     the child processes to terminate.  This is called MULTI-TASKING.

     In this example, all 4 processes will run CONCURRENTLY (which means IN 
     PARALLEL in a logical sense). Among them, the sh runs in the FOREGROUND 
     while others run in the BACKGROUND.  Only the foreground process can 
     receive inputs from stdin.
     The  fg  command can be used to raise a background process to foreground.
     The  ps  command displays all the ProcessId (PID) of a user.


6. REVIEW QUESTIONS:

(1). The   ls -l   command lists the contents of a directory:

drwxr-xr-x   root   bin     2048  Dec 23 09:22 bin/
lrwxrwxrwx   root   root      23  Dec 20 20:15 kwang -> /home/kwang/public_html
-rw-r--r--   root   root  433387  Dec  8 21:52 vmlinuz
-rwxr-xr-x   kwang  kwang  21400  Jan 10 07{30 a.out

EXPLAIN THE MEANING OF EACH field?

(2). What are the permission bits of a file, and what do they do?
     
(3). Each user has a UserId (uid) and a GroupId (gid).  
     How does a user get hid/her uid and gid?
     What are the uid and gid used for? 

(4). The owner of a file can use the Unix command
         chmod  0766  fileName  
     to change the mode of fileName. What are the resulting permissions?

(5). What does the x bits of a directory mean?

(6). Unix has a special user, called the SuperUser or the Root, who can access
     any file. What's the reason for having such a Super user?

(7). How does a user acquire a Unix process?

(8). How many processes will be executing with the sh command?
         %  a & b & c & d &
     Which one is the foreground process?

(9). The Unix command    ls | more
     sets up 2 processes, one executes ls and the other executes more, in such 
     a way that the outputs of the first process ls are PIPEd to the second 
     process more. 
     How many processes will be executing with the sh command?
         %  a | b | c | d 
 








<TITLE>CS360 NOTES#3</Title>
<Body bgcolor="#00FFCC" text="#000000">

<H1>360 NOTES #2 : PROGRAM DEVELOPMENT</H1>

<Pre>

1. OBJECTIVES
   To understand the steps involved in program development.

2. THE STEPS:

(1). Source file : A text editor, such as vi or emacs, may be used to create
     one or more source program files in some language(s). Typical languages
     are C and Assembly.

(2). Consider C programs first. Let the source of a C program be written as
     two files, t1.c and t2.c,  as shown below:

/********  t1.c file *************************************************/
     extern int g;                      /*  IMPORT g    */
     int      sum;                      /* global variable */
     main(int argc, char *argv[ ])      /* main function */
     {
       int a,b;                         /* local variables */
       a = 1;
       b = 2;
       g = 100;                         /* reference extern variable */
       sum = mysum(a,b);                /* call mysum(), passing a,b */
       printf("sum=%d g=%d\n",sum, g);  /* call printf() */
     }
/**********************************************************************/

/*******  t2.c file **************************************************/
     int g;                             /* global variable  */
     int mysum(int x, int y)            /* function heading */
     {
        return x+y+g;                   
     }              
/*********************************************************************/

(3). To convert these source files into an executable, we typically use the 
     cc command (In Linux, cc is linked to gcc, so they are the same).

        cc  t1.c t2.c       =====> this generates an executable file  a.out

(4). WHAT'S cc or gcc?
     cc is a program, which consists of 3 major steps:
     
     1. Convert C source files to Assembly code files:
        The first step of cc is to invoke the C COMPILER, which translates
        the .c files into .s files containing ASSEMBLY code for the 
        target machine.  

     2. Convert ASSEMBLY Code to OBJECT code:
        Every machine has its own set of machine instructions. Users may 
        write programs in an ASSEMBLY language for a specific machine.

        An ASSEMBLER is a program, which translates assembly code into 
        machine code in binary form. The resulting .o files are called 
        OBJECT code. 

        The second step of cc is to invoke the ASSEMBLER to translate the
        .s files into .o files.

        Each .o file consists of 3 parts:
         
              a CODE section consisting of machine instructions;
              a DATA section consisting of all GLOBAL and static variables; 
              a SymbolTable  containing all variable and function names
                             and their attributes.

     3. LINKING: 
        A program may be composed of several pieces of .o files, which are 
        usually dependent on one another.  In addition, the .o files may call
        C library functions (e.g. printf), which are NOT present.

        The last step of cc is to invoke the LINKER, which puts all the .o 
        files and the needed library functions together into a single 
        executable binary file, a.out. More specifically, the LINKER does the 
        following:

        .Combine all the code sections of the individual .o files into a
         single CODE section,

        .Combine all the data sections into a single DATA section,

        .Use the SymbolTables to resolve the cross references among the
         inidvidual .o files. 

         For instance, when the compiler sees sum = mysum(a,b), it does NOT 
         know where mysum is. So it leaves a blank in the .o file for the
         entry address of mysum. When the linker puts t1.o t2.o together, it 
         knows where mysum is since mysum is recorded in the SymbolTable
         of t2.o. So the linker can replace the blank in t1.o with the address
         of mysum. Similarly for other symbols that are cross referenced.

        If everything goes well, the linker will write the resulting combined 
        file as a.out, which is the executable binary.
 
3. STATIC Vs. DYNAMIC Linking:
   There are two ways to create a.out, known as static and dynamic linking.
   In static linking, the linker includes every needed library function in 
   a.out. This makes a.out self-sufficient but usually very large.
     
   In dynamic linking, the library functions are not included in a.out but 
   calls to such functions are recorded in a.out as a directives to the LOADER.
   When a.out is to be executed, the system LOADER will load both a.out and 
   its needed libaray files into memory. 

   The main advantages of dynamic linking are:
       .The size of every a.out is reduced.
       .Once loaded into memory, the library functions can be SHARED.
      . Modifying library functions does not have to re-linking any a.out file.
 
   This kind of libraries are known as Dynamic Linking Libraries (DLLs).

4. WHAT's in a.out?
   a.out is the executable binary file, which usually has the format:
   ---------------------------------------------------------------------------
     header      : The header of a.out contains its sizes in bytes: 
                       tsize = size of Code section;
                       dsize = size of Data section;
                       bss_size=size of bss section;
                       Needed library functions (if dynamic linked).

     Code Section: this is the combined code area of a.out; it always begins
                   with the standard C startup file crt0.o, which calls main. 

     Data Section: The Data section contains INITIALIZED global and static data
                   objects. Examples of static data are static variables and 
                   format strings in printf(fmt, .....).

     bss (Block Started by Symbol) Section: un-initialized statics and globals
   ---------------------------------------------------------------------------
   NOTE that the bss section is NOT included in a.out. However, its size
   is recorded in the header of a.out as bss_size.

5. Execution of a.out
   The sh command
       %  a.out ONE TWO THREE 
   executes a.out with the strings ONE TWO THREE as command-line parameters.
   As explained before, sh will create a child process to execute a.out.
   
   After creation, The child process does the following

   (1). It reads the header of a.out to determine the Total memroy size needed:
             TotalSize = tsize + dsize + bss_size + stackSize
        where the stackSize is usually a default value of say, 4K bytes.

   (2). It then allocates a memory area of TotalSize bytes. Conceptually, we
        may assume that the allocated memory area is a single piece of
        contiguous memory. It then loads a.out (without the header) into this 
        memroy area, with the Code section at the Low address end. The High
        address end will be the stack area. Thus, the stack grows downward.

   (3). The main() function of  a.out  may be written as 
              main(int argc, char *argv[ ], char *env[ ])
        As will be shown later, parameters are passed through the stack. 

   (4). It then starts to execute crt0.o, whcih calls main().
  
   (5). The execution image of a process is shown by the figure:

            LowAddress                                 HighAddress 
                      |  CODE  |  DATA | HEAP | STACK |

        where the HEAP is for dynamic memory allocations (by malloc() in C or
        new() in C++) and STACK is the run-time stack.
        Subject to a certain maximum size limit, both HEAP and STACK may be 
        expanded automatically by the Unix operating system.

   (6). Termination:
        The process that executes a.out may terminate in ONE of 4 ways:

        1. The process calls exit(bye_value), which does some clean-up work 
           (such as flush stdout, close I/O stream FILEs) and then issues an 
           _exit(value) system call, which causes the process to enter the Unix
           Kernel to die. For instance, when the process return from main() to
           crt0.o, it calls exit(0). Alternatively, the process may call
           exit(byte_value) anywhere in a.out to terminate (without going back
           to crt0.o). 

        2. Inside a.out, the process may call _exit(value) anywhere to enter 
           Kernel to die IMMEDIATELY. Reason: if you want to die in a such a 
           hurry, why bother to clean up your room first?
           
           When a process dies, it records the byte_value in the _exit() call
           as the "cause of death" on its body, notifies its parent that it is
           dying and then becomes a ZOMBIE. The parent (either the original 
           parent or P1) will find the ZOMBIE, get its pid and "cause of death"
           value via the 
                         dead_child_pid = wait(&cause_of_death);
           system call, where cause_of_death has 2 bytes containing
                              |exitValue|signal#|
           Naturally, only one of the bytes would be non-zero, WHY?

        3. While executing, the process encounters an error (in YOUR a.out of
           course), which is recognized and "caught" by the CPU. The process is
           forced into the Unix kernel by a "trap". Once in kernel, it converts
           the trap error (type) into a magic number called a SIGNAL number and
           delivers the signal to itself, causing it to die. In this case, the
           ZOMBIE's "cause of death" is the signal number, and we may say that
           the process has died abnormally. 

           Examples: Try to run these C programs
                      int *p;
                      main(){   *p = 1;  }

                      int a,b,c;
                      main(){   c = a/b; }

                      main(){   main();  }

           What do you see and WHY?


        4. Killed by a signal, which may originate from hardware (interrupts)
           or sent by another process via the 
                      kill pid 
           command, which uses the kill(pid, singal#) system call.
           Example:  If you run the C program:
                        main()
                        {
                           while(1);
                        }       
           What would happen and how do you get out the mess?





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #3</H1>

<Pre>
            360 NOTES #3 Function Calls in C

Consider the program:

         main()
         { int a,b,c;
           a = 1; b = 2; c = 3;
           c = mysub(a,b);
           printf("c=%d\n", c); 
         }

         int mysub(int x, int y)
         {
           int u, v;
           u = 4; v = 5;
           return(x+y+u+v);
         }

The topics here are:
     ----------------------------------------------
     Function call conventions in C and stack usage.
     ----------------------------------------------

(1). When we execute a.out, a process image is created in memory, which looks 
     (logically) like the following:
   
     lowAddress                      HighAddress
          -----------------------------
          | Code | Data |  stack      |
          ----------------------------- 
(2). CPU registers:

     Every CPU has:

        PC register, which points to the next instruction
                     to be executed by the CPU.
        SP register, which points to the current top of 
                     the stack. (esp register)
        FP register, which points to the stack Frame of the
                     current active function (ebp register).
        A register for return value (eax register).

(3). Our main() is called by the C startup code, crt0.o. When crt0.o calls 
     main(), it pushes the return address (its current PC contents) onto stack,
     and enters main(). When main() is entered, the stack contains:

     HighAddress      ---------->              LowAddress
  
       --------------------------------------------- 
       XXXX|PC|
       --------------------------------------------- 
            ^ 
            SP 

     with SP pointing at the returnPC (where crt0.o called main().

(4). Upon entry, every C function does the following
     (4).1  push FP into stack;   this saves the FP register
     (4).2  let  FP point at the stack top, i.e. point at the saved FP.
     (4).3  shift SP downward to allocate space for local variables.
   
     For this example, there are 3 local variables, a,b,c, each 4 bytes long. 
     The stack becomes:

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  |
       --------------------------------------------- 
               ^         ^ 
               FP        SP 
               
(5). a=1; b=2; c=3;  The values 1,2,3 go to the locations of a,b,c, which are
     at -4, -8, -12 bytes from where FP is pointing at, respectively. 
     These are expressed as -4(FP), -8(FP), -12(FP) in assembly code.

(6). main() calls mysub() by  c = mysub(a,b);

     The compiled code for the function call consists of:

         PUSH parameters in reverse order:
              push b's value onto stack, push a's value onto stack,
         CALL mysub
              which pushes the current PC (contents) onto stack and replaces PC
              with the address of mysub, causing the CPU to enter mysub().
 
     When control just enters mysub(), the stack becomes

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  | 2| 1|PC|
       --------------------------------------------- 
                                  ^ 
                                  SP 

(7). mysub() is written in C.  Its actions are the same as those of main():
        push FP; 
        let FP point at the saved FP, and
        shift SP downward to allocate locals u,v. 
     Then the stack becomes
         
     HighAddress      ---------->              LowAddress
                  a  b  c               u  v 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  | 2| 1|PC|FP|  |  |
       --------------------------------------------- 
                                     ^     ^ 
                                     FP    SP 
(8). While in mysub(), 
 
               -----------------------------
               WHERE ARE x,y? WHERE ARE u,v?
               -----------------------------

     For this example, the parameters a, b are at 8(FP) and 12(FP), i.e at 
     where FP points at + 8 bytes, + 12 bytes.  Local variables u, v are at 
     -4(FP) and -8(FP).

     The stack area visible to a function (parameters and locals) is called 
     a stack FRAME (like a frame of movie). Thus, FP is called the stack
     FramePointer.
 
(9). Return from called function:

     When mysub executes return(expression); it puts the value of the 
     expression in the return value register (eax for 486/Pentinum CPUs).
     Then, it deallocates the local variables by

       .copy FP into SP;   stack top now contains the saved FP.
       .pop stack into FP; this restores FP, leaving the return PC on top of 
                           the stack.
       .RET   RET pops the stack top into PC register, causing the CPU to 
              execute from the "return address" saved earlier.

(10). Upon return, the caller function copies the contents of the return value
      register into c, then it pops the parameters a,b off the stack (by adding
      8 to SP). This restores the stack to the same situation before the call.
  
      Then it continues to the next statement.





<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                HOWTO open_close_lseek

int open_file()
{
  1. ask for a pathname and mode to open:
         You may use mode = 0|1|2|3 for R|W|RW|APPEND

  2. get pathname's inumber:
         ino = getino(&dev, pathname);

  3. get its Minode pointer
         mip = iget(dev,ino);  

  4. check mip->INODE.i_mode to verify it's a REGULAR file and permission OK.
     (Optional : do NOT check FILE type so that we can open DIRs for RW)
     
     Check whether the file is ALREADY opened with INCOMPATIBLE type:
           If it's already opened for W, RW, APPEND : reject.
           (that is, only multiple R are OK)

  5. allocate an OpenFileTable (OFT) entry and fill in values:
         oftp = falloc();       // get a FREE OFT
         oftp->mode = mode;     // open mode 
         oftp->refCount = 1;
         oftp->inodeptr = mip;  // point at the file's minode[]

  6. Depending on the open mode 0|1|2|3, set the OFT's offset accordingly:

      switch(mode){
         case 0 : oftp->offset = 0; 
                  break;
         case 1 : truncate(mip);        // W : truncate file to 0 size
                  oftp->offset = 0;
                  break;
         case 2 : oftp->offset = 0;    // RW does NOT truncate file
                  break;
         case 3 : oftp->offset =  mip->INODE.i_size;  // APPEND mode
                  break;
         default: printf("invalid mode\n");
                  return(-1);
      }

   7. find the SMALLEST i in running PROC's fd[ ] such that fd[i] is NULL
      Let running->fd[i] point at the OFT entry

   8. update INODE's time field. 
      for W|RW|APPEND mode : mark Minode[] dirty

   9. return i as the file descriptor
}


truncate(MINODE *mip)
{
  1. release mip->INODE's data blocks;
     a file may have 12 direct blocks, 256 indirect blocks and 256*256
     double indirect data blocks. release them all.
  2. update INODE's time field

  3. set INODE's size to 0 and mark Minode[ ] dirty
}
 
      
int close_file(int fd)
{
  1. verify fd is within range.

  2. verify running->fd[fd] is pointing at a OFT entry

  3. The following code segments should be fairly obvious:
     oftp = running->fd[fd];
     running->fd[fd] = 0;
     oftp->refCount--;
     if (oftp->refCount > 0) return 0;

     // last user of this OFT entry ==> dispose of the Minode[]
     mip = oftp->inodeptr;
     iput(mip);

     fdalloc(oftp);   (optional, refCount==0 says it's FREE)
     return 0; 
}

long lseek(int fd, long position)
{
  From fd, find the OFT entry. 

  change OFT entry's offset to position but make sure NOT to over run
  either end of the file.

  return originalPosition
}

int pfd()
{
  This function displays the currently opened files as follows:

       filename  fd  mode  offset
       --------  --  ----  ------ 
       /a/b/c     1  READ   1234       
  
  to help the user know what files has been opened.
}
<Title>360 Week 1 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
	<H1>360 Course Plan</H1>
	<Pre>                CPTS 360 COURSE PLAN
                    
                    Fall, 2008

COURSE TITLE : CPTS 360 Systems Programming

Reference    : Advanced Programming in the UNIX Environment, 
               W. Richard Stevens, Addison-Wesley, 1992.
CLASS NOTES  : www.eecs.wsu.edu/~cs360/

INSTRUCTORS  : K. C. Wang, Professor of EECS, Sloan 321
                           335-3769, kwang@eecs.wsu.edu
                           Office Hours: MW 9:10-10:00 AM
               TA: To be posted
   
PREQUISITES  : CPTS 250
  Basic knowledge and working experience in Unix commands.
  Ability to program in C or C++.

COURSE CONTENTS:
  Introduction to the Unix Operating System: 
     Files, directories, special files, logical organization of 
     Unix file system; user account, login process and command
     execution.

  Program development
     Source files;  compiler, assembler and object files; 
     linker, library and executable files; loader and execution 
     images. Symbolic debugger and run-time support.

  Execution image of C programs
     Code, data and stack segments; function calling convention, 
     stack frames and parameter passing; long jumps.

  File I/O
     System calls and low-level file I/O; open, close, read, write, 
     lseek, file descriptors and file sharing. Execution of User 
     mode and Kernel mode images, implementation and implications 
     of system calls.

  File Control
     Permissions and access control, fcntl, chown, chmod, hard 
     and soft links, file status and statistics. 
     I/O redirection, pipes, filters and applications.

  Standard I/O Library
     Streams and high-level file I/O; user space buffering, 
     relationship with low-level I/O,  char and line mode I/O. 
     Formatted I/O.

  File system implementation
     Inodes and file representation; mkfs and physical file 
     system layout; traversal of the file system tree; booting 
     system images.

  Processes
     Concept and implementation of processes, process execution 
     environment, user mode and kernel mode images, process
     states transitions. Processes in the Unix system; init, 
     login and user processes.

  Process Control
     fork, vfork, wait, exit, kill, exec operations. traps and 
     signal handling.

  Process Synchronization and Communication
     Signals, pipes, semaphores, messages and shared memory 
     segments. Sockets.
   
  Networking
     Introduction to Internet; host, address resolution, 
     routing; protocols, client and server; ftp, rlogin, nfs, 
     and nis, Socket Programming. 

  Project: Implement an ETX2 File System Simulator

  Misc Topics: sh and Perl programming, Unix system adm. 

COMPUTER SYSTEMS: (Sloan 327) 
     Pentinum based PCs running Linux.
     Other HP Unix systems and work stations for general usage.

LABORATORY: 
     Time : Wed 7:10-10 PM Place: Sloan 233
     (Firt Week: NO LAB)
---------------------------------------------------------------------
GRADING:
   Exam                      %30  (Date and form will be set later).
   Programming Assignments   %30
   Project                   %40   
---------------------------------------------------------------------

</Pre>
</Body>
<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes </H1>

<Pre>
         Lab #4 Pre-work: DUE: Sept 24, 2008 in Lab


Download the server.c andd client.c files for samples/LAB4.
Compile and test run the server and client on IP hosts.
============================================================
MODIFY the programs to do the following :
       client : send 2 numbers to server
       server : return the SUM of the 2 numbers to client
===========================================================
<Title>360 PROJECT FILE</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT</H1>
<Pre>
                    CPTS 360 PROJECT

               Date Assigned: Oct 13, 2008

 *****************************************************************************
  1.   DUE and DEMO: Wednesday to Thursday in Close Week.
       Sign up for demo time slots. Turn in a floppy disk AND a hard copy.
  2.   May work in 2-person teams. However, a comprehensive ORAL exam will 
       be given to EACH individual during the DEMO.  The ORAL exam score 
       will be a major part of your FINAL grade.
 ****************************************************************************

                     A. OBJECTIVE:
   Design and implement a Linux EXT2 file system simulator. 

                     B. SPECIFICATIONS:
1. Files:
   Files are exactly the same as they are in the Linux file system, i.e.
   we shall use the same EXT2 file system data structures for

      SuperBlock, GroupDescriptor, Bit-maps, Inode, Directory

   EXCEPTIONS:
      Only DIR and REG file types; no SPECIAL files.
      File size : No triple-indirect blocks.
      
   
2. Disks:
    Disks are REAL floppy disks OR "virtual disks" simulated by Linux files.  
    Disk I/O are simulated by Linux read()/write() operations on a BLKSIZE 
    basis. You may use Linux's, mkfs (mke2fs) to create EXT2 file systems.

3. File names:
   As in Unix, each file is identified by a pathname, e.g. /a/b/c or x/y/z.

   If a pathname begins with "/",  it's relative to the / directory.
   Otherwise, it's relative to the Current Working Directory (cwd) of the 
   running process (see Processes below). 

4. Processes:
   Every file operation is performed by a process. A process has a unique uid and pid.
   The simulator starts with TWO processes:
       A process P1 with uid=0 (for SUPERUSER), and
       A process P2 with uid=1 (for ordinary user).
   The initial CWD of both processes are initially /
  
   P1 runs first. P2 is in a readyQueue, which contains ALL processes
   that are ready to run.

   All processes executes the same code (i.e. the Simulator), in which it

       loop forever{
            prompt for a command;
            execute the command;
       }
 
   Each command is performed by the current running process. 
   
   Process management commands are:

      switch : switch process (to run another READY process).

      fork : create a child process with the SAME uid (and its own pid).
             As in Unix, the child process shares opened files with its parent.

      kill, exit: cause process to terminate.

5. File System Commands and Operations:
   Unlike Unix (Kernel), file operations will be executed as commands.
   The required commands are listed below. LEVEL 1 is the MINIMUM requirements 
   for passing.
    
              -------  LEVEL 1 ------------ 
               mount_root;
               mkdir, rmdir, ls, cd, pwd;
               creat, rm;       
               stat, chmod, touch;

              -------  LEVEl 2 -------------
               open,  close,  read,  write
               pfd,   lseek
               cat,   cp,     mv

              -------  LEVEl 3 ------------ 
               mount, umount,             
               Process Management Commands 
               File permission checking
              -----------------------------
      
   Unless as noted below, all commands behave exactly the same as they do in 
   Unix.
 
      pfd   : Show the valid fd's of the current process.

      write : Prompt for fd and a string of chars, then write the chars 
              to the file and show the number of chars written.

      read  : Prompt for fd and n, then read the file and DISPLAY the 
              chars that are read.
============================================================================
                       SAMPLE PROGRAMS:
                       ~cs360/samples/
 
       simulator.bin: The File System Simulator for EXT2 FS. 
                        Under Linux, use  
                              mkfs /dev/fd0 1440
                        to make an EXT2 FS on a FD.

                    Then, run the simulator to see what I expect of YOUR work.
============================================================================


<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT HELP </H1>
<Pre>
                     EECS 360 PROJECT HELP #1
    
Given: mkfs ======> make an EXT2 file system on /dev/fd0 (or a Linux file).


                     PROJECT ORGANIZATION

1. type.h (samples/type.h file)
          define constants, e.g. BLKSIZE, NPROC, NMINODE, NOFT, etc.
          define types for SUPER, INODE, DIR => same as in Linux
                
            MOUNT ==>   ---------------------------------------
                               dev       : disk identifier (fd number)
                               MinodePtr : pointer to mounted Minode

                               deviceName: pathname of mounted device  
                               MinodePath: pathname of mounted Minode
                          ---------------------------------------

            MINODE ==> In_Memory Inodes = ------
                                           INODE
                                          -------
                                          dev,ino
                                          refCount
                                          dirty
                                          mounted
                                          mountTablePtr
                                          (lock:optional)
                                           -------

            OFT   ===> OpenFileTable = --------- 
                                       mode: R|W|RW|A 
                                       refCount
                                       MinodePtr
                                       offset
                                       file's string name (optional)
                                       -------   

            PROC  ===> Process Structure = ptrs to other PROC's;
                                           pid, ppid, 
                                           uid;
                                           cwd ---> currentWorkingDir
                                           fd[NFD] = openfilePointers
                                           -------------------------- 
                
2. global.c ===> Ths file defines global variables, e.g.
                 MINODE *root;      pointer to root inode in memory.
                 PROC   *running;   pointer to current running process.
                 MINODE minode[100] in-memory inodes
                 etc

3. include.c ==> #include  "type.h"
                 #include  "global.c"
                 #include  "utility.c"
                 #include  "mountroot.c"
 
                 #include  "mkdir_creat.c"
                 #include  "cd_ls_pwd.c"
                 #include  "rmdir_rm.c"
                 #include  "other_level_1.c"

                 #include  "open_close_pfd.c"
                 #include  "write.c"
                 #include  "read.c"
                 #include  "cat_cp_mv.c"

                 #include  "mount_umount.c"
                 #include  "fork_switch_exit.c"
                 #include  "check_permission.c"

4. main.c:

   #include "include.c"

   init(){ 
           initialize the simulator system's data structures:
                MOUNT  mountTable[10];
                MINODE Minode[100];
                OFT    oft[100];
                PROC   proc[10];
            
           mount the rootdevice;  e.g. default to /dev/fd0
           Run porc[0] as the current process P0  with  cwd = /;
   }

             
   main()
   {
     init(); 
     while (1){
       print the current process ID;
       prompt for a commandString; ===>  mkdir, creat, cd, ....
              get paramter strings: e.g. mkdir pathaname

       cmdIndex = findCommand(commandString); ===> return 0,1,2,....

       switch(cmdIndex){
           case 0: mkdir(pathname);         break;
           case 1: creat_file(pathanme);    break;
           .......................................
           default: print INVALID command;
       }
   }

       
5. IMPLEMENT and TEST the commands in successive steps:

6. utility.c:
   This file implements the commonly used functions that are needed
   by the commands. It is suggested that you implement the following: 

(1). get_block(dev, buf, blkno);  read block to buf;
     put_block(dev, buf, blkno);  write block from buf


(2). Alocate/Deallocate functions:

     ialloc()/ idealloc() ===> allocate/deallocate an inode
     balloc()/ bdealloc() ===> allocate/deallocate a  file block;
     
     mialloc()/midealloc() ==> allocate an in memory inode 
     falloc()/fdealloc()   ==> allocate OFTE entry.

(3). ulong search(INODE *ip, char *name)
     search a DIR inode (data blocks) for name; 
     return ino if found, return 0 if not 

(4). THE MOST FUNDAMENTAL FUNCTION IS:

         ino = getino(&dev, char *pathname);

     which returns the ino of pathname.  The beginning dev is either / or
     the running proc's CWD, as in
                if (pathname[0] == '/')
                   dev = root->dev;
                else
                   dev = cwd->dev;
    However, while traversing the pathname, dev may change to that of a 
    mounted device.  So bring in &dev to keep track of the changes. 
    Alternatively, you may write ino = getino(char *pathname) and use a 
    global variable dev to record the CURRENT device number. 

    Upon return from getino(), we have (dev, ino) of the file.

    THIS IS SIMILAR TO YOUR showblock.c


(5). MINODE *iget(dev, ino) ==>   Return ptr to in-memory inode=(dev,ino);
                                  load the inode into a minode[] if necessary.
             iput(minodePtr); ==> Release the inode;  WRITE BACK TO DISK
                                                      IF refCount=0 and dirty.

(6). Others as needed:

     Given ip->inode in memory, find its parent's ino;

     Given a parent ip->inode in memory, and a child stringName,
           search for the childName.
           search for an unused directory entry.



              HOW TO GENERATE THE simulator EXECUTABLE

                       METHOD 1:

As shown above, main.c includes ALL the needed .c files. So
         cc -o simulator main.c
would generate the simulator executable. In this approach, the .h file
can only be included ONCE. 


                    METHOD 2: Use make
The is the preferred method of managing a LARGE set of C programs.
To use the make facility, you need to create a Makefile (or makefile) containing
instructions for make to follow.  make reads the Makefile, compiles the .c 
files (as needed) and link the .o files into an executable.

NOTE: in this approach, each .c file must include the .h file and use
      extern to declare any needed (global) variables.
 
To learn more about makefile contents, read Linux's /usr/info/make.info-1, etc.
Here, we show a makefile for the project.

#            # starts a comment line, which is ignored by make

# ***************************************************************************
#                    Example Makefile
#            Save these as Makfile or makefile Then run  make
# ***************************************************************************

# Variable H defines the head file (string)

H = type.h

# Variable OBJ defines the string containing .o file names
# NOTE: this is ONE line, but splitted into several lines for easier to read

OBJS = global.o alloc_dalloc.o util.o mount_umount.o mkdir_creat.o \
       stat.o cd_ls_pwd.o rmdir_rm.o open_close.o read.o write.o \
       cp_mv.o cs_fork.o main.o

# simulator:  is a rule, which says simulator DEPENDS on $(OBJ), the (string)
# value of the OBJ variable
    
simulator : $(OBJS)

# This rule tell make how to generate simulator: by    cc $(OBJ s.s
# NOTE !!! Each ACTION rule must begin with a TAB char, NOT a bunch of spaces.

	cc  -o simulator $(OBJS) s.s


# These tell make how to generate each .o file from a corresponding .c file.
# Each .o file DEPENDs on $(H), whcih means: The .o file will be generated 
# again if $(H) are changed. This certainly makes sense since each .c file
# depends on the TYPEs in type.h.

global.o : $(H)

alloc_dalloc.o : $(H)

util.o :  $(H)

mount_umount.o :  $(H)

mkdir_creat.o : $(H)

stat.o : $(H)

cd_ls_pwd.o : $(H)

rmdir_rm.o : $(H)

open_close.o : $(H)

read.o : $(H)

write.o : $(H)

cp_mv.o : $(H)

cs_fork.o : $(H)

main.o : $(H)


# make clean  ==>  remove the executable and all the .o files
clean :
	rm simulator *.o



<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                      HOWTO read

int read_file()
{
  Preparations:
   ask for a fd  and  nbytes to read
   verify that fd is indeed opened for READ or RW

   return(myread(fd, buf, nbytes));
}
 

// myread() behaves exactly the same as Unix's read(fd, buf, nbytes) syscall
// it tries to read nbytes from fd to buf[ ], and returns the actual number of
// bytes read.

int myread(int fd, char *buf, int nbytes)
{
 1. size = fileSize - OFT's offset //number of bytes remain in file.

 2. while (nbytes > 0 && size > 0){
     compute LOGICAL BLOCK lbk and startByte in that block from offset;
           lbk       = oftp->offset / BLOCK_SIZE;
           startByte = oftp->offset % BLOCK_SIZE;
     
     // I only show how to read DIRECT BLOCKS. YOU do INDIRECT and D_INDIRECT
 
     if (lbk < 12){              // direct block
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12) { 
          //  indirect blocks 
     }
     else{ 
          //  double indirect blocks
     } 

     /* get the data block into readbuf[] */
     get_block(mip->dev, blk, readbuf);

     /* copy from startByte to buf[], at most remain bytes in this block */
     char *cp = readbuf + startByte;   
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in readbuf[]

     while (remain > 0){
            *cq++ = *cp++;             // cq points at buf[ ]       
             oftp->offset++; 
             count++;                  // count=0 for counting
             size--; nbytes--;  remain--;
             if (nbytes <= 0 || size <= 0) 
                 break;
     }
 
     // if one data block is not enough, loop back to OUTER while for more ...

 }

 show ("myread : read %d char from file %d\n", count, fd);  

 return count;    // count is a actual number of bytes read
}
<html>
<body>
<pre>

                 360 Review Questions

1. What happens when you login to Unix?

2. Write C statements for a struct containing
         ---------------------------------------    
         NEXT  : a pointer to the SAME struct
         ID    : an integer                         
         NAME  : an array of 256 chars              
         ---------------------------------------    
   Write C statements to print the contents of a list.

3. What's cc? (Steps and what does each step do)
   Dynamic Vs. static linking?

4. Given a C program,

        int g;
        int h = 1;

        main(int argc, char *argv[])      int A(        )
        {                                 {                            
           int a,b,c;                        int u,v;
           a = 2; 
           b = 3;                            HERE:       
           c = A(a,b,"hello");      
        }                                 }  

   (0). Complete the function heading of A(....)
   (1). Which variables are global? local?   
   (2). Which variables are in a.out?
   (3). In the run-time memory of a.out, where are the variables?

   (4). Execution is at HERE:  Show the stack contents from HERE to main()'s 
                               argc and argv.

5. A simple function in assembly:
            .global sub
   sub:

   ENTRY:   pushl   %ebp
            movl    %esp, %ebp
   
   BODY:
            movl    $1234, %eax
            movl     1234, %eax            

   EXIT:
            movl    %ebp, %esp
            popl    %ebp
            ret

   (0). What's purpose of .global sub ?
   (1). What's the purpose of the statements at ENTRY?
   (2). What's the difference between the 2 statements in BODY?
   (3). What does the EXIT part do?

6. int pid, dead, how;

   pid = fork();              What does it do?

   if (pid){ // do this }     which process does this?
   else{     // do that }     which process does that?

   dead = wait(&how);         IF CALLED BY THE ABOVE 2 processes, dead=? how=?

7. What does  int   r = execve("a.out", argv, env);    do?
   How does the system find a.out?
   Draw a diagram to show exactly what's argv?
   What's the value of r? (It can only have ONE possible value !!!)

8. a.out is the binary executable of the C program
     main(int argc, char *argv[], char *env[])
     {
       execve(argv[0], argv, env);
     }
   What would happen?
   HOW TO GET OUT THE MESS?

9. When run  a.out > outfile, how does sh do the I/O re-direction?

10. You can use the Unix command  mkdir /a/b/c  to make a directory.
    Write a C statement for the mkdir command.
    
11. open,  read,  write are system calls
   fopen, fread, fwrite are library I/O functions.

   What's their RELATIONSHIP? 
   WHY do wee need lib I/O functions?

   Write C code to
     open a file for READ; read the SECOND block of 1024 bytes into a buf[]
     open a file for WRITE (CREAT if needed); write a string of chars to it.

12. stat():
    What does it do?
    HOW TO determine a files's type, e.g. REG or DIR?
    HOW TO get the file size, creation time?
    How to print creation time in calendar form?
    How to tell whether 2 pathnames are really the SAME file?

13. HOW TO use opendir(), readdir()?

14. Network Programming using TCP
    What's IP? what's TCP? HOW DOES TCP achieve reliable data transfer?
    What's an IP address, a Port Number?
    Network (bytes) order Vs. host order?
    Compare a socket (number) with a file descriptor?

    In a TCP Server-Client model, to establish a "virtual" connection,

       What should the Server do?   |    What should the Client do? 
            
          (After Server accepted a Client connection)                      
       How does the Server know where is the Client?
            HOW DO THEY communicate with each other?

    HOW TO let the Server deal with multiple Clients?

15. mkfs:
    What's a bit map?
    Assume : char buf[1204], block 4 of a FD contains a bit map for inodes.
             INODE my_inode is an INODE struct.

    Write C code for the following:
   (1). read disk block 4 into buf[].
   (2). serach for a FREE inode (number) in the bit map, change it to BUSY
        and return the inode number.
   (3). copy the inode on disk to my_inode.


16. showblock:

    ASSUME: char buf[1024] contains a data block of a directory, such as that of /
    Write C code to 
      (1). search for a name string "abcde" in that data block.
      (2). while searching, print the names of the DIR entries in that block.









<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP : HOWTO rmdir_rm</H1>

<Pre>

int rmdir()
{
  1. ask for a pathname to rmdir
  2. get its inumber :  
         ino = getino(&dev, pathname) 
  3. get a pointer to its Minode[] :   
         mip = iget(dev, ino);

  4. check DIR type */
       if NOT : iput(mip); retunr -1;
 
  5. check ownership 
       super user : OK
       not super user: uid must match

  5. check for BUSY or mounted on ?
       test refCount and mounted flag

  6. check whether it's empty
     First, check link count (inks_count > 2 means not empty);
     However, links_count == 2 may still have FILEs, so go through its data 
     block(s) to see whether it has any entries in addition to . and ..

  7. Assume empty:
       get parent DIR's ino and Minode (pointed by pip);
       remove child's entry from parent directory:

       rm_child(pip, me, child);   pip->parent Minode, me=my_inumber
                                   child = nameString to remove

  8. deallocate its block and inode
     for (i=0; i<12; i++){
         if (mip->INODE.i_block[i]==0)
             continue;
         bdalloc(mip->dev, mip->INODE.i_block[i]);
     }
     idalloc(mip->dev, mip->ino);
     mip->refCount = 0;

     decrement pip's link_count by 1; 
     touch pip's atime, mtime fields;
     mark pip dirty;
     iput(pip);
     return(0);
}


int rm(pathname) char *pathname;
{
   1. get its ino and inode */
          ino = getino(&dev, temp);

   2. get its Minode pointer
          mip = iget(dev, ino);

   3. check busy:
          check refCount

   4. check FILE type */

   5. check ownership

   6. get parent's ino and Minode pointer
          pino = getino(&dev, parent);
          pip  = iget(dev, pino);

   7. remove name from parent directory */
          rm_child(pip, ino, child);

   8 deallocate direct and indirect data blocks */
     for (i=0; i<12; i++){
        if (mip->INODE.i_block[i]) 
            bdalloc(mip->dev, mip->INODE.i_block[i]);
      }
    
     deallocate indirect data blocks AND the indirect blocks themselves 
     NOTE: you MUST allow files to have DOUBLE indirect blocks

   9. deallocate its inode :
         idalloc(mip->dev, mip->ino);
   
   10. mip->refCount = 0;

   11. dispose of parent's Minode
       touch pip; mark pip dirty;
       iput(pip);
   
   return(0);
}



// rm_child() is common to both rmdir and rm. It remove an entry [me, child]
   from the parent's data block. WATCH the clever tricks used here.

int rm_child(parent, me, child)
    MINODE *parent; unsigned long me; char *child;
{
   1. Search parent INODE's data block(s) for an entry eqaul to me
   2. Erase my name from parent directory:
       if first entry in block ==> set my ino to 0;   
       if NOT first entry in block ==> absorb my rec_len to the previous entry;
          (this effectively makes my_entry disappear;
           no need to change parent's fileSize)
   3. Write the parent's data block back to disk
}




<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Sh Programming</H1>

<Pre>
1. sh scripts:
   A sh script is a text file containing sh statements for sh to execute.
   Example: Text edit a file, mysh,  containing
            -----------------------------------
            #! /bin/bash
            # comment line
            echo hello
            -----------------------------------
   Use chmod +x mysh to make it executable. Then run mysh. It will print hello.

2. Command-line parameters:
   Similar to running C programs, sh scripts can be invoked with parameters, 
   as in      mysh one two three

   $# = the number of such parameters, which are known as $1 to $9. $0 is the
        program name itself.
   $* = ALL command-line parameter (strings) $1 $2 ....
   
   Example:
            ------------------
            echo $#
            echo $1 $2
            echo $*
           -----------------
   mysh                      ====> print  0 
                 
   mysh one two three        ====> print  3
                                           one two
                                           one two three
2. sh Statements

2-1. sh statements include all Unix commands, with I/O re-directions.
     Examples:    ls           ; ls > outfile 
                  date         
                  cp f1 f2
                  mkdir new
                  cat filename

2-2. Simple sh (built-in) statements
     echo This is a line              # display This is a line
     echo "This is     a   line"      # display This is    a   line
     echo -n hi                       # display hi without NEWLINE  
     echo    there                    # display hithere
     
     shift, eval (will be explained later).

2-3. Command Substitution:
     When sh sees $(cmd), it executes cmd first, and SUSTITUTEs $(cmd)
     with the RESULT (string) of the execution.

     echo $(date)       ==> display current date string
     echo $(ls)         ==> display the result of ls command 


3. Sh Variables:
   Sh has many built-in variables, e.g. PATH, HOME.
   You may use any symbol as sh variable. No declaration is necessary.
   sh variable values are STRINGs !!! If A is a variable, $A is its value.
   Examples
      echo A   ==>  A
      echo $A  ==>        (null string if A is not set)
      A="this is fun"     # set A value
      echo $A  ==> this is fun
      B=A
      echo $B   ==> A     (B was assigned the string "A")
      B=$A                (B takes the VALUE of A)
      echo $B   ==> this is fun

      echo -n "enter yes or no "
      read ANS            # sh reads an input line from stdin; try read A1 A2 with "one two three"
      echo $ANS

      local X             # X is local to this sh; not available in child sh
      export Y            # variable Y will be passed to child sh process

4. Quotes:
   Sh has many special chars, such as $, /, *, >, <, etc.  
   To use these as ordinary chars, use \ to quote them, as in
         echo \$A     ==> $A
     OR  echo '$A'    ==> $A    (NO substitution within SINGLE quotes)

         echo " this is $A"     (DOUBLE quotes will substitute $A !!!)

5. sh statements
5-1. if-else-fi statement
     if [ condition ]
       then
          statements
       else                # as usual, the else part is optional
          statements
     fi

Example:
echo ------------------------------
echo This sh script copies f1 to f2
echo "     then removes f2"        # Use double-quotes " " to include spaces
echo ------------------------------

# $# is the number of command line parameters, which are known as 
# $1,$2,$3,...., $9    As usual, $0 is the name of the execcutable itself.
# Here, $# must be 2. If not show Usage and exit

# By default, all values in sh are strings, so they can be compared by
#  if [ s1 = s2 ];  if [ s1 != s2 ];   if [ s1 \< s2 ]; if [ s1 \> s2 ]; etc.
# Note the spaces between the tokens

# In contrast, the operators -eq, -ne, -lt, -gt compare them as (integer)
# NUMBERS, thus
#  if [ "123" = "0123" ]  is false (since they differ as strings)
#  if [ "123" -eq "0123" ] is true. Since everything is string, you may use
#  if [ 123 -eq 0123 ] OR  if ["123" -eq 0123 ]

# Here we compare them as STRINGs; 
if [ $# != 2 ] 
then
     echo Usage: copy file1 file2
     exit 1
fi

# $1 is the first parameter string, $2 the second, etc.

echo You are copying $1 to $2 
echo in the directory $(pwd)     # COMMAND SUBSTITUTION

echo copying $1 to $2 ....
     cp  $1  $2                 # this is the actual copy operation
echo done

echo show $2 has been created ....
  ls -l $2
echo now try to remove $2

# if $2 exists as a file:
if [ -e $2 ]  
 then 
   echo removing $2 .....
   rm $2
fi
echo
echo all done
echo Let\'s go on .....      # QUOTE the special char ' by \ 

# ***************** DO THESE:  ****************************
# In sh, the following tests can be used:
# if [ -e name ]      test whether file name exists
# if [ -f name ]      test whether name is a (REG) file
# if [ -d name ]      test whether name is a DIR
# if [ -r name ]      test whether name is readable; also -w,-x
# if [ f1 -ef f2 ]    test whether f1, f2 are the SAME file
#.........................................................

                   EXERCISES:

# MODIFY the above sh program to do these:

#1. Check whether f1 exists. If not, echo a message and exit;

#2. Check whether f2 exists.  
#      If f2 already exists:
#         echo a message:     OK to over-write f2 (y/n)?
#         read user's response by    read ANS
#         if $ANS = "y" ===> go on, else exit.

#3. Ask for a directory name (relative to user's $HOME)
#   DIR to do the copying. Then copy f1 to f2, all in that 
#   directory.

#   read DIR
#   cd $DIR  will cd to that directory
#   (cd $DIR; sh commands; .....)  ==> commands grouping
#                                   
#   Alternatively, you may stay in the current directory 
#   but generate the right file names from $1 and $2.
#   basename a/b/c/d  ====> d 
    
# ******************************************************

5-2. for statement in sh:

       for VARIABLE in string1 string2,...., stringn
         do
            commands
         done

   Examples:
      for FRUIT in  apple  orange  banana  cherry
        do
           echo $FRUIT     ===> apple  orange  banana  cherry 
        done 

      for NAME in $* 
        do
          echo $NAME      ==>  all command-line param strings
          if [ -f $NAME ]; then
             echo $NAME is a file
          fi
          if [ -d $NAME ]; then
             echo $NAME is a DIR
          fi
        done


5-3. while [ condition ]
       do
          commands
       done

  -------------------------------------------------------------------
                  Example:
   echo '$#' = $#         # echo the number of parameters 
   I=0                    # set I to "0" (STRING !!!!) 
   while [ $1 ]           # while $1 is not the empty string
   do
      echo $1             # echo current $1
      I=$(expr $I + 1)    # use expr to change I from "0" to "1"
      shift               # shift once, $2 becomes $1, $3 becomes $2, ... etc.
   done
          
   echo I = $I            # total number of parameters 
  --------------------------------------------------------------------

5-4 Other Flow-Control statements:

    until [ "$ANS" = "give up" ]
    do
        echo -n "enter your answer : "
        read ANS
    done
   
    case statement (SELF-STUDY)

5-5. break and continue statements:
     They work exactly the same as they do in C

6 sh Processing Steps:

  Assume:   A='$B'    B='new.*'    C=newdir
   For each command line, e,g,
        cp  $A `pwd`/$C
   sh evaluates the variables in the following order:

   (1). Parameter substitution: (only scan ONCE) ==>
        cp  $A `pwd`/$C          Replace $A, $C ===> becomes  
        cp  $B `pwd`/newdir      NOTE that $A is replaced only ONCE.
    
   (2). Command substitution:
        cp  $B `pwd`/newdir     Perform `pwd` ===>   becomes
        cp  $B /a/b/c/newdir    (assuming CWD=/a/b/c)

   (3). Blank Interpretation:
        Use the value of $IFS (usually space,tab and newline) to
        break up the chars into non-blank words. ==> 
        cp  $B /a/b/c/newdir    NO change here.
       
   (4). File name generation:
        Each word is scanned for file pattern characters *, ?, [..]
        to generate a list of filenames, which replace the word.

        cp  $B /a/b/c/newdir    There are no file pattern chars, so no change.
                                This is the final command to sh.
        ------------------------------------------------------------- 
                         
7. eval  is a sh built-in command, which is executed by sh itself without
   forking a new process.   Each  eval  evaluates the input string ONCE 
   and use the results as inputs to sh. 

   Example 1: Assume execution of do_it generates output lines
                   A=a\nB=b\nC=c\n

            Then,  eval $(do_it)

            generates A=a\nB=b\C=c\n as inputs to sh AS IF you have
            entered the lines
                               A=a  
                               B=b
                               C=c
            Thus, sh will set the variables A,B,C to a,b,c, respectively.
             
   Example 2: Assume: A='$B'     B='new.*'     C=newdir
            Then    eval echo $A  ==> generates  
                         echo $B      to sh, resulting   ===>  new.*

   Now, consider this command:

        eval cp $A `pwd`/$C     ===> eval  first converts this to
             cp $B `pwd`/newdir ===> and uses this as inputs to sh.
   
   With these inputs, sh will do the substitutions of Steps (1) to (3).
   The command at Step (4) is

             cp new.* /a/b/c/newdir 

   Step 4 : The command line has a file wild-card char *.
            sh will replace the word  new.* by the filenames 
            new.X, new,Y,... (assuming they exist) and finally 
            executes

            cp new.X new.Y ...  /a/b/c/newdir

4. Within a pair of double quotes, parameter and command substituions occur 
   but blank interpretation and file name generation do not.
 
8. sh FUNCTIONS (by examples)
    --------------------------------------------------------
     # check_file() is a function, NOT the entry point

              check_file()     
              {
                local A=localVariable    # A is local to this function

                if [ -f $1 ]; then
                   return 0
                fi
                return 1
              }

     # Here is the entry point of the program
     # Usage : thisFile  f1 f2  f3 ......

              for FILE in $*             # for FILE in $1 $2 ....
              do
                  check_file  $FILE      # call check_file() 
                  if [ $? = 0 ]          # returnCode == 0 ?
                     then
                         echo $FILE is a regular file
                     else
                         echo $FILE is not regular
                  fi
              done
     -------------------------------------------------------------

9. Utility Programs and sh Programming
   
   expr is a utility program. It is used as
        expr x Operator y
   It evaluates the the expression (x Operator y), where Operator is
   any valid operator in C, e.g.
         expr 3 + 5  ==>  8
         expr 3 \* 5 ==> 15   #NOTE: * must be quoted 
         expr 5 % 3  ==>  1   etc

   There are many utility programs, such as basename, grep, sed, cut, etc. 
   which are used so often that they have become almost an indispensible part 
   of sh programming. You are free to develop your own utility programs and,
   if they prove to be useful enough, include them in the Unix command set.
   Many Unix commands originated this way. As they say: Necessity is the
   Mother of all inventions.

   For example, suppose you want to have a myinc operator, which
   increments a sh (COUNTing) variable by one.  You may write it as

       main(int argc, char *argv[])
       {  
          int i = 0;
          if (argc > 1)
             i = atoi(argv[1]) + 1;;
          printf("%d",i);
       }

   Then, use myinc to replace  expr  for incrementing $I by 1.

10. I/O Redirection:

   When entering a sh command, we may instruct sh to re-direct I/O
   to files other than the default stdin, stdout, sterr. I/O redirections
   have the following form and meaning:
      -------------------------------------------------
      >  file   stdout goes to file, which will be created if non-existing.
      >> file   stdout append to file
      <  file   use file as stdin; file must exist and have r permission.
      << word   take inputs from "here" file until a line containing only 
                "word" is encountered. 
                Try these:
                ---------------------------------------------
                echo << END    
                  keep entering lines until a line with only
                  END
                --------------------------------------------
                cat << DONE
                  keep entering lines until
                DONE
                -------------------------------------------

      >&2      dup (see below) the fd=2 and use the result as stdout.

      <&3      dup fd=3 and use the result as stdin
      --------------------------------------------------
      A digit may preceed any of these to mean: use that fd instead of 
      stdin or stdout.  Examples:
                2> file           stderr to file
                2>> file          stderr append to file
                2>&1              dup 1 and use it as 2 ==> merge 1 and 2

8-1. dup and dup2 syscalls:

     int dup(int fd);
     
     dup() duplicates a file descriptor by creating a new fileDescriptor
     using the lowest fd number. It returns the new fd,  or -1 if failed.

     -------------------------------------------------------------      
     Example 1:  int fd = open("infile", 0);  /* open for READ */
                   close(0);    /* This frees fd[0]*/
                   dup(fd);     /* dup fd into fd[0] */

               /*** from here on stdin is the same as fd */
                   sscanf(FMT, &items);  will input from infile.

     ------------------------------------------------------------
     Example 2:  int gd = creat("outfile", 0644);
                     close(1);  /* this frees  fd[1] */
                     dup(gd);   /* dup gd into fd[1] */
               /** from here on stdout is really gd ***/
                     printf("hello world\n");  will go to outfile.
     ------------------------------------------------------------

     int dup2(int old_fd, int new_fd);

         duplicates  old_fd  into  fd[new_fd].  It closes new_fd first, 
         if necessary.  dup2(gd, 0) is equivalent to  close(0); followed
         by  dup(gd);

     ------------------------------------------------------------
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                 HOWTO STAT_CD_LS_PWD

1. HOW TO stat:

   struct stat mystat; 
   char *pathname = "/a/b/c/d";
 
   r = do_stat(pathname, &mystat); 

int do_stat(char *pathname, struct stat *stPtr)
{
  1. Get inode of pathname into an MINODE:
         ino = getino(&dev, pathname); 
         mip = iget(dev, ino);          // iget() returns a pointer to minode[]
         
  3. Copy entries of INODE into stat struct;

     As you can see, everything needed by the stat struct is in MINODE.
     Write C statements to copy from mip->INODE to stPtr->fields.

       struct ext2_inode {
	i_mode;		/* File mode */
	i_uid;		/* Owner Uid */
	i_size;		/* Size in bytes */
	i_atime;	/* Access time */
	i_ctime;	/* Creation time */
	i_mtime;	/* Modification time */
	i_dtime;	/* Deletion Time */
	i_gid;		/* Group Id */
	i_links_count;	/* Links count */
	i_blocks;	/* Blocks count */
        .................................
        i_block[15];    // Allocated disk blocks 
      }

      struct stat {
        st_dev;      // dev
        st_ino;      // ino

        st_mode;     // i_mode
        st_nlink;    // i_links_count
        st_uid;      // i_uid
        st_gid;      // i_gid
        st_rdev;     // IGNORE THIS
        st_size;     // i_size
        st_blksize;  // 1024
        st_blocks;   // i_blocks
        st_atime;    // i_atime
        st_mtime;    // i_mtime
        st_ctime;    // i_ctime
      };

  4. Print the entries of the stat struct;
  5. iput(mip);      // dispose of the in memory inode; see NOTE below.
     return 0 for success;
}
============================================================================
NOTE: In general,   mip = iget(dev, ino); and
                          iput(mip);
      should occur in pairs, with only a few exceptions:

       cd()   : iget(new CWD) but iput(old CWD)
       open() : iget() but close() does iput().
       mount(): iget() but umount() does input().
============================================================================
2. HOW TO ls:

int do_ls(char *pathname) 
{
 
  1. If pathname==NULL, ls CWD.

  2. YOU MAY USE do_stat() OR work on the INODE of pathname directly.
  
  3. In either case, USE YOUR myls LAB program here.

  4. return 0 for SUCCESS

}


3. HOW TO cd:

int do_cd(char *pathname)
{
  1. if pathname==NULL ==> cd to root (default HOME dir) AS SHOWN:

     if (pathname[0] == 0){
        iput(rnning->cwd);                 // dispose of CWD
        running->cwd = iget(rootdev, 2);   // OR running->cwd = root; 
                                           //    root->refCount++;
        return 0;
     }
     

  2. Get INODE of pathname into a MINODE:
         ino = getino(&dev, pathname);     // return BAD if ino==0

  3. Get inode into an MINODE slot.
         mip = iget(dev, ino);

  4. Check DIR type ==> if NOT DIR: 
                           iput(mip); YELL at user; return BAD;

  5. Dispose of original running->cwd (by iput(running->cwd) ); 
     Change running->cwd to point at this Minode in memroy;
     return 0 for OK;
}


3. HOW TO pwd:

int do_pwd()
{ pwd(running->CWD); }

pwd(wd) MINODE *wd;
{ 
   Write this function as a recursive fucnction, which

   1. if wd is already the root:
         print /; return;

   2. Get parent's MINODE pointer wd; 
          (HOW? get i_block[0]; then iget(dev, ino of ..))
      Call pwd(wd) again with parent's MINODE pointer;

   3. Print wd's name followed by a /;
          (HOW TO get the name string of a MINODE?)

          2 ways: if you recorded the pathname of a file in its MINODE,
                  then it's the basename() of that string.
          OR    : You have this guy's ino and its parent's MINODE.
                  Search the parent DIR for an entry with this ino. Then, you
                  have its name. I PREFER THIS method !!!

   4. FOR LEVEL-3: If you implement MOUNTing, make sure your recursion can
                     cross mounting points.
}


<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #7</H1>

<Pre>

         360 Notes #7 System Calls for File Operations

1. What are syscalls?

   Syscall is a mechanism that allows a process to enter Kernel mode to 
   perform operations not allowed in User mode. Operations such as open files,
   read/write files, fork, exec, even termination, must all be done in Kernel.
   In this set of notes, we shall focus on Unix syscalls for file operations.
   
2. Where to find these information:

   Under Linux, the man pages of all syscalls are listed in /usr/man/man2/.
   The Unix command man 2 NAME displays the man pages of NAME in man2/. 
   Similarly, man 8 mkfs displays the man pages of mkfs in /usr/man/man8/. 

   DO: practice using man to read Linux's man pages.
 
3. How to use these functions?

   Include them in your C program, just like ordinary function calls. A return 
   value >=0 means OK, -1 means BAD. An implicitly defined global int variable,
   errno, records the error code.  Each error code number has a corresponding
   string description, as the following program shows.

            #include &lterrno.h&gt
            main()
            {
              if (mkdir("newdir", 0777) < 0){
                 printf("errno=%d : %s\n", errno, strerror(errno));
              }
            }

    If you run the program twice, the second time it will print
                   errno=17 : File exists
    as it should.
    ************************************************************** 
                 EXERCISES: (Some already in LAB#2)
       Write a C program to test :  
               mkdir, rmdir, chdir, creat, unlink, rename, chmod
    **************************************************************

4. READ and LEARN how to use these syscalls on your own:

   access : check user's permissions for a file : R_OK,W_OK,X_OK,F_OK. 
            int access(const char *pathname, int mode);

   chdir  : change directory
            int chdir(const char *path);

   chmod  : change permissions of a file
            int chmod(const char *path, mode_t mode);

   OTHERS : chown, chroot, setuid


   mkdir  : create a directory
            int mkdir(const char *pathname, mode_t mode);

   rmdir  : remove a directory (must be empty)
            int rmdir(const char *pathname);

   link   : make a new name for a file
            int link(const char *oldpath, const char *newpath);


   unlink : delete a name and possibly the file it refers to
            int unlink(const char *pathname);

   symlink: create a symbolic link for a file
            int symlink(const char *oldpath, const char *newpath);

   rename : change the name of a file
            int rename(const char *oldpath, const char *newpath);
  
                       SPECIAL ONES:

   mount  : int  mount(const  char  *specialfile, const char * dir , 
                       const char *filesystemtype, unsigned long mountflags , 
                       const void * data);

   umount : int umount(const char *dir);

   mknod  : make special files, e.g.  mknod /dev/fd2 b 2 2


5. To be covered in details in class:

      open, creat, umask
      read, write, lseek
      close

      opendir : DIR *opendir(const char *name);
      readdir : int readdir(unsigned int fd, struct dirent *dirp, unsigned int count);
      readlink: int readlink(const char *path, char *buf, size_t bufsiz);

      stat :  int stat(const char *file_name, struct stat *buf);
              int fstat(int filedes, struct stat *buf);
              int lstat(const char *file_name, struct stat *buf);


6. The stat Systen Call

6-1. Link Files:
   In Unix, every file has a pathname, such as /a/b/c. However, Unix allows 
different pathnames to represent the same file. These are known as LINK files.
There are two kinds of LINKs, HARD link and SOFT link. 

HARD Links: 
     The command    ln  oldpath  newpath 

creates a HARD link from newpath to oldpath. The corresponding syscall is

          link(char *oldpath, char *newpath)

NOTE: Hard links can only be applied to non-DIR files. 
      (What would happen if DIRs could  be hard linked ?) 

Hard linked files share the same inode, whose nlink field records the number of
hard links to the inode. Converse to link, the syscall
 
        unlink(char *pathname)

finds the inode of pathname and decrements its nlink by 1. The file is truly 
removed only if nlink becomes 0. This is what the rm command does.
    
SOFT Links:  
     The command   ln -s  oldpath newpath  

creates a SOFT or Symbolic link from newpath to oldpath. The corresponding
syscall is 
             symlink(char *oldpath, char *newpath)

The newpath is (almost a regular) file, which contains the oldpath string. It
acts like a detour road sign, which directs the traffic to the real destination
(oldpath). Unlike hard links, soft links can be applied to any file, such as

             ln -s   aVeryLongPathname                 a
             ln -s   aFileWhichMayBeChangedOften       b

One drawback of soft link is that the target file may NOT exist. If so, the
detour would direct the poor driver to fall off a cliff. In Linux, such death
traps are displayed in (the appropriate color of) RED under the ls -l command.

Also, if foo -> /a/b/c is a soft link file, the open("foo", 0) syscall, as 
implemented, will open the target file /a/b/c, not the link file foo itself. 
So, the open()/read() syscalls would NOT read any soft link file. Instead, the
syscall, readlink(), must be used to read the contents of a soft link file. 

 
A Brief Summary about Links:
           Command                               Syscall used
  =======================================================================
    ln     oldpath newpath             link(char *oldpath, char *newpath)
    ln -s  oldpath newpath          symlink(char *oldpath, char *newpath)
  =======================================================================

6-2. File Status:
   Every file has a UNIQUE inode, whcih contain ALL the information about the
file. The syscalls, stat/lstat/fstat, return the info of a file. (

9-2-1. INODE:
     Every file is represented by a unique INODE data strucutre, which is shown
here for reference.:

struct ext2_inode {
  unsigned short i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[15];
  // several other unimportant fields
};

6-2.2  The man pages of stat:
    Use  man stat  to read the man pages of the stat system call, which is 
shown below.
=============================================================================
STAT(2)                    System calls                   STAT(2)

NAME
       stat, fstat, lstat - get file status

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;

       int stat(const char *file_name, struct stat *buf);
       int fstat(int filedes, struct stat *buf);
       int lstat(const char *file_name, struct stat *buf);

DESCRIPTION
       These  functions  return  information  about the specified
       file.  You do not need any access rights to  the  file  to
       get  this  information  but  you need search rights to all
       directories named in the path leading to the file.

       stat stats the file pointed to by file_name and  fills  in
       buf.

       lstat  is  identical to stat, except in the case of a sym-
       bolic link, where the link itself is stat-ed, not the file
       that it refers to.

       fstat  is identical to stat, only the open file pointed to
       by filedes (as returned by open(2)) is stated in place  of
       file_name.


       They  all return a stat structure, which contains the fol-
       lowing fields:

            struct stat {
                dev_t         st_dev;      /* device */
                ino_t         st_ino;      /* inode */
                mode_t        st_mode;     /* protection */
                nlink_t       st_nlink;    /* number of hard links */
                uid_t         st_uid;      /* user ID of owner */
                gid_t         st_gid;      /* group ID of owner */
                dev_t         st_rdev;     /* device type (if inode device) */
                off_t         st_size;     /* total size, in bytes */
                unsigned long st_blksize;  /* blocksize for filesystem I/O */
                unsigned long st_blocks;   /* number of blocks allocated */
                time_t        st_atime;    /* time of last access */
                time_t        st_mtime;    /* time of last modification */
                time_t        st_ctime;    /* time of last change */
            };

       The value st_size gives the size of the file (if it  is  a
       regular file or a symlink) in bytes. The size of a symlink
       is the length of the pathname it contains, without  trail-
       ing NULL.

       The value st_blocks gives the size of the file in 512-byte
       blocks.  (This may be smaller than st_size/512  e.g.  when
       the file has holes.)  The value st_blksize gives the "pre-
       ferred" blocksize for efficient file system I/O.  (Writing
       to a file in smaller chunks may cause an inefficient read-
       modify-rewrite.)

       Not all of the Linux filesystems implement all of the time
       fields.   Some  file system types allow mounting in such a
       way that file accesses do  not  cause  an  update  of  the
       st_atime field. (See `noatime' in mount(8).)

       The  field  st_atime  is changed by file accesses, e.g. by
       exec(2), mknod(2), pipe(2), utime(2) and read(2) (of  more
       than zero bytes). Other routines, like mmap(2), may or may
       not update st_atime.

       The field st_mtime is changed by file modifications,  e.g.
       by  mknod(2),  truncate(2), utime(2) and write(2) (of more
       than zero bytes).  Moreover, st_mtime of  a  directory  is
       changed  by  the  creation  or  deletion  of files in that
       directory.  The st_mtime field is not changed for  changes
       in owner, group, hard link count, or mode.

       The  field  st_ctime  is  changed by writing or by setting
       inode information (i.e., owner, group, link  count,  mode,
       etc.).

       The  following  POSIX macros are defined to check the file
       type:

              S_ISREG(m)  is it a regular file?

              S_ISDIR(m)  directory?

              S_ISCHR(m)  character device?

              S_ISBLK(m)  block device?

              S_ISFIFO(m) fifo?

              S_ISLNK(m)  symbolic link? (Not in POSIX.1-1996.)

              S_ISSOCK(m) socket? (Not in POSIX.1-1996.)

       The following flags are defined for the st_mode field:

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit (see below)
       S_ISVTX    0001000   sticky bit (see below)

       S_IRWXU    00700     mask for file owner permissions
       S_IRUSR    00400     owner has read permission
       S_IWUSR    00200     owner has write permission
       S_IXUSR    00100     owner has execute permission
       S_IRWXG    00070     mask for group permissions
       S_IRGRP    00040     group has read permission
       S_IWGRP    00020     group has write permission
       S_IXGRP    00010     group has execute permission
       S_IRWXO    00007     mask for permissions for others (not in group)
       S_IROTH    00004     others have read permission
       S_IWOTH    00002     others have write permisson
       S_IXOTH    00001     others have execute permission

RETURN VALUE
       On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.


SEE ALSO
       chmod(2), chown(2), readlink(2), utime(2)
=============================================================================

6-2.3 File Type and Permissions:
    Among the fileds of the stat structure, only the st_mode field needs
    some explanation:

       mode_t        st_mode;     /* copied from i_mode of INODE */

    The TYPE of st_mode is unsigned short (2 bytes or 16 bits). 
    The 16 bits have the following meaning:

       |Type|   |permissions|
       ----------------------
       |tttt|fff|uuu|ggg|ooo| 
       ----------------------

    The leading 4 bits are file types, which can be interpreted as (Octals)

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo
 
    The next 3 bits are flags, which indicate special usage of the file 

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit 
       S_ISVTX    0001000   sticky bit 

    The remaining 9 bits are PERMISSION bits for file protection:

        owner  group  other
         rwx    rwx    rwx
    
    By interpreting these bits, YOU may disaplay the st_mode field as
       -rwxr-xr-x             (REG file) 
       drwxr-xr-x             (DIR)
       lrw-r--r--             (LNK file)

==============================================================================
6-3. HOW TO read DIR Entries:
   Read the man pages of   
            opendir, readdir, readlink  
to learn how to use these syscalls to open a DIR file for read, and then read 
the contents of a DIR file (as DIR entry strings). Alos, learn how to read the
contents of a (soft) LNK file itself.
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>type.h for Project</H1>

<Pre>

/*	type.h for CS360 Project             */

#include &lt stdio.h >
#include &lt fcntl.h>
#include &lt linux/ext2_fs.h>
#include &lt libgen.h>
#include &lt string.h>
#include &lt sys/stat.h>

// define shorter TYPES, save typing efforts
typedef struct ext2_group_desc  GD;
typedef struct ext2_super_block SUPER;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

#define BLOCK_SIZE        1024
#define BITS_PER_BLOCK    (8*BLOCK_SIZE)
#define INODES_PER_BLOCK  (BLOCK_SIZE/sizeof(INODE))

// Block number of EXT2 FS on FD
#define SUPERBLOCK        1
#define GDBLOCK           2
#define BBITMAP           3
#define IBITMAP           4
#define INODEBLOCK        5
#define ROOT_INODE        2

// Default dir and regulsr file modes
#define DIR_MODE          0040777 
#define FILE_MODE         0100644
#define SUPER_MAGIC       0xEF53
#define SUPER_USER        0

// Proc status
#define FREE              0
#define BUSY              1
#define KILLED            2

// Table sizes
#define NMINODES          50
#define NMOUNT            10
#define NPROC             10
#define NFD               10
#define NOFT              50

// Open File Table
typedef struct Oft{
  int   mode;
  int   refCount;
  struct Minode *inodeptr;
  long  offset;
} OFT;

// PROC structure
typedef struct Proc{
  int   uid;
  int   pid;
  int   gid;
  int   ppid;
  struct Proc *parent;
  int   status;

  struct Minode *cwd;
  OFT   *fd[NFD];
} PROC;
      
// In-memory inodes structure
typedef struct Minode{		
  INODE    INODE;               // disk inode
  ushort   dev;
  unsigned long ino;
  ushort   refCount;
  ushort   dirty;
  ushort   mounted;
  struct Mount *mountptr;
  char     name[128];           // name string of file
} MINODE;

// Mount Table structure
typedef struct Mount{
        int    ninodes;
        int    nblocks;
        int    dev, busy;   
        struct Minode *mounted_inode;
        char   name[256]; 
        char   mount_name[64];
} MOUNT;
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HOWTO #3</H1>

<Pre>
   The util.c file contains utility functions that are needed by most other  
   functions.  It is suggested that you implement the following.

1. get_block(dev, blk, buf) 
   put_block(dev, blk, buf)    These require no explanation.


2. token_path(char *pathname)
{
  This function breaks up a pathname, such as /a/b/c/d, into components
  a   b   c   d  and  determines the number of components n.
  The components will be used to search for the inode of pathname. 
}


3. dirname() and basename():
   Use these functions to divide a pathname into dirname and basename
   NOTE: They are in clib but both functions destroy the parameter string
  
4. unsigned long getino(int *dev, char *pathname)
{
  This is the most important function of the project. It converts
  a pathname, such as /a/b/c/d OR x/y/z, into its (dev, inumber), i.e. 
  the returned value is its inumber and dev is its dev number. 

  NOTE: while traversing a pathname, the starting dev number is the dev of / 
  OR the dev of (running's) CWD. If you have only one device, the dev number 
  will not change. But when crossing MOUNTed file systems (for Level-3), the
  dev number may change. The dev parameter is used to keep the CURRENT dev 
  number.

  This function depends on search(), which searches an DIR's data block for 
  a component name, and returns the component's inmuber. Modify *dev if the
  dev number changes.
  
  You have already done these in showblock.c
}   

5. unsigned long search(MINODE *mip, char *name)
{
   This function searches the data blocks of a DIR inode (inside an Minode[])
   for name. You may assume DIRECT data blocks only.
}


6. MINODE *iget(int dev, unsigned long ino)
{
  Once you have the (dev, ino) of an inode, you may load the inode into a slot
  in the Minode[] array. To ensure uniqueness, you must search the Minode[] 
  array to see whether the needed INODE is already loaded.

  If you find the needed INODE already in a Minode[] slot, just inc its 
  refCount by 1 and return the Minode[] pointer.

  If you do not find it in memory, you must allocate a FREE Minode[i], load
  the INODE from disk into that Minode[i].INODE, initialize the Minode[]'s
  other fields and return its address as a MINODE pointer,
}


7. iput(MINODE *mip)
{
  This function releases a Minode[]. Since an Minode[]'s refCount indicates
  the number of users on this Minode[], releasing is done as follows:
    First, dec the refCount by 1. If (after dec) refCount > 0 ==> return;
    else:
      if Minode[].dirty == 0 ==> no need to write back, so return;
      Otherwise, (dirty==1) ==> must write the INODE back to disk.
   
  To write an INODE back to disk:
     Use Minode's (dev, ino) to determine which dev and which INODE on disk,
  i.e. which disk block and which inode in that block.
  Read that block in, copy Minode's INODE into the INODE area in that block
  and write the block back to disk.
} 


8. int findmyname(MINODE *parent, unsigned long myino, char *myname) 
{
   Given the parent DIR (MINODE pointer) and my inumber, this function finds 
   the name string of myino in the parent's data block. This is similar to 
   SERACH() mentioned above.
}


9. int findino(MINODE *mip; unsigned long *myino, *parentino)
{
  For a DIR Minode, extract the inumbers of . and .. 
  Read in 0th data block. The inumbers are in the first two dir entries.
}
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                     HOWTO write    

int write_file()
{
  1. Preprations:
     ask for a fd   and   a text string to write.

  2. verify fd is indeed opened for W or RW or APPEND mode

  3. copy the text string into a buf[] and get its length as nbytes.

     return(mywrite(fd, buf, nbytes));
}



// mywrite behaves exactly the same as Unix's write(fd, buf, nbytes) syscall.
// it writes nbytes from buf[] to the file fd

int mywrite(int fd, char *buf, int nbytes) 
{
  while (nbytes > 0 ){

     compute LOGICAL BLOCK (lbk) and the startByte in that lbk:
          lbk       = oftp->offset / BLOCK_SIZE;
          startByte = oftp->offset % BLOCK_SIZE;

    // I only show how to write DIRECT data blocks, you figure out how to 
    // write indirect and double-indirect blocks.

     if (lbk < 12){                         // direct block
        if (ip->INODE.i_block[lbk] == 0)    // if no data block yet
            mip->INODE.i_block[lbk] = balloc(mip->dev);
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12){ 
            // indirect blocks
     }
     else{
            // double indirect blocks */
     }

     /* all cases come to here : write to the data block */
     get_block(mip->dev, blk, wbuf);   // read disk block into wbuf[ ]  
     char *cp = wbuf + startByte;      // cp points at startByte in wbuf[]
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in this block

     while (remain > 0){               // write as much as remain allows  
           *cp++ = *cq++;              // cq points at buf[ ]
           nbytes--; remain--;         // dec counts
           oftp->offset++;             // advance offset
           if (offset > i_size)        // especially for RW|APPEND mode
               mip->INODE.i_size++;    // inc file size (if offset>filesize)
           if (nbytes <= 0) break;     // if already nbytes, break
     }
     put_block(mip->dev, blk, wbuf);   // write wbuf[ ] to disk
     
     // loop back to while to write more .... until nbytes are written
  }

  mip->dirty = 1;       // mark mip dirty for iput() 
  show ("wrote %d char into file fd=%d\n", nbytes, fd);           
  return nbytes;
}
<TITLE>CS360 NOTES</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 NOTES</H1>
<Pre>
                   360 NOTES on TCP/IP

1. IP stands for Internet Protocol. TCP (Transmission Control Protocol) is a 
   protocol built on top of IP. TCP/IP is the backbone of InterNet. Currently 
   there are 2 versions of IP, known as IPv4 and IPv6. IPv4 uses 32-bit address
   and IPv6 uses 128-bit address. The discussion here is based on IPv4, which 
   is still the predominat version IP in use.

2. Host and IP address:
   A host is a machine that runs IP. Every host is identified by a unique 
   32-bit number called the IP address. For human convenience, this 32-bit 
   number is usually expressed in a "dotted" notation, such as 134.121.64.1  
   A host is also known by a host name, e.g. dns1.eecs.wsu.edu. Host name and 
   IP address are "equivalent" in the sense that, given one, we can find the 
   other (by a Domain-Name-Server, DNS). 

   An IP address is divided into two parts: | networkID | hostID |.
   Depending on networkID, IP addresses are classified as

                                             Decimal Notation:
   Class A : |0xxxxxxx|    24 bits          |    1-126
             | netID  |    host ID          |

   Class B : |10| 14 bits   |   16 bits     |    128-191  
             |   NetID      |   HostID      |
   
   Class C : |110 21 bits            |8 bits|    192-223
             |       netID           |host  |
   ------------------------------------------------------- 
   Class D : |1110x|  multicast group ID    |
   Class E : |11110|  reserved              |

   Data packets intended for an IP address are first sent to a "Router" with 
   the same NetworkID.  That router will forward the packets to a specific
   host by using the HostID.

3. What is IP ?  
   IP is a protocol for sending/receiving data packets between hosts. IP 
   operates in a best-effort manner, i.e. it just sends the packets out, but 
   does NOT guarantee that they will be delivered to their destinations, NOR 
   in order. So, IP may be unreliable. 

4. IP Packet Format:
   An IP packet consists of

      | Header |SourceIP|DestIP|<-----  DATA ---->|
         12       4        4   | upto 64K-24 bytes|
        
   The Header part contains more information, e.g. total length, TCP/UDP, TTL, 
   check-sum for error detection, etc. about the packet so that a receiving
   host would know what to do with the packet. For example, an IP packet is
   simply dropped if its check-sum indicates an error or its TTL has expired.

5. Routers:
   IP hosts may be located far apart. It is usually not possible to send data 
   packets from one host to the other DIRECTLY. "Routers" are special IP hosts 
   that receive and forward packets. Therefore, IP packets may go through 
   many routers, or "hops",  before arriving at a destination. 


6. UDP (User DataGram Protocol)
   UDP operates on top of IP. It is used to send/receive "datagrams". Like
   IP, UDP doe NOT guarantee reliability but it is fast and efficient. It is 
   used in situations where reliablility is not essential.
   Example:

      ping mail.wsu.edu     OR    ping 134.121.1.8
   
   ping is a program that sends a UDP packet to a host, which "echo" the UDP 
   packet back to the sender with a round-trip time.
      
7. TCP (Transmission Control Protocol)
   TCP also operates on top of IP but guarantees reliable data transfer. It is
   a connection-oriented protocol for sending/receiving "data streams". 

   A common analogy is that UDP is similar to "telegram" (or USPS), and TCP is
   similar to "telephone".

8. Port Number:
   At each IP host, many applications may be using UDP/TCP at the same time. 
   Each application is uniquely identified by a triple
        Application = (HostIP, Protocol, PortNumber)
   where Protocol is either UDP or TCP, and PortNumber is a unique 2-byte 
   unsiged integer assigned to the application. In order to use UDP or TCP at 
   a host, an application (process) must choose or obtain a PortNumber first. 
   The first 1024 port numbers (0 to 1023) are reserved.  

9. Network and Host (byte) Order:
   Machines may use either "big-endian" or "little-endian" byte-ordering. On 
   the "Internet", data are always in "network order", which is "big-endian".

   A set of library functions htons()/htonl(), ntohs()/ntohl() are used to 
   convert data between host-order and network-order. 

10. Server-Client Model:
    In network programming, we typically run a Server at a host first. The 
    Server waits for Client requests and serves the requests. In UDP, the 
    Server simply waits for "datagrams" from a Client. In TCP, the Server 
    waits for a Client to "connect".

    Then, we run the Client from a client host, In UDP, the client simply sends
    each request as a UDP datagram to the Server. Then it receives a reply 
    datagram from the Server. In TCP, the Client requests to connect to the 
    Server first. Then the Server and Client can exchange "continuous" streams
    of data.

In the following, we shall show how to do network programming using TCP.

11. Network Programming:
    Unix (Linux) Kernel provides TCP/IP support. User interface to TCP/IP is
    through "sockets". To the user (program), creating a socket is similar to 
    opening a file for RW. It returns a file descriptor so that the same 
    read()/write() system calls can be used to transfer data.   

12. Sockets Programming

    First, we need the following C structs defined in netdb.h and sys/socket.h

12-1.The socket address data structure:

    struct sockaddr_in {
       u_short        sin_family; /* protocol identifier; usually AF_INET */
       u_short        sin_port;   /* port number. 0 means let kernel choose */
       struct in_addr sin_addr;   /* IP address. INADDR_ANY=the current host.*/
       char           sin_zero[8];}; /* Unused, always zero */
    }

    struct in_addr {
        u_long s_addr;
    };

12-2. The hostent struct in &lt;netdb.h&gt; is as shown (man gethostbyname):
        
        struct hostent {
               char    *h_name;        // DOT name string of host
               char    **h_aliases;    // alias list 
               int     h_addrtype;     // host address type
               int     h_length;       // length of address
               char    **h_addr_list;  // list of addresses (long IP address)
        }
        #define h_addr  h_addr_list[0]  // for backward compatibility 

        // NOTE: h_addr is defined as a char * but it points at the IP_address,
        //       which is a 4-byte number in network (big-endian) order.
        // ulong NIP = *(ulong *)h_addr is the IP_address in network order.
        // ulong HIP = ntohl(NIP) is NIP in host order (INTEL=little-endian).
        // inet_ntoa(NIP) converts NIP to a string in DOT notation.

13. An ECHO Server/Client Program using TCP

    Shown below are the C source files of an ECHO server and a client.
    These files are also available in ~samples/LAB4/. 

    First, run the server at a host as        server [hostname]
    where hostname is either the DNS name or IP address of the host machine. 
    If no hostname is given, the default "localhost" (127.0.0.1) will be used.

    The Server first displays the server's hostname, IP address and port number
    Then it waits for a client to connect.

    Next, run the client at another host as   client ServerName ServerPort

    (You may also run both on the SAME host but in separate X-windows).

    After connecting to the server, the client asks the user for an input 
    string, sends it to the server, which simply echos the string back.

    When the client ends (by Enter or Control-C), the server loops back
    to accept another connection, etc.

    The sequence of actions between the server and the client are shown
    in the following diagram.

                                ACTIONS OF 
            Server                                       Client:
   --------------------------------      ---------------------------------
1. Display hostname, IP, Port#      ===> 1. MUST know Server's name|IP,Port#
2. Construct a server_addr struct        2. Construct a server_addr struct 
3. Create a TCP socket with Port#        3. Create a TCP socket sock
4. Bind socket to server_addr info             
5. Listen at socket by listen() syscall
6. newsock = accept()               <==  4. connect() to Server via sock
   ------------------------------------------------------------------------
                           Send/Receive Data
7. READ from newsock      <------------------  WRITE to  sock
   WRITE to  newsock      ------------------>  READ from sock
   ------------------------------------------------------------------------
8. loop to 6 to accept next client             close(sock);

//**************************************************************************
//           This Server-Client package uses TCP sockets.
//              This is the ECHO SERVER server.c file. 
//**************************************************************************

#define  MAX 256

#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;

// Define variables:
struct sockaddr_in  server_addr, client_addr, name_addr;
struct hostent *hp;

int  sock, newsock;                  // socket descriptors
int  serverPort;                     // server port number
int  r, length, n;                   // help variables

// Server initialization code:

int server_init(char *name)
{
   printf("==================== server init ======================\n");   
   // get DOT name and IP address of this host

   printf("1 : get and show server host info\n");
   hp = gethostbyname(name);
   if (hp == 0){
      printf("unknown host\n");
      exit(1);
   }
   printf("    hostname=%s  IP=%s\n",
               hp->h_name,  inet_ntoa(*(long *)hp->h_addr));
  
   //  create a TCP socket by socket() syscall
   printf("2 : create a socket\n");
   sock = socket(AF_INET, SOCK_STREAM, 0);
   if (sock < 0){
      printf("socket call failed\n");
      exit(2);
   }

   printf("3 : fill server_addr with host IP and PORT# info\n");
   // initialize the server_addr structure
   server_addr.sin_family = AF_INET;                  // for TCP/IP
   server_addr.sin_addr.s_addr = htonl(INADDR_ANY);   // THIS HOST IP address  
   server_addr.sin_port = 0;   // let kernel assign port

   printf("4 : bind socket to host info\n");
   // bind syscall: bind the socket to server_addr info
   r = bind(sock,(struct sockaddr *)&server_addr, sizeof(server_addr));
   if (r < 0){
       printf("bind failed\n");
       exit(3);
   }

   printf("5 : find out Kernel assigned PORT# and show it\n");
   // find out socket port number (assigned by kernel)
   length = sizeof(name_addr);
   r = getsockname(sock, (struct sockaddr *)&name_addr, &length);
   if (r < 0){
      printf("get socketname error\n");
      exit(4);
   }

   // show port number
   serverPort = ntohs(name_addr.sin_port);   // convert to host ushort
   printf("    Port=%d\n", serverPort);

   // listen at port with a max. queue of 5 (waiting clients) 
   printf("6 : server listening ....\n");
   listen(sock, 5);
   printf("===================== init done =======================\n");
}

main(int argc, char *argv[])
{
   char *hostname, line[MAX];

   if (argc < 2)
      hostname = "localhost";
   else
      hostname = argv[1];
 
   server_init(hostname); 

   // Try to accept a client request
   while(1){
     printf("server: accepting new connection ....\n"); 

     // Try to accept a client connection as descriptor newsock
     length = sizeof(client_addr);
     newsock = accept(sock, (struct sockaddr *)&client_addr, &length);
     if (newsock < 0){
        printf("server: accept error\n");
        exit(1);
     }
     printf("server: accepted a client connection from\n");
     printf("-----------------------------------------------\n");
     printf("        IP=%s  port=%d\n", inet_ntoa(client_addr.sin_addr.s_addr),
                                        ntohs(client_addr.sin_port));
     printf("-----------------------------------------------\n");

     // Processing loop
     while(1){
       n = read(newsock, line, MAX);
       if (n==0){
           printf("server: client died, server loops\n");
           close(newsock);
           break;
      }
      
      // show the line string
      printf("server: read  n=%d bytes; line=[%s]\n", n, line);

      strcat(line, " ECHO"); // ASSUME line[MAX] still has room for " ECHO"

      // send the echo line to client 
      n = write(newsock, line, MAX);

      printf("server: wrote n=%d bytes; ECHO=[%s]\n", n, line);
      printf("server: ready for next request\n");
    }
 }
}


//*********************** ECHO CLIENT client.c file *************************

#define MAX 256

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;


// Define variables
struct hostent *hp;              
struct sockaddr_in  server_addr; 

int sock, r;
int SERVER_IP, SERVER_PORT; 

int client_init(char *argv[])
{
  printf("======= clinet init ==========\n");

  printf("1 : get server info\n");
  hp = gethostbyname(argv[1]);
  if (hp==0){
     printf("unknown host %s\n", argv[1]);
     exit(1);
  }

  SERVER_IP   = *(long *)hp->h_addr;
  SERVER_PORT = atoi(argv[2]);

  printf("2 : create a TCP socket\n");
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock<0){
     printf("socket call failed\n");
     exit(2);
  }

  printf("3 : fill server_addr with server's IP and PORT#\n");
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = SERVER_IP;
  server_addr.sin_port = htons(SERVER_PORT);

  // Connect to server
  printf("4 : connecting to server ....\n");
  r = connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
  if (r < 0){
     printf("connect failed\n");
     exit(1);
  }

  printf("5 : connected OK to \007\n"); 
  printf("---------------------------------------------------------\n");
  printf("hostname=%s  IP=%s  PORT=%d\n", 
          hp->h_name, inet_ntoa(SERVER_IP), SERVER_PORT);
  printf("---------------------------------------------------------\n");

  printf("========= init done ==========\n");
}


main(int argc, char *argv[ ])
{
  int n;
  char line[MAX], ans[MAX];

  if (argc < 3){
     printf("Usage : client ServerName SeverPort\n");
     exit(1);
  }

  client_init(argv);

  printf("********  processing loop  *********\n");
  while (1){
    printf("input a line : ");
    bzero(line, MAX);                // zero out line[ ]
    fgets(line, MAX, stdin);         // get a line (END with \n) from stdin 
    line[strlen(line)-1] = 0;        // kill \n at end
    if (line[0]==0)                  // exit if NULL line
       exit(0);

   // Send ENTIRE line to server
    n = write(sock, line, MAX);
    printf("client: wrote n=%d bytes; line=(%s)\n", n, line);

    // Read a line from sock and show it
    n = read(sock, ans, MAX);
    printf("client: read  n=%d bytes; echo=(%s)\n",n, ans);
  }
}



13-1. Run the above Server/Client programs. 
      The source files of server.c/clinet.c are in ~samples/LAB4/ directory.
      Download them, cc and run.

      Modify them to do computations, e.g. client sends 2 numbers to server, 
      which returns the SUM.

13-2. 
The above Server/Client code may be used as the basis for TCP-orineted network
programming. You may adapt it for different applications by simply changing the
data contents and the ways they process the data.

                    Example:
============================================================================== 
Instead of numbers, the Client may send a "command" string, such as

           pwd  
           ls  [pathname]
           cd  [pathname]
           get filename  
           put filename
           
The Server executes the command and sends results back to the Client. 

Simlarly, you may implement mkdir, rmdir, creat, rm operations at the Server. 
==============================================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab Assignment #2 </H1>

<Pre>

Given the C program:

main(int argc, char *argv[], char *env[])
{
  int a,b,c;
  printf("enter main\n");
  a=1; b=2; c=3;

     //****** DO (1): Write C code here to print the ************* 
     (1). argv[] strings
     (2).  env[] strings

  A(a,b);
  printf("exit main\n");
}

int A(int x, int y)
{
  int d,e,f;
  printf("enter A\n");
  d=3; e=4; f=5;
  B(d,e);
  printf("exit A\n");
}

int B(int x, int y)
{
  int g,h,i;
  printf("enter B\n");
  g=6; h=7; i=8;
  C(g,h);
  printf("exit B\n");
}

int C(int x, int y)
{
  int p,q,r;
  printf("enter C\n");
  p=9; q=10; r=11;

    / Write C and assembly code to 
    ********* DO (2)-(4) AS SPECIFIED BELOW *************/

  printf("exit C\n");
}
=============================================================================

(1). Call an assembly function
             getfp:   
                     pushl %ebp
                     movl  %esp, %ebp
                     ...............
     which returns the current frame pointer fp=%ebp. As shown by the diagram,
     fp is the head pointer of a link list of the stack frames, which ends 
     with a 0.

       HIHG                                                  LOW
        ---------------------------------------------------------
          0        fp0       fpM       fpA        fpB     fpC
        ---------------------------------------------------------  
          ^         ^         ^         ^          ^       ^ 
         fp0       fpM       fpA       fpB        fpC      fp

(2). Print in HEX the stack contents from fp to fp0 in the form

              Address      Contents
             ---------    ----------

             ---------    ---------- 

(3). On a hard copy of the outputs, IDENTIFY and EXPLAIN the stack contents 
     in terms of the function stack frames, i.e. local variables, parameters, 
     return address, etc. 


4: Long Jump:
   In the above calling sequence, it is possible to return from C() directly 
   to, say main(), by a long jump, as shown below:

4-1: First, define global variables

       int mainFP, mainPC;  /* for saving main()'s FP and PC */

       main()
       { 
           int r;

4-2: /**** Save long jump return point ****/
         if ( r = setjump() )

             /*********************************************
              Implement setjump() in such a way that it
              saves main's FP into mainFP, setjump()'s return
              PC into mainPC, and returns to here with a 0;
             **********************************************/    
         { 
             printf("back via long jump: r=%d\n",r);
             exit(1);
         }
4-3: /***** Normal call out ******/
         /* call A() -> B() -> C() as before */
         printf("noraml return\n");
       }


4-4:  In one of the called functions, e.g. C():

       int C()
       { .......................;

         printf("long jump back to main? {y|n) ");
        
         /**************************************
           If the answer is 'y' call the function
                 longjump(100);  
           which returns to main() via the saved 
           globals (mainFP, mainPC), and return a 
           nonzero value, e.g. 100.
          **************************************/
       }

           
-------------------  DO #3  ---------------------------
3-5: Implement the functions IN ASSEMBLY:
         int setjump();
         int longjump(int returnValue);
     and DEMO your long jump in LAB.

NOTE: YOU MUST IMPLEMENT these in ASSEMBLY !!!!
=======================================================
<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Lab #2 Pre-Work</H1>

<Pre>
            DUE : in Lab 

1. A binary executable file, a.out, consists of

           |header| TEXT | DATA |<== BSS ===>|

The Unix command    size a.out   shows the size of TEXT, DATA, BSS of a.out.

Use the following C program, t1.c, to generate t2.c, t3.c,.. t6.c as specified
below. 
        //********** t1.c file ************
          int g;                              
          main()                              
          {                                   
             int a,b,c; 
             a = 1; b = 2; 
             c = a + b;
             printf("c=%d\n", c);
          }                                

t2.c: Change the global variable  g  to  int g=3;
t3.c  Change the global variable  g  to  int g[10000];
t4.c  Change the global variable  g  to  int g[10000] = {4);
t5.c  Change the local variables of main() to
                 int a,b,c, d[10000];
t6.c. Change the local variables of main() to
                 int a,b,c, d[10000]={5];
t7.c  Change the local variables of main() to
                 static int a,b,c, d[10000];
t8.c  Change the local variables of main() to
                 static int a,b,c, d[10000]={6};
           
(A). For each case, use cc to generate a.out. Then use  ls -l a.out to get 
     a.out size, and run size a.out to get its section sizes. Record the
     observed sizes in a table:

          Case  | a.out |  TEXT  |  DATA  |  BSS   |
        --------------------------------------------
          (1)   |       |        |        |        |
        --------------------------------------------  
          (2)
        --------------------------------------------
          (3)
        --------------------------------------------
          (4)
        --------------------------------------------
          (5)
        --------------------------------------------        
          (6)
        --------------------------------------------
          (7)
        --------------------------------------------        
          (8)
        --------------------------------------------

                  ANSWER THESE QUESTIONS:

   1. Variables in C may be classified as

          globals ---|--- UNINITIALIZED  globals;
                     |---   INITIALIZED  globals;

          locals  ---|--- AUTOMATIC locals;
                     |--- STATIC    locals;
          

   In terms of the above classifications and the variables g, a, b, c, d,

      Which variables are in DATA? ______________________________________
      Which variables are in BSS ? ______________________________________

   2. In terms of the TEXT, DATA and BSS sections,
      Which sections are in a.out, which section is NOT in a.out?
      WHY?______________________________________________________

  (B). For each case, use   cc -static t.c   to generate a.out.
       Record the sizes again and compare them with the sizes in (A).
       WHAT DO YOU SEE?_________________________________________________

       WHY?______________________________________________________________


2. Given the C function, test.c:
     int g;
     int sub(int x, int y)
     {
        int a, b;
        g = 1;
        x = 2; y = 3;
        a = 4; b = 5;
        return 6;
     }

Use cc -S test.c to generate test.s   Examine the test.s file

ABSWER these questions: WHAT ARE THE addresses OF
(1). g?______________________________________________________
(2). parameters x, y ________________________________________
(3). locals a, b     ________________________________________
(3). Which CPU register contains the return value?___________       
<html>
<Body bgcolor="#00cccc" text="#000000">
<pre>

     CS360 Lab Assignment #4 : File Operations across Networks
               
                   WORK IN 2-person teams
                  DUE & DENO : to be posted


A. OBJECTIVE:
   Network Programming using TCP.
   Unix system calls for file operations.

B. PRE Lab (Do these on your own).:
   Donwload the server.c and client.c files from samples/LAB4/ direcotry.
   cc and run the server and client programs.

   Modify the programs to do the following:
      Client: input 2 numbers, send them to server and get the answer.
      Server: Add the two numbers and send the result back to client.

C. REQUIREMENTS:
   Modify the server/client programs in samples/LAB4/ to do the following:

     Client : input a command:
              ----------------  
              pwd
              ls   [pathname]
              cd    pathname
              mkdir pathname
              rmdir pathname       
              rm    pathname       (rm pathname file)
              get   pathname       (cp pathname file to client side)
              put   pathname       (cp pathanme file to server side)
              quit                 (Client exits)
           -----------------
           send command to Server.
           receive reply (results) from Server.

     Also,implement the (local) commands
         lpwd, lls, lcd, lmkdir. lrmdir, lrm
     which the Client executes LOCALLY.

     Server:
             get a command from Client;
             perform the command;
             send reply to Client;

C. HELP Hints:

   Make each command a fixed-length string, e.g. of LEN=128 bytes.
   REASON: a TCP socket contains a "stream" of data. Each read operation
           reads whatever is available in the socket. Using fixed-length 
           items simplifies reading inidvidual command strings.

D. Sample Solutions
   in samples/LAB4/ : lab4.server  and lab4.client

<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H2>360 LAB Pre-Work #6</H2>
<Pre>
                   CS 360 LAB #5 Pre_work
          PART 1 only:   DUE Wed Oct 15, in LAB 
===============================================================================

1. Given: kcmkfs.c file in samples/LAB5

   Write YOUR own C code for 

         get_block(int dev, char *buf, int blk);
         put_block(int dev, char *buf, int blk);

   where dev is an opened file descriptor of a "DEVICE", such as a FD. 

         set_bit(char buf[], int bit);
         clr_bit(char buf[], int bit):
         
         make_bmap();
         make_imap();

   to make the program kcmkfs.c complete. DEMO YOUR WORK on Wednesday,3-19


2. ASSUME: mkfs /dev/fd0 1440  OR  kcmkfs /dev/fd0 1440 184   
   Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode info
6. dir.c    : dir_entries of the root directory.
-------------------------------------------------------------------------


//Sample dir.c code

<PRE>

#include &lt;fcntl.h&gt;
#include &lt;linux/ext2_fs.h&gt;

// define shorter TYPES
typedef struct ext2_group_desc    GD;
typedef struct ext2_super_block   SUPER;
typedef struct ext2_inode         INODE;
typedef struct ext2_dir_entry_2   DIR;  

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 


char buf[1024], rbuf[1024];
int fd, blk, i;

int get_block(int blk, char *buf)
{
  // read disk blk into buf[ ]
}

main()
{
  char *cp, temp[256];

  fd=open("/dev/fd0", O_RDONLY);

  get_block(5, buf);      // get root inode block
  ip = (INODE *)buf + 1;  // it's inode #2

  for (i=0; i<12; i++){   // ASSUME dir has only direct blocks
    blk = ip->i_block[i];
    printf("i_block[%d] = %d\n", i, blk);  // print blk number
    if (blk==0)
       break;

    get_block(blk, rbuf); // get block contents into rbuf[] 
    
    dp = (DIR *)rbuf;     // as DIR entries
    cp = rbuf;            
 
   while(cp &lt; &rbuf[1024]){
      bzero(temp, 256);
      strncpy(temp, dp->name, dp->name_len);

      // print DIR entry info
      printf("%4d %4d %4d  %s\n", dp->inode, dp->rec_len, dp->name_len, temp);
      // In addition to printing, CAN YOU SEARCH FOR A name STRING? 
      // OR SEARCH FOR A INOODE NUMBER?
      
      cp += dp->rec_len;
      dp = (DIR *)cp;
   }
  }
}







<html>
<Body bgcolor="#00cccc" text="#000000">
<H1>CS360 Lab Assignment #3 : sh Simulator</H1>
<pre>

                DUE & DENO : To be posted

A. OBJECTIVE:
   Understand how Unix sh works by using fork/wait/exec.
   String operations

B. REQUIREMENTS:
   Write a C program, mysh, which simulates the Unix sh for command processing.
   Your mysh should run as follows:

1. Prompt for an input line, which is of the form
          cmd arg1 arg2 arg3 .... argn
   where cmd is a command.

   For simplicity, do NOT consider sh scripts files.
   Valid commands include only "echo", "cd", "exit", and ANY Unix binary 
   executables, e.g. ls, date, pwd, cat, cp, mv, cc ... you name it !!!


2. Handle simple commands:
     cmd = "cd"   :  chdir(arg1) OR chdir($HOME) if no arg1;
     cmd = "echo" :  echo the remaining line;
     cmd = "exit" :  exit(1) to terminate;  

   NOTE: chdir(pathname) is a syscall to change CWD.
         $HOME is the home directory; YOU must find its value from *env[ ].

3. For all other commands:
      fork a child process;
      wait for the child to terminate;
      print child's exit status code
      continue step 1;

4. Child process:
   4-1. Handle I/O redirection:
          cmd  arg1 arg2 ...  <  infile    // take inputs from infile
          cmd  arg1 arg2 ...  >  outfile   // send outputs to outfile
          cmd  arg1 arg2 ...  >> outfile   // APPEND outputs to outfile
        For simplicity, assume at most ONE I/O redirection per line.

   4-2. Execute cmd by execve(), passing parameters 
                char *myargv[], char *env[]
        to the cmd file, 
        where myargv[0]->cmd, myargv[1]->arg1, ....., ending with NULL pointer

        NOTE: if cmd begins with /, execute it directly.
              otherwise, try to execute pathdir/cmd for every pathdir in $PATH


5. SAMPLE SOLUTION:
   
   ~samples/LAB3/lab3.bin          (down load and run under Linux)

===========================  I/O Redirections ===============================

6. I/O Redirections:

6-1. Stream FILEs and File Descriptors:
   Recall that the sh process has 3 stream FILEs: stdin, stdout, stderr.
   When sh forks a child, the child process also has the same FILE streams.
   Each of the FILE streams corresponds to an opened file in the Unix kernel.
   Each opened file has a unique file descriptor (number). The file descriptors
   of stdin, stdout, stderr are 0,1,2, respectively.

6-2. Stream I/O and System Call:
   When a process executes        scanf("formatString", &item);
   it tries to input an item from stdin, which points to a FILE struct.If the
   FILE struct's buffer is empty, it issues a system call to the Unix kernel,
   to READ data from the file descriptor 0, which is mapped to the terminal
   (/dev/ttyX) of the sh process.

                      REDIRECT INPUT: 
   If we let stdin point to the FILE struct of a diffferent file that's 
   opened for input, then every scanf() would read inputs from the new file.
   So, if we do
              fclose(stdin);
   which erases the FILE struct pointed by stdin, casuing stdin to be NULL, 
   followed by
              stdin = fopen("filename", "r");
   which fopens filename for READ and let stdin point at the new FILE struct,
   then scanf() would get inputs from the file filename.
   
   The FILE struct of stdin contains a file descriptor 0. If we replace the 
   file descriptor 0 with a newly opened file, we would achieve the same 
   effect. Thus, if we do 
           close(0);    // system call to close file descriptor 0
           open("filename", O_RDONLY);  // open filename for READ, which
                                        // will replace fd 0
   Then, every scanf() call will get inputs from the opened file.


   Similarly, when a process executes      printf("formatString", item);
   it tries to write to stdout, which points to a FILE struct. If the FILE
   struct's buffer is full, it issues system call to the Unix kernel to
   write data to file descriptor 1, which is mapped to the terminal screen.

                       REDIRECT OUTPUT: 
   If we 
          fclose(stdout);
   which erase the FILE struct of stdout, followed by
          stdout = fopen("filenmae", "w");
   which opens filename for WRITE and let stdout point to the FILE struct,
   then printf() would send outputs to filename. More directly, we may keep
   stdout and its FILE struct but let file descriptor 1 point at a different
   file. Thus, if we
          close(1);
          open("filename", O_WRONLY|O_CREAT, 0644); 
   which change file descriptor 1 to point to a file, then the outputs will 
   go to that file instead of the screen. 
  
   When a process dies (in Kernel), it cloes all opened files, (causing
   data to be written out to disk ..

6-3 Use man open to read more on how to issue syscalls 
        open(), read(), write(), close(), 
    and (I/O library functions)
       fopen(), fclose()
              









<Title>460 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 Notes #5</H1>
<Pre>
         360 Notes on Process Management in Unix

1. Read Unix man pages on
        fork, exec, wait, exit,  
        kill, signal,  

2. Process:
   A process is a sequence of executions regarded as a single entity by the 
   Unix kernel. Each process has a unique pid and a ppid, which identify the
   process and its parent process, respectively. Processes in Unix form a 
   family tree. They compete for CPU time to run. 

3. Process Origin:
   How does a process begin? As explained before, when Unix starts, it creates
   a process P0 by brutle force. P0 creates (by fork) a child process P1, which 
   is the INIT process. P1 forks many children processes, one on each terminal 
   as the LOGIN process on that terminal. Each LOGIN process opens 3 stream FILEs, 
   stdin, stdout, stderr. It displays login: to its stdout and waits for a user to 
   login. After a user login, the LOGIN process becomes the user process. Typically, 
   the user process execute sh, so it's known as the sh process. 
   When sh sees an a.out command, it forks a child process to execute a.out. The sh 
   process "waits" until the child process dies. Then it prompts for another command.  

4. Process Image:
   In Unix, a process executes in two different modes; Kernel mode or User 
   mode, denoted by Kmode or Umode, for short. In each mode, a process has
   an "execution image", as shown by the following figure.

                  Images of Process i:
       ------------------------------------------ 
       Kmode :    Kcode_i  Kdata_i   Kstack_i
       ==========================================
       Umode :    Ucode_i  Udata_i   Ustack_i
       ------------------------------------------
   The index i indicates these are the images of process i. In general, the 
   Umode images of different processes are all different. While in Kmode they 
   share the same Kcode and Kdata, which are those of the Unix Kernel. However,
   Each process still has its own Kstack.
    
   A process migrates between Kmode and Umode many many times during its life
   time.

   Every process comes into existence and begins execution in Kmode. In fact,
   it does everything of interest, including to die (or terminate), in Kmode. 
   While in Kmode, it can come to Umode easily (by changing CPU's status from 
   K to U mode) However, once in Umode it cannot change CPU's status  
   arbitrarily. A Umode process can enter Kmode in only one of 3 ways:

   (1). Interrupts : Interrupts are hardware signals to the CPU. When an
                     interrupt occurs, CPU will enter Kmode to handle the 
                     interrupt, which causes the process to enter Kmode. 
   (2). Traps: Traps are error conditions, such as invalid address, illegal 
               instruction, divide by 0, etc. recognized by the CPU, causing it
               to enter Kmode to deal with the error. Since traps are caused by
               the executing process on the CPU, the process typically dies
               (with a dreadful message such as "Segmentation Fault").

   (3). System Calls:
        System call (or syscall for short) is a mechanism that allows a process
        to enter Kmode to execute Kernel functions. When the Kernel function 
        finishes, it comes back to Umode with a return value, which is normally
        0 for success or -1 for error. In case of error, the global int 
        variable errno (in errno.h) contains an ERROR code which further 
        identifies the error.

        In the following, we shall discuss these syscalls:
           fork(), wait(), exec(), exit(), chdir(), open(), close() 

5. Process Management in Unix:

5-1. fork():  Usage:   int pid = fork();
     fork() creates a child process and returns the child's pid or -1 if error.
     The following diagram shows the actions of fork().


               PROCi                      |      PROCj
              --------                    |      -------
    Kmode :    Kcodei   kfork(){....}     |                    ( When Pj runs:)
               Kdatai        ^       |    |                          |
               kstacki       |       |    |      Kstackj             V
   ========================  |  ==== | ===========================   | =======
    Umode :    Ucodei  pid=fork(); <-     |      Ucodej  pid=fork();<-
               Udatai                     |      Udataj
               Ustacki                    |      Ustackj


   (1). The left hand side shows the images of a process Pi, which issues
        the syscall   pid=fork();    
   (2). Pi goes to Kmode to execute the corresponding kfork() function, in 
        which it creates a child process PROCj with Kstackj and Umode image of
        Pj, as shown in the right hand side of the diagram.
 
        The Umode image of Pj is an IDENTICAL copy of Pi's Umode image.

        Thus, Pj's Ucodej also has the statement
                   pid=fork();

   (3). After creating Pj, Pi returns to the statement  
              pid = fork();
        in Ucodei with the child's pid = j.

   (4). When Pj begins to run, it exits Kmode and returns to the same statement
              pid = fork();
        with a 0 value in ITS OWN Umode image. 

   Example 1: Consider the C program:

        main()
        {
           int pid;
           printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid()); 

           pid = fork();   // fork syscall; parent returns child pid, 
                           //               child returns 0

           if (pid < 0){   // fork() may fail. e.g. no more PROC in Kernel
               perror("fork faild");
               exit(1);
           }
           
           if (pid){ // PARENT EXECUTES THIS PART 
                  printf("THIS IS %d  MY PARENT=%d\n", getpid(), getppid());
           } 
           else{ // child executes this part
                  printf("I am    %d  my parent=%d\n", getpid(), getppid());
           }
        }


5-2. pid = wait(int *howDidChildDie);

     wait() returns a dead child's pid and its exit code=[exit#|sig#]
            As usual, it returns -1 if error, e.g. caller has no child.

     Note:  if caller has more than one child, wait() returns ANY dead child.
               exit# is the exit(VALUE) used by child to die,
               sig#  is the (signal) number that caused the child to die.
            ONLY one of the numbers will be present, WHY?

     main()
     {
       int pid, status;
       pid = fork();
       if (pid){ // PARENT:
           printf("PARENT %d WAITS FOR CHILD %d TO DIE\n", getpid(),pid);
           pid=wait(&status);
           printf("DEAD CHILD=%d, HOW=%04x\n", pid, status);
       }
       else{// child:
           printf("child %d dies by exit(VALUE)\n", getpid());
           exit(100);  //OR {int a,b; a=b/0;} ==> see how does it die
       }
     }

5-3. Execution Order:
     After fork(), the child process competes with all other processes
     for CPU time to run. Which process will run next depends on their 
     scheduling prioirty, which changes dynamically.
 
     main()
     {
        int pid;
        pid=fork();
        if (pid){ // PARENT
           printf("PARENT %d DYING\n", getpid());
        }
        else{ // child
               printf("child %d sleeps for 2 seconds\n");
               sleep(2); // sleep for 2 seconds ==> PARENT DIES FIRST
               printf("child %d my parent=%d\n", getpid(), getppid());
        }
     }

5-4. Parent Process
     When a process dies (in Kmode), it becomes a ZOMBIE, i.e. its PROC is 
     marked as ZOMBIE and contains information, such as exit code. When the 
     parent process finds a ZOMBIE child (by wait() syscall), it collects the 
     needed information from the ZOMBIE PROC and finally lay the dead body to 
     rest, i.e. set the ZOMBIE PROC to FREE for recycle again. Thus, a process
     MUST have a parent at all times. However, because of the (independent) 
     process execution order, a process with children may die first. Similar 
     to humman society, such children are called orphans. The natural question
     is: who should be the "parent" of such orphans? In humman society, they 
     would be sent to grandma's house. But what if gradma also died? In Unix,
     the parent of all orphans is P1. Thus, P1 wears many hats:
     It's the grand dad of ALL user processes. It's the head of an orphange, 
     and it's also the manager of a morgue (which buries DEAD bodies). 
                  
5-4. nice(VALUE); 
     Decrease caller's scheduling priority by VALUE, allowing other processes
     to run first.

6. Change Execution Image:

   A process may use exec() to change its USER mode image to another 
   (executable) file. The exec() library functions have several members:
 
     int execl( const char *path, const char *arg, ...);
     int execlp(const char *file, const char *arg, ...);
     int execle(const char *path, const char *arg , ..., char *const envp[]);
     int execv( const char *path, char *const argv[]);
     int execvp const char *file, char *const argv[]);

   All of them eventually issue the syscall

     int execve(const char *filename, char *const argv[], char *const envp[]);

   which is the basis of the C function

         main(int argc, char *argv[], char *env[])


   If successful, exec("filename",....) replaces the current Umode image with
   a new image generated from the executable filename. It's the SAME process 
   but with a new Umode image. The old Umode image is abandoned and therefore
   never returned to, unless exec() fails, e.g. filename is non-executable.

   This is similar to a person who goes to Heaven (Kernel) from where he/she
   builds a new house on Earth (Umode), burns down the old house (IRS allows 
   only one house per person?) and returns to the new house to begin a new life
   there. Naturally, the person must return to the same old house if the new
   house cannot be built.
    
Example #1 : Use execl(), which is of the form 
                     
             execl("a.out", "a.out", string1, string2, ..., 0);

----------- cc to a.out ---------------------------------
 main(int argc, char *argv[])
{
  printf("THIS IS %d IN %s\n", getpid(), argv[0]);
  execl("b.out", "b.out", "hi", 0);
  printf("SHOUDL NOT SEE THIS LINE\n");
}  

----------- cc to b.out ---------------------------------
main(int argc, char *argv[])
{
  printf("this is %d in %s\n", getpid(), argv[0]);
  while(1);
}
----------------------------------------------------------


7. Signals and Signal Handling:

(1). A signal is a number from 1 to 31, as defined in &lt;asm/signal.h&gt;

(2). Signal Sources:
     traps      : errors recognized by CPU as "traps", e.g. 
                  divide by 0, illgal instruction, invalid address, ....
     interrupts : Control_C, HangUp, ...
     pre-defined: death_of_child,...
     sent by other processes via kill()

(2). kill(pid, signal#): send signal# to pid; signal#=1 to 31.

     main()
     {
       int pid, status;
       pid=fork();
       if (pid){// PARENT
                  kill(pid, 8);
                  pid=wait(&status);
                  printf("dead child=%d, how=%4x\n", pid, status);
                 }
       else{ // child
             while(1);  // while happily looping, child will die by sig# 8
           }
      }
============================================================================


(3). signal(sig#, ACTION); install a signal handler for sig#, 
            where ACTION = 0 ==> default action by Unix Kernel;
                           1 ==> ignore the signal (except #9)
                           &catcher() in user space.

#include &ltsignal.h&gt
#include &ltsys/time.h&gt

/**********************************************************
struct itimerval {
                struct timeval it_interval;
                struct timeval it_value;   
            };

struct timeval {
                long tv_sec;               
                long tv_usec;              
            };

int  setitimer(int which,  const  struct  itimerval  *value, struct
              itimerval *ovalue);
**************************************************************/

struct itimerval t;

int h, m, s;

void catcher(sig) int sig;
{
  printf("in catcher, sig=%d\n", sig);
}

main()
{

 t.it_interval.tv_sec = 1;    // interval=1 second
 t.it_interval.tv_usec= 0;

 t.it_value.tv_sec = 2;       // after 2 seconds 
 t.it_value.tv_usec= 0;

   signal(SIGALRM, (void *)catcher);   // install catcher for signal 14

   setitimer(ITIMER_REAL,&t,0);        // set interval timer REAL mode

 while(1);                             // sits here in a loop;

} 

<Title>360 Week 2 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes on Assembly Programming</H1>

<Pre>
   
              360 NOTES on Assembly Programming

1. Implement C functions in Assembly:

Example 1: Functions for getting CPU registers

main()
{
   int ebp, esp;
   ebp = get_ebp();
   esp = get_esp();
   printf("ebp=%8x   esp=%8x\n", ebp, esp);
}

=============================

	.global get_esp, get_ebp

get_esp:
         movl	%esp, %eax
         ret

get_ebp:
	movl	%ebp, %eax
	ret
=============================
EXERCISE: Write assembly functions for getting ebx, ecx, edx, esi and edi


Examples 2. A function that computes the sum of 2 integers

main()
{ 
  int a,b,c;
  a = 100; b = 200;
  c = mysum(a,b);
  printf("c=%d\n", c);
}

==========================
# int mysum(int x, int y)

        .global mysum
mysum:
# establish stack frame
        pushl	%ebp
        movl	%esp, %ebp

        movl	 8(%ebp), %eax
        addl	12(%ebp), %eax     
         
# return to main
        leave       # same as  { movl %ebp,%esp;  pop %ebp }
        ret


2. Call C functions from Assembly:

Example 3: Access global variables
 
int a, b;

main()
{
   a = 100;  b = 200;
   sub();
}

===================================

        .global sub, a, b, printf
sub:
        pushl   %ebp
        movl    %esp, %ebp

        pushl   b
        pushl   a
        pushl   $fmt
        call    printf
        addl    $12, %esp
        
        movl    %ebp, %esp
        popl    %ebp
        ret

fmt:	.asciz	"a=%d  b=%d\n" 
====================================

Example 4: Assembly function format:

# entry:
          pushl  %ebp
          movl   %esp, %ebp 
----------------------------------

    # Actual code of fucntion 

----------------------------------
# exit:    leave
           ret
   <Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>
                
<Pre>
                     HOWTO cat_cp_mv

int cat_file()
{
  ask for a pathname to cat

  mycat(pathname);

}

// with open() and read(), mycat() is almost trivial
 
int mycat(pathname) char *pathname;
{
 fd = myopen(pathname, 0);  // call OUR own myopen() to open file for READ

 loop:
       read 1 BLOCK, printf() to show the chars;
       UNTIL end file

 myclose(fd);
 
 return(0);
}


NOTE: For simplicity, consider cp (or mv) of a SINGLE file only.
      However, files may have DOUBLE-INDIRECT BLOCKs !!!!

int cp_file()
{
    ask for 2 pathnames, src and dest, for cp src to dest.
    
    call mycp(src, dest) to do the actual cp
}


int mycp(char *src, char *dest)
{
   AS USUAL, NEVER cp a file to itself !!

   open src for READ   ==> fd
   creat f2 if not exists;
   open dest for WRITE ==> gd; 
   loop:
         n = read(fd, buf, nbytes);
         write(gd, buf, n);
   while (n>0)
   close fd;
   close gd;
}




int mv_file()
{
    ask for 2 pathnames src and dest for mv  src to dest

    return mymv(src, dest);
}


int mymv(char *srcf1, char *dest)
{
  Case 1: same dev:
          Listen to lecture

  Case 2: differnet dev (with mounted FS):
          mycp(src, dest);
          rm src;
}







<Title>360 Class Notes</Title>
<Body bgcolor="#00ffdd" text="#000000">

<H1>360 Project Help #2</H1>

<Pre>

                 Simulator Data Structure Diagram

   KEEP A COPY OF THIS DIAGRAM FOR REFERENCE when designing your algorithms.


1. RunningPtr

     |
     V        |---- PointerToCWD ------|
              |                        |
2  PROC[]     |    3. OFT[ ]           V 4.MINODE[]              Disk dev
 ===========  |    ===========          ============       ===================
  nextProcPtr |     mode                  INODE            |         INODE   |
  pid, ppid   |     refCount             -------           =================== 
  uid, gid    |     MinodePtr            dev,ino
  cwd --------|     offset               refCount          
                  ===========            dirty
  fd[10]                                 mounted
  ------                                 mTablePtr -----------
  ------                                 filename[]          |
  ------                                                     |
  ------                                ============         |  
 ==========                               INODE              |
                                         -------             |
                                         dev,ino             |
                                         refCount            |  
                                         dirty               |
                                         mounted             |
                                         mTablePtr           |
                                         filename[]          |
                                        ============         |
                                                             |
            PointAtRootInode                                 |
                   ^                                         V
                   |                                    PointAtMountTable[0]
                   |      5.   MuntTable[ ]
                   |  ------- 0 --------- 1 ----------
                   |  | dev          |            |
                   |--| MinodePtr    |            |
                      |............. |            |
                      | deviceName   |            |
                      | MinodePath   |            |
                      |              |            |
                      | nblocks      |            |
                      | ninodes      |            |
                      ---------------------------------  



This diagram shows the data structures of the file system simulator.

1. is a PROC pointer pointing at the PROC structure of the current running 
   process.  Each process has a Currnet Working Directory, cwd, which is
   initialized to point at the in-memory root inode.

2. is the PROC structure of processes. Everything in the simulator is performed
   by the current ruuning process.

3. is the Open File Table (OFT). Each OFT entry represents an instance of an 
   opened file. We shall discuss OFT later when dealing with Level-2.

4. is the in-memory inodes array, MINODE[100]. Each minode entry contains a 
   sub-structure INODE, which is the INODE struct on Disk.  Whenever a file
   (regular or DIR) is referenced, its inode must be brought into memory. In 
   order to ensure ONLY ONE copy of every inode in memory, a needed inode will
   be loaded into a MINODE slot. The (dev, ino) field identifies where the 
   inode came from (for writing it back to disk). The refCount keeps track of
   how many processes are using this minode. The dirty field tells whether the
   INODE has been modified or not. If an minode is dirty, the last user of the
   minode must write the INODE back to disk. The mounted flag says whether 
   this DIR has been mounted on or not. If mounted on, the mTablePtr points at
   the MountTable entry.

5. is the MountTable (MT). Each entry represetns a device that has been 
   mounted (on a DIR).  When a file system starts, it must mount a device on
   the Root DIR /. That device is called the root device. So the first thing
   our simulator does is also to mount-root.  As shown, MT[0] represents the
   root device. The dev field identifies which device this is. The MinodePtr
   points at the DIR that's mounted on. (in 4, the DIR also points back to the
   mounted device). Knowing the dev, we can always access the device to get 
   its Superblock, bitmaps, rootInode, etc. For convenience, some often
   used information are kept in the MountTable for quick reference, e.g. 
   nblocks, ninodes. Here is an exmple of their usage: If process wants to 
   release an inode, it calls dealloc(ino) to deallocate the inumber of the 
   inode. The caller may pass in an ino > actual number of inodes (hence 
   exceeds the range of the inodes bitmap). We can check the ino against 
   ninodes to avoid tunning the worng bits on in the bitmap. Similarly for 
   nblocks. 



<html>
<body>
<pre>

                NOTES #11 EXT2 File System on FD

Under Linux, the command  mkfs /dev/fd0 1440  makes an EXT2 file system on a 
1.44MB floppy disk. It also reports some statistics, such as block size=1024, 
184 inodes, 1440 blocks, etc. Linux's mkfs creates an EXT2 file system with a
default lost+found directory. You may use the commands  
        mount /dev/fd0 /mnt;  rm -r /mnt/*;   umount /mnt
to make the file system empty.
 
The layout of an EXT2 file system on a floppy disk is 

   |Boot|Super| Gd |Bmap|Imap|Inodes blocks .....|data blocks ..........|
      0    1    2    3     4    5  ..............| .....................|

The block contents are explained below.

Block#0: Boot Block:
  B0 is the boot block, which is not used by the file system.

Block#1: Super Block:
  B1 is the Superblock, described by the super_block structure, where only the
  essential fields are (shown and) explained. You may ignore the other fields.

struct ext2_super_block {
  unsigned long  s_inodes_count;       // total number of inodes
  unsigned long  s_blocks_count;       // total number of blocks
  unsigned long  s_r_blocks_count;     
  unsigned long  s_free_blocks_count;  // current number of free blocks
  unsigned long  s_free_inodes_count;  // current number of free inodes 
  unsigned long  s_first_data_block;   // first data block in this group
  unsigned long  s_log_block_size;     // 0 for 1KB block size
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;   // 8192 blocks per group 
  unsigned long  s_frags_per_group;
  unsigned long  s_inodes_per_group;    
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_count;          // number of times mounted 
  short          s_max_mnt_count;      // mount limit
  unsigned short s_magic;              // 0xEF53
  // A FEW MORE non-essential fields
};

Block#2: Group Descriptor Block
EXT2 divides disk blocks into GROUPs. Each group contains 8192 (contiguous)
blocks. Each group is described by a group_desc structure of 32 bytes:

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;          // Bmap block number
  unsigned long  bg_inode_bitmap;          // Imap block number
  unsigned long  bg_inode_table;           // Inodes begin block number
  unsigned short bg_free_blocks_count;     // THESE are OBVIOUS
  unsigned short bg_free_inodes_count;
  unsigned short bg_used_dirs_count;        

  unsigned short bg_pad;                   // ignore these 
  unsigned long  bg_reserved[3];
};

A FD has only 1440 blocks. So, B2 contains only 1 group_desc structure (The
rest are 0's).

Block#3: Block Bitmap (Bmap):
A bitmap is a sequence of bits used to represent some kind of items, e.g. disk
blocks or inode structures. Bitmaps are used to allocate/deallocate items. In a
bitmap, a 0 bit means the corresponding item is FREE, and a 1 bit means the 
corresponding item is in USE. A FD has 1440 blocks but block#0 is NOT used by
the file system. So, the Bmap has only 1439 valid bits in B3. The exact values 
of Bmap will be shown later.

Block#4: Inode Bitmap (Imap)
An inode is a data structure used to represent a file. A file system is created
with a finite number of inodes. The status of the inodes are represented by a
a bitmap, called the Imap, in B4. 
In an EXT2 FS, the first 10 inodes are reserved. Thus, the Imap of an empty FS
starts with TEN 1's, followed by 0's.

Block#5: Inodes (begin) Block
In Unix, every file is represented by a UNIQUE inode structure of 128 bytes, 
defined as follows.

struct ext2_inode {
  //*************************************************************************
  unsigned short i_mode;                      // will be explained in detail 
  unsigned short i_uid;                       // ownerID
  unsigned long  i_size;                      // file size in bytes
  unsigned long  i_atime;                     // time fields  
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;                       // groupID
  unsigned short i_links_count;               // link count
  unsigned long  i_blocks;                    // IGNORE
  unsigned long  i_flags;                     // IGNORE
  unsigned long  i_reserved1;                 // IGNORE
  unsigned long  i_block[15];                 // See details below
  //**************************************************************************

  // IGNORE THE FOLLOWING
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsigned long  i_reserved2[2
}

The fields i_block[15] record the disk blocks (numbers) of a file, which are 

    DIRECT blocks : i_block[0] to i_block[11], which point to direct blocks.
    INDIRECT block: I_block[12] points to a block, which contians 256 (ulong) 
                    block numbers.
    DOUBLE INDIRECT block: 
                    I_block[13] points to a block, which points to 256 blocks,
                    each of which point to 256 blocks.
    TRIPLE INDIRECT block: 
                    I_block[14] points to a block, which points to 256 blocks,
                    each of which points to 256 blocks, each of which points to
                    256 blocks.
    
The total number of inodes is always a multiple of 8 (so that every inodes 
block is full). The number of inode blocks is therefore
                    (total number of inodes)/8. 
For example, if the number of inodes is 184, then the inode blocks include 
B5, B6, B7, ...., B27.


Data Blocks:
Immediately after the inode blocks are the data blocks. In the example of 184
inodes, the first real data block is B28, which is i_block[0] of the root
directory /.


EXT2 Directory Entries:
A directory contains dir_entry sturctures. In EXT2, component file names can 
vary form 1 to 255 chars long. So the dir_entries also have varying length. 

struct ext2_dir_entry_2 {
	unsigned long  inode;        // Inode number; count from 1, NOT from 0
	unsigned short rec_len;      // This entry length in bytes
	unsigned char  name_len;     // Name length in bytes
	unsigned char  file_type;    // for future use
	char   name[EXT2_NAME_LEN];  // File name: 1-255 chars, no NULL byte
};

                  HOW TO STEP THROUGH dir_entries:

Example: Assume the root directory / contains entries 
                this  is  aVeryLongName short
Then the 0th data block (i_block[0] in its inode) of this DIR file contains:
 
|2 12 1.|2 12 2..|11 12 4this|12 12 2is|13 24 13aVeryLongName|14 952 5short   |

Each record has a rec_len and a name_len field, which will be explained later.

First, read the block into a char buf[1024].
Let DIR *dp and char *cp BOTH point at buf;
Use dp-> to access the fields of the record, e.g. print the name

                    TO MOVE TO THE NEXT entry:
        cp += dp->rec_len;       // advance cp by rec_len BYTEs
        dp = (shut-up)cp;        // pull dp along to the next record

This way, you can step through ALL the record entries of a DIR file.


************************ Mailman's Algorithm by KCW *************************
Each inode is determined uniquely by its POSITION (counting from 0,1,2,...) in
the inode area. The position PLUS 1 is called the inode number (i_number or 
ino for short), which counts from 1. (A 0 i_number means no inode). In an EXT2
FS, the root inode is inode #2.
                       
                             QUESTION:
----------------------------------------------------------------------------
 Given an i_number, such as 123, how to find the inode in the inode blocks?
 i.e. which inode block?  which inode in that inode block?
 This problem has a more general form:

                         Mailman's Algorithm:
 A city has M blocks, numbered 0,1,2,..,M-1. Each block has N houses, numbered 
 0,1,..,N-1.
 Each house has a unique BLOCK address in the form
                BA = (BLOCK, HOUSE)
 A house also has a unique LINEAR address 
                LA = 0,1,2,..,N-1, N,N+1,......

                            PROBLEM:
 Given a linear address LA, e.g. 123, determine its BLOCK address, and vice 
 versa. The solution is called the Mailman's algorithm:
 
 IF everything counts from 0,the algorithm is very simple:

                    BA = (LA / N, LA % N)
                    LA = N*BLOCK + HOUSE

 It is so simple that you may ask: What's all the fuss about?
 QUESTION: WHAT IF they do not count from 0?
============================================================================
Applications of Mailman's Algorithm:

1. Test, Set, Clear BITs in C:
   Consider  char buf[1024]; buf[] has 1024 bytes, known as buf[i], i=0,1,2,.. 
   It also has 8192 BITs numbered 0,1,2,....

   Given a bit number BIT, e.g. 1234, which byte i contains the bit, and which 
   bit j is it in that byte?
   Solution:
               i = BIT / 8
               j = BIT % 8

   To TST a bit at BIT:  if ( buf[i] & (1 << j) )

   To SET a bit at BIT:  buf[i] |=  (1 << j);
     
   To CLR a bit at BIT:  buf[i] &= ~(1 << j);
 
2. Convert i_number to inode:
   In an EXT2 FS, inodes begin in the inode_table block (block 5 for FD).
   Each inode has a unique i_number = 1,2,.....

   Given an i_number, e.g. 1234, determine which disk block# contains that
   inode, and which inode# is it in that block?

   We need to know the block# because READ/WRITE real disk is always in block,
   can't just read/write an item inside a disk block.    

   Soution:  block# = (i_number - 1)/INODES_PER_BLOCK + inode_table;
             inode# = (i_number - 1)%INODES_PER_BLOCK;

   TRY TO ANSWER FOR YOURSELF: WHY i_number-1? and WHY + inode_table
   
3. Convert disk block# to CHS = (cyl, head, sector) of a REAL disk:
   A FD has 80 cylinders, each cylinder has 2 tracks (heads), each track has
   18 sectors. A hard disk just has many MORE cylinders, heads and sectors.
 
   Given a (linear) block#, e.g. 1234, determine its (cyl, head, sector) on
   the disk. Some disk drivers takes only (cyl,head,sector) for disk I/O.
*****************************************************************************

All the struct types are defined in 
&ltlinux/ext2_fs.h&gt

==========================================================================
#include &ltstdio.h&gt
#include &ltfcntl.h&gt
#include &ltlinux/ext2_fs.h&gt

// define shorter TYPES, save typing efforts
typedef struct ext2_super_block SUPER;
typedef struct ext2_group_desc  GD;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

==============================================================================

                            EXERCISES

ASSUME: mkfs /dev/fd0 1440
Write C programs to display the specified information on the FD:
------------------------------------------------------------------------
1. super.c  : the superblock information,
2. gd.c     : the group descriptor information.
3. bmap.c   : the Bmap as a sequence of 0/1 chars (80 chars per row).
4. imap.c   : the Imap as a sequence of 0/1 chars (80 chars per row)
5. inode.c  : root inode
6. dir.c    : dir_entries of the root directory.
-------------------------------------------------------------------------

<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Linux EXT2 File System</H1>

<Pre>

The Second Extended File system (EXT2)

1. Groups

An EXT2 disk partition is divided into groups (of 8K blocks). Each group 
contains in the order: 

    Superblock 

    Group Descriptors 

    Block bitmap of the group

    Inode bitmap of the group

    Inodes of the group

    Data blocks of the group 


2. The EXT2 Superblock

  The Superblock contains information about the entire file system.
Amongst other information it contains:

Magic Number 
    This allows the mounting software to check that this is indeed the 
    Superblock for an EXT2 file system. For the current version of EXT2 this 
    is 0xEF53. 
Revision Level 
    The major and minor revision levels allow the mounting code to determine 
    whether or not this file system supports features that are only available 
    in particular revisions of the file system. There are also feature
    compatibility fields which help the mounting code to determine which new 
    features can safely be used on this file system, 
Mount Count and Maximum Mount Count 
    Together these allow the system to determine if the file system should be 
    fully checked. The mount count is incremented each time the file system is
    mounted and when it equals the maximum mount count the warning message 
    ``maximal mount count reached, running e2fsck is recommended'' is 
    displayed, 
Block Group Number 
    The Block Group number that holds this copy of the Superblock, 
Block Size 
    Block size used by the file system.
Blocks per Group 
    The number of blocks in a group. Like the block size this is fixed when 
    the file system is created, 
Free Blocks 
    The number of free blocks in the file system, 
Free Inodes 
    The number of free Inodes in the file system, 
First Inode 
    This is the inode number of the first inode in the file system. 

The detailed structure of an ext2fs superblock is [include/linux/ext2_fs.h]: 

struct ext2_super_block {
  unsigned long  s_inodes_count;
  unsigned long  s_blocks_count;
  unsigned long  s_r_blocks_count;
  unsigned long  s_free_blocks_count;
  unsigned long  s_free_inodes_count;
  unsigned long  s_first_data_block;
  unsigned long  s_log_block_size;
  long           s_log_frag_size;
  unsigned long  s_blocks_per_group;
  unsigned long  s_frags_per_group;
  unsigned long  s_inodes_per_group;
  unsigned long  s_mtime;
  unsigned long  s_wtime;
  unsigned short s_mnt_count;
  short          s_max_mnt_count;
  unsigned short s_magic;
  unsigned short s_state;
  unsigned short s_errors;
  unsigned short s_pad;
  unsigned long  s_lastcheck;
  unsigned long  s_checkinterval;
  unsigned long  s_reserved[238];
};

s_inodes_count 
    the total number of inodes on the fs. 

s_blocks_count 
    the total number of blocks on the fs. 

s_r_blocks_count 
    the total number of blocks reserved for the exclusive use of the superuser.

s_free_blocks_count 
    the total number of free blocks on the fs. 

s_free_inodes_count 
    the total number of free inodes on the fs. 

s_first_data_block 
    the position on the fs of the first data block. Usually, this is block 
    number 1 for fs containing 1024 bytes blocks and is number 0 for other fs. 

s_log_block_size 
    used to compute the logical block size in bytes. The logical block size is
    in fact 1024 << s_log_block_size. 

s_log_frag_size 
    used to compute the logical fragment size. The logical fragment size is in
    fact 1024 << s_log_frag_size if s_log_frag_size is positive and 1024 >> 
    -s_log_frag_size if s_log_frag_size is negative. 

s_blocks_per_group 
    the total number of blocks contained in a group. 

s_frags_per_group 
    the total number of fragments contained in a group. 

s_inodes_per_group 
    the total number of inodes contained in a group. 

s_mtime 
    the time at which the last mount of the fs was performed. 

s_wtime 
    the time at which the last write of the superblock on the fs was performed.

s_mnt_count 
    the number of time the fs has been mounted in read-write mode without 
    having been checked. 

s_max_mnt_count 
    the maximum number of time the fs may be mounted in read-write mode before
    a check must be done. 

s_magic 
    a magic number that permits the identification of the file system. It is 
    0xEF53 for a normal ext2fs and 0xEF51 for versions of prior to 0.2b. 

s_state 
    the state of the file system. It contains an or'ed value of EXT2_VALID_FS
    (0x0001) which means: unmounted cleanly; and EXT2_ERROR_FS (0x0002) which 
    means: errors detected by the kernel code. 

s_errors 
    indicates what operation to perform when an error occurs. See section 
    Error Handling 

s_pad 
    unused. 

s_lastcheck 
    the time of the last check performed on the fs. 

s_checkinterval 
    the maximum possible time between checks on the fs. 

s_reserved 
    unused. 

Times are measured in seconds since 00:00:00 GMT, January 1, 1970. 



3. The EXT2 Group Descriptor

  Each Group is described by a data structure called the Group Descriptor.
Like the Superblock, all the group descriptors for all of the Block Groups are
duplicated in each Block Group in case of file system corruption. 

Each Group Descriptor contains the following information: 

Blocks Bitmap 
    The block number of the block allocation bitmap for this Block Group. 
    This is used during block allocation and deallocation, 
Inode Bitmap 
    The block number of the inode allocation bitmap for this Block Group. 
    This is used during inode allocation and deallocation, 
Inode Table 
    The block number of the starting block for the inode table for this Block 
    Group. Each inode is represented by the EXT2 inode data structure 
    described below. 
Free blocks count, Free Inodes count, Used directory count 

The group descriptors are placed one after another and together they make the 
group descriptor table. Each Blocks Group contains the entire table of group 
descriptors after its copy of the Superblock. Only the first copy (in Block
Group 0) is actually used by the EXT2 file system. The other copies are there,
like the copies of the Superblock, in case the main copy is corrupted. 

On disk, the group descriptors immediately follow the superblock and each 
descriptor has the following layout: 

struct ext2_group_desc
{
  unsigned long  bg_block_bitmap;
  unsigned long  bg_inode_bitmap;
  unsigned long  bg_inode_table;
  unsigned short bg_free_blocks_count;
  unsigned short bg_free_inodes_count;
  unsigned short bg_used_dirs_count;
  unsigned short bg_pad;
  unsigned long  bg_reserved[3];
};

bg_block_bitmap 
    points to the blocks bitmap block for the group. 

bg_inode_bitmap 
    points to the inodes bitmap block for the group. 

bg_inode_table 
    points to the inodes table first block. 

bg_free_blocks_count 
    number of free blocks in the group. 

bg_free_inodes_count 
    number of free inodes in the group. 

bg_used_dirs_count 
    number of inodes allocated to directories in the group. 

bg_pad 
    padding. 

The information in a group descriptor pertains only to the group it is 
actually describing. 


4. Block and Inode Bitmaps

The ext2 file system uses bitmaps to keep track of allocated blocks and inodes.
The blocks bitmap of each group refers to blocks ranging from the 0th block
to the last block in the group. The inode bitmap of each group refer to inodes
ranging from the 0th inode (inumber couts from 1) to the last inode of the
group. A 0 bit means that block/inode is FREE, and a 1 bit means it has been
allocated.


5. Inodes

   An inode is a structure that uniquely describes a file. In the EXT2 file
system, every file and directory is described by one and only one inode. 
The EXT2 inodes for each Block Group are kept in the inode table together with
a bitmap that allows the system to keep track of allocated and unallocated 
inodes. It contains the following fields: 

mode 
    This holds two pieces of information; what does this inode describe and 
    the permissions that users have to it. For EXT2, an inode can describe one
    of file, directory, symbolic link, block device, character device or FIFO. 
Owner Information 
    The user and group identifiers of the owners of this file or directory. 
    This allows the file system to correctly allow the right sort of accesses, 
Size 
    The size of the file in bytes, 
Timestamps 
    The time that the inode was created and the last time that it was modified,


The detailed inode structure is as follows.

struct ext2_inode {
  unsigned short i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[EXT2_N_BLOCKS];
  unsigned long  i_version;
  unsigned long  i_file_acl;
  unsigned long  i_dir_acl;
  unsigned long  i_faddr;
  unsigned char  i_frag;
  unsigned char  i_fsize;
  unsigned short i_pad1;
  unsigned long  i_reserved2[2];
};

i_mode 
    type of file (character, block, link, etc.) and access rights on the file. 

i_uid 
    uid of the owner of the file. 

i_size 
    logical size in bytes. 

i_atime 
    last time the file was accessed. 

i_ctime 
    last time the inode information of the file was changed. 

i_mtime 
    last time the file content was modified. 

i_dtime 
    when this file was deleted. 

i_gid 
    gid of the file. 

i_links_count 
    number of links pointing to this file. 

i_blocks 
    number of blocks allocated to this file counted in 512 bytes units. 

i_flags 
    flags (see below). 

i_reserved1 
    reserved. 

i_block 
    pointers to blocks (see below). 

i_version 
    version of the file (used by NFS). 

i_file_acl 
    control access list of the file (not used yet). 

i_dir_acl 
    control access list of the directory (not used yet). 

i_faddr 
    block where the fragment of the file resides. 

i_frag 
    number of the fragment in the block. 

i_size 
    size of the fragment. 

i_pad1 
    padding. 

i_reserved2 
    reserved. 

As can be seen, an inode contains, EXT2_N_BLOCKS (15) pointers to block. 
Of theses pointers, the first EXT2_NDIR_BLOCKS (12) are direct pointers to 
data blocks. The following entry points to a block of pointers to data 
(indirect). The following entry points to a block of pointers to blocks of 
pointers to data (double indirection). The following entry points to a block 
of pointers to a block of pointers to a block of pointers to data
(triple indirection).

For SPECIAL files (I/O devices such as /dev/fd0, /dev/hda1, etc.) they
do not need data block pointers. Only iblock[0] contains the device's
(major, minor) ID numbers.


The inode flags may take one or more of the following or'ed values: 

EXT2_SECRM_FL 0x0001 
    secure deletion. This usually means that when this flag is set and we 
    delete the file, random data is written in  the blocks previously allocated
    to the file. 

EXT2_UNRM_FL 0x0002 
    undelete. When this flag is set and the file is being deleted, the file 
    system code must store enough information to ensure the undeletion of the 
    file (to a certain extent). 

EXT2_COMPR_FL 0x0004 
    compress file. The content of the file is compressed, the file system code
    must use compression/decompression algorithms when accessing the data of 
    this file. 

EXT2_SYNC_FL 0x0008 
    synchronous updates. The disk representation of this file must be kept in 
    sync with it's in core representation. Asynchronous I/O on this kind of 
    file is not possible. The synchronous updates only apply to
    the inode itself and to the indirect blocks. Data blocks are always written
    asynchronously on the disk. 

Some inodes have a special meaning: 

EXT2_BAD_INO 1 
    a file containing the list of bad blocks on the file system. 

EXT2_ROOT_INO 2 
    the root directory of the file system. 

EXT2_ACL_IDX_INO 3 
    ACL inode. 

EXT2_ACL_DATA_INO 4 
    ACL inode. 

EXT2_BOOT_LOADER_INO 5 
    the file containing the boot loader. (Not used yet it seems.) 

EXT2_UNDEL_DIR_INO 6 
    the undelete directory of the system. 

EXT2_FIRST_INO 11 
    this is the first inode that does not have a special meaning. 


6. Directories

A directory is a file containing a list of entries of the following format: 

struct ext2_dir_entry_2 {
        unsigned long  inode;                  /* Inode number */
        unsigned short rec_len;                /* Directory entry length */
        unsigned char  name_len;               /* Name length */
        unsigned char  file_type;            
        char    name[EXT2_NAME_LEN];           /* File name */
};


inode 
    points to the inode of the file. 

rec_len 
    length of the entry record. 

name_len 
    length of the file name. 

name 
    name of the file. This name may have a maximum length of EXT2_NAME_LEN 
    bytes (255 bytes as of version 0.5). 

As in all Unix file systems. the first two entries in a directory are "." and
".." which represent to the current directory and the parent directory.


Whenever possible, ext2 uses the following rules to allocate new inodes and 
data blocks: 

    the inode for a new file is allocated in the same group of the inode of 
    its parent directory. 

    inodes are allocated equally between groups. 

    a new block is allocated in the same group as its inode. 

    allocate consecutive sequences of blocks. 
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #6</H1>

<Pre>
                   CS360 NOTES on FILE OPERATIONS

1. File Operations in Unix consists of 5 levels, from LOW to HIGH:
   
1.1. Hardware Level:
     This is the lowest level of file operations. It prepares the hardware 
     device, e.g. disk drive, for file systems
     Examples: fdisk : divide a hard disk into partitions.
               mkfs  : create a file system on a disk, also known as format.
               fsck  : check and repair file systems.
     Many "comercial" file system tools, such as DiskManager, DiskDoctor, etc.
     belong to this catagory.

1.2. System Call Level:
     Every Operating System provides support for BASIC file operations. 
     Unix has the following file operation functions in its kernel:

          kmount(), kumount();            (for mount/umount file systems)

          Kmkdir(), Krmdir(), Kchdir(),   (obvious)
          klink(),  kunlink(),ksymlink(), (for link/remove files) 
          Kchmod(), Kchown(), ktouch()    (change file MODE, owner, time)  

          Kcreat(), Kopen(),              (create/open file for R,W,RW,..) 
          Kread(),  Kwrite(),             (read/write opened files) 
          Klseek();                       (change R/W byte position)
          Kclose()                        (close opened files)

          kopendir(), kreaddir(), kclosedir(), (READ directories)
          kreadlink();                    (READ symbolic link files)

          kstat(),  kfstat(), klstat(),   (get file status/information)

     The prefix K emphasizes that these are functions inside the Unix Kernel.

     
                        SYSTEM CALLS:

     Processes use System Calls (syscall for short) to access Kernel functions.
     More will be on this later.  For the time being, consider how to READ a 
     file.
     
     Assume myfile is an existing file. The following C program shows HOW TO
     READ the file (contents).

           #include    &lt;fcntl.h&gt;
           int fd, n;   char myBuffer[1024]; 
           main()
           {
              fd = open("myfile", flags, mode); where flag = O_RDONLY|O_WRONLY|O_RDWR|many others
                                                      mode = permission bits for new file

              if (fd < 0)                  fd is called a FileDescriptor.
                 exit(1);                  if fd < 0, open() call has failed.
                   
              n = read(fd, myBuffer, nbytes);  where nbytes = number of bytes you wish to read.
                                               data will be read into myBuffer[]. 
                                               n = ACTUAL # of bytes read.
              
             lseek(fd, (long)POSITION, 0);     This moves the read Pointer to POSITION bytes from 
                                               the file beginning. NOTE: It's a LONG.
 
             close(fd);                        This closes an opened file.

           }


Examples:  
          #define BLKSIZE 1024

          int fd; char buffer[BLKSIZE];

          fd = open("/dev/fd0", 0);       /* open floppy drive 0 for READ */
          lseek(fd, (long)BLKSIZE, 0);    /* skip 1024 bytes ==> to BLOCK#1 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          lseek(fd, (long)4*BLKSIZE, 0)   /* move to beginning of Block#4 */
          read(fd, buffer, BLKSIZE);      /* read one block into buffer */
          .........................

     The functions open(), read(), write(), lseek(), close() in a User mode 
     program are Library functions.  Each such Library function will issue a
     syscall, causing the process to switch from User mode to Kernel mode.
     Once in K mode, the process will be directed to the corresponding Kenrel
     function, e.g. open() goes to Kopen(), read() goes to Kread(), etc.  
     When the process finishes executing the Kernel function, it exits Kernel 
     and returns to User mode.

     Every syscall causes the process to enter K mode and then back to U mode.
     Switching between Umode and Kmode takes a lot of actions (and time). Data
     transfer between Kmode and Umode is especially "expensive". Although it is
     permissible to issue
                         read(fd, buffer, 1);
     syscall to read just ONE byte, it is NOT wise to do so because that one 
     byte would come with a terrible price. Every time you have to cross the 
     boarder to enter the wonderful world of Kernel, do as much as you can 
     rather than in piece meal in order to make the journey worthwhile. In the
     case of READ/WRITE files, the best way is to match what the Kernel does. 
     The kernel reads/writes disks by BLOCK size, which ranges from 1KB to
     8KB. For instance, in Linux, the default BLOCK size is 4KB for hard disks
     and 1KB for floppy disks. 

1.3  Library I/O Functions:
    
     Syscalls allow us to read/write chunks of data, which are just a sequence
     of bytes. They do not know, nor care, about the meaning of the data. 
     However, a user (program) often needs to read/write individual chars or
     lines. If so, the user program would have to do these from/to a beffered 
     data area by itself. Most users would consider this "too much"!

     The C library provides a set of standard I/O functions for convenience, as
     well as for run-time efficiency. The library I/O functions include:

     FILE I/O      :  fopen(), fread(); fwrite(), fseek(), fclose();
                      fflush(), 
     char mode I/O :  getc(), putc(), getchar(), putchar(), ungetc()
     line mode I/O :  gets(), puts(), fgets(), fputs();

     formatted I/O :  scanf(), fscanf(), sscanf();
                      printf(), fprintf(), sprintf()

     With the exceptions of sscanf()/sprintf(), which read/write memroy 
     locations, all other library I/O functions are built on top of syscalls 
     in that they ultimately issue syscalls for "actual" data transfer through
     the Operating System Kernel.

1.4. User Commands Level:

     Instead of writing programs, users may use Unix commands to manipulate
     files. Examples of user commands are

            mkdir, rmdir, cd, pwd, ls;
            rm, cat, cp, mv, chmod, .....

     Each user command is in fact an executable program (except cd), which 
     typically calls library I/O functions, which in turn issue syscalls to 
     invoke the corresponding kernel functions. Thus, the processing sequence 
     is either
            Command ==> Library I/O function ==> Syscall ==> | Kernel Function
        or
            Command ===========================> Syscall ==> | Kernel Function

1.5. sh Script Files:

     Although much more convenient than syscalls, commands must be entered
     manually, which is often tedious and time-consuming.

     sh scripts are files written in the sh programming language. The sh 
     language includes all valid Unix commands. It also includes additional 
     statements (if, do, for, while, case, etc.) to control the executions.  
     In practice, sh scripts are used extensively in Unix system programming.
     In addition to sh, many other script languages, such as Perl, are also in
     wide use. sh programming will be covered later. 


<tITLE>CS460</TITLE>

<BODY bgcolor="#00CCCC" TEXT="#000000" LINK="#990000" VLINK="#0000FF" ALINK="#3300FF"> 

<H1>CS360 CLASS NOTES</H1>
<H2>
<P>
<img src="redball.gif" alt ="*">
<A HREF="planF08.html">Course Plan : Fall, 2008</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_final_signup.html">Final Demo Signup</a>

<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_460_ta.html">TA Information</a>
<P>
<img src="redball.gif" alt="*">
<A HREF="ta_files/cs360_grade.html">Lab Grades</a>
<P>
<img src="redball.gif" alt=*">
<A HREF="ta_files/cs360_grade_exam.html">Exam Grades</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes1.html">Notes #1: Introduction to Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="lab1.html">Lab Assignment #1</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes2.html">Notes #2 : Program Development</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="notes3.html">Notes #3 : Function Calls</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LAB2Pre.html">Lab#2 Pre-work</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="ass.html">Notes #4 : Assembly Programming</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LAB2.html">Lab Assignment #2</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="PROC.html">Notes #5 : Process Management in Unix</a>
<P>
<img src="redball.gif" alt ="*">
<A HREF="LABsh.html">Lab Assignment #3 : sh Simulator</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="fileops.html">Notes #6 : File Operations</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="syscall.html">Notes #7 : System Calls</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="libio.html">Notes #8 : Library I/O Functions</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="pre4.html">Lab #4 Pre-Work; DUE : in Lab, Sept. 24, 2008</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="IP.07.html">Notes #9 : Newtork Programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB4.tcp.html">LAB #4 : File Operations across Networks</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="sh.html">Notes #10 : sh programming</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fs.html">Notes #11 : EXT2 File System Info</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="ext2fd.html">Notes #12 : EXT2 FS on Floppy Disk</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="LAB5pre.html">LAB #5 Pre-work (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="lab508.html">LAB #5 show block (DUE : 10-15-08)</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="review.html">REVIEW FOR EXAM #1</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="proj08.html">Project Specification</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="project.help.html">Project Organization</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="diagram.html">Project Data Structures</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="util.html">Project HELP: Utility functions</a>

<P>
<img src="redball.gif" alt = "*">
<A HREF="mkdir_creat.html">Project HELP: HOW TO mkdir_creat</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="stat_ls_cd_pwd.html">Project HELP: HOW TO cd_stat_ls_pwd</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="rmdir_rm.html">Project HELP: HOW TO rmdir_rm</a>
<h2>Project Level-2 Help Files</h2>
<P>
<img src="redball.gif" alt = "*">
<A HREF="open_close.html">Project HELP: HOW TO open_close files</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="read_ext2.html">Project HELP: HOW TO read</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="write_ext2.html">Project HELP: HOW TO write</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="cat_cp_mv.html">Project HELP: HOW TO cat_cp_mv</a>
<P>
<img src="redball.gif" alt = "*">
<A HREF="mount_umount.html">Project HELP: HOW TO mount_umount</a>




<TITLE>CS360 LAB ASSIGNMENT #1</Title>
<Body bgcolor="#FFFFd8" text="#000000">
<H1>CS360 LAB ASSIGNMENT #1</H1>
<Pre>
                     CS360 ASSIGNMENT #1
              DUE & DEOM: Week of Sept 1, 2008

1. OBJECTIVES
   Partition table, fdisk, structures in C, read/write special files

2 Partition Table:

A disk is usually divided into several partitions. The partitions are recorded
in a partition table in the very first sector of the disk, called the Master Boot 
Record (MBR). Each sector is 512 bytes long. Inside the MBR, the partition table 
begins at the offset 0x1BE. The Partitin Table contains 4 entries, each 16 bytes 
long as defined in the following C structure.

struct partition {
	unsigned char drive;            /* 0x80 - active */

	unsigned char head;             /* starting head */
	unsigned char sector;           /* starting sector */
	unsigned char cylinder;         /* starting cylinder */

	unsigned char sys_type;         /* partition type */

	unsigned char end_head;         /* end head */
	unsigned char end_sector;       /* end sector */
	unsigned char end_cylinder;     /* end cylinder */

	unsigned long start_sector;     /* starting sector counting from 0 */
	unsigned long nr_sectors;       /* nr of sectors in partition */
};

As can be seen, sector and cylinder are all unsiged chars (8 bits). However, the
cylinder value is actually 10 bits. The highest 2 bits of cylinder value are in  
the leftmost 2 bits of sector, which is only 6 bits.
 
Each partition has a type, which indicates the kind of file system of the 
partition. Consult Linux's fdisk to see the partition types.

If a partition is EXTEND type (type==5), the partition may be further divided 
into more partitions. The extended partitions forms a link-list as the 
following diagram shows. 

Assume P4 is EXT type:
P4's beginSector = MBR
                    P5's beginSector
                    P6's MBR's sector# = MBR
                         (r.e. to P4)     P6's begin sector#
                                          P7's MBR r.e. to P4 --> etc.

Since use fdisk on any hard disk is risky, we shall use a floppy disk for this
assignment. Download the file ~cs360/samples/LAB1/floppyImage.gz to Linux. 
Uncompress and dump it to flopy disk by
                gunzip floppyImage.gz           ( unzip to floppyImage ) 
                dd if=floppyImage  of=/dev/fd0  ( dump to a FD         )

Then, run       fdisk /dev/fd0  
                 'p' : to print the partition table
                 'q' : to quit fdisk
to see the partition table on the floppy disk. 


                      REQUIREMENTS

Write a C progrom to display the partition table of the FLOPPY disk in 
(1). RAW form, i.e. as per the partiton struct entries (%20), then 
(2). Linux fdisk 'p' output form (%40),
(3). including ALL the extend partitions (%40) <== YOU BETTER DO THIS !!!!.

Turn in a floppy disk containing your work. Also, sign up for demonstration
in SLOAN 327 on Wednesday.
==============================================================================

3. HELP INFO: UNIX System calls for reading/writing files
                   int fd = open("filename", mode);
                   lseek(fd, (long)position, 0); 
                   read(fd, buffer, nbytes);
                   write(fd, buffer, nbytes);
                   close(fd);

The following C program writes/reads floppy disk sectors

#include &ltfcntl.h&gt
char buf[512];
int sector;

main()
{
   int fd, r;
   sector = 10;                           // sector # 10 (count from 0)  

   fd = open("/dev/fd0", O_WRONLY);       // open /dev/fd0 for WRITE
   strcpy(buf, "cs360 is fun");           // create a string in buf[]
   lseek(fd, (long)sector*512, 0);        // seek to the sector 10
   r = write(fd, buf, 512);               // write 512 bytes to fd
   printf("r=%d bytes written\n", r);     // show number of bytes written
   close(fd);                             // close the file descriptor fd

   fd = open("/dev/fd0", O_RDONLY);       // open /dev/fd0 for READ
   lseek(fd, (long)sector*512, 0);        // seek to sector 10           
   r = read(fd, buf, 512);                // read 512 bytes into buf
   printf("r=%d read  buf=%s\n", r, buf); // show result
   close(fd);                             // close opened file
}

4. Sample Solution:
   ~cs360/samples/LAB1/lab1.bin






<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Oct. 15, 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can easily determine whether it's a DIR.
   
   (READ how to use S_ISDIR(), S_ISREG() macros by  man stat)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       -------------------------------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB5:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#FFFFFF" text="#000000">

<H1>LAB Assignment #5</H1>

<Pre>

/ *************** DUE & DEMO : Week of Oct. 13 2008 ********************
 
 Write a C program, showblock, which displays the disk blocks of a file 
 in an EXT2 file system. The program runs as follows

       showblock   DEVICE    PATHNAME

e.g.   showblock  /dev/fd0   /a/b/c/d
OR     showblock  ext2Image  /x/y/z    (ext2Image is an EXT2 image file)

 It locates the file named PATHNAME and prints the disk blocks (direct, 
 indirect, double-indirect) of the file.
**************************************************************************/ 

               HOWTO Traverse EXT2 File System Tree

1. REVIEW The Mailman's Algorithm

2. Traverse the EXT2 FS tree
   Given a device (/dev/fd0), containing an ext2 FS, and a pathname, e.g. 
                   /cs360/is/fun
   of a file, find the file.

   NOTE!!! To find a file amounts to finding its INODE. 
           From the inode, you have ALL the information of a file.

  
3. ALGORITHM
  
1. Open the device for READ. 
   Read in Superblock (blk #1 for FD to verify it's indeed an ext2 FS. (HOW?)

   (With the SuperBlock read in, you might as well print some of its important
    fields, e.g. nblocks, ninodes, ngroups, inodes_per_group, number of free 
    inodes and blocks, etc.
   )

2. Read in the group descriptor block (block #2 for FD) and access Group0 
   Descriptor. From its bg_inode_table entry, determine where INODEs begin on 
   the disk.  Call it the InodesBeginBlock.  

3. Read in InodeBeginBlock to get the inode of /, which is INODE #2.
   NOTE: inode number counts from 1.

4. Break up pathname into components and let the number of components be n,
   Example:
                            |<----- n = 3  ---->|
         /cs360/is/fun  ==> cs360     is      fun 

   Denote the components by name[0] name[1] name[n-1]

   YOU HAVE DONE THESE BEFORE!!!

6. Start from the root INODE in (3), search for name[0] in its data block(s).
   For DIRs, you may assume that (the number of entries is small so that) it 
   only has DIRECT data blocks. Therefore, search only the direct blocks for 
   name[0].

   Each data block of a DIR inode contains DIR structures of the form 

     [ino rlen nlen .   ] [ino rlen nlen ..  ] [ino rlen nlen NAME ] ....
     [ino rlen nlen NAME] [ino rlen nlen NAME] [ino rlen nlen NAME ] ....
     
   where each NAME is a string (without terminating NULL !!!) of nlen chars. 
   You may use nlen to extract the NAME string, and rlen to advance to the 
   next DIR structure (Listen to lecture in class). 

   If name[0] exists. you can find its inode number.

7. Use the inode number, ino, to locate the corresponding INODE:
   Recall that ino counts from 1.  Use the Mailman's algorithm

               (ino - 1) / 8    and   InodeBeginBlock    
               (ino - 1) % 8 
               
   to read in the INODE of /cs360

   NOTE: the number 8 comes from : for FD, blockSize=1024 and inodeSize=128. 
         If BlockSize != 1024, you must adjust the number 8 accordingly.

   From the INODE of /cs360, you can easily determine whether it's a DIR.
   
   (Remember S_ISDIR(), S_ISREG() ?)
  
   If it's not a DIR, there can't be anything like /cs360/is ...., so give up.

   If it's a DIR and there are more components yet to search (BAD NEWS!)
   you must go on.

   The problem now becomes:
       Search for name[1] in the INODE of /cs360
   which is exactly the same as that of Step (6).

8. Since Steps 6-7 will be repeated n times, you should implement a function
 
     int search(INODE * inodePtr, char * name)
         {
            // search for name string in the data blocks of this INODE
            // if found, return name's inumber
            // else      return 0
         }


7. Then, all you have to do is call search() n times, as sketched below.

   Assume:    n,  name[0], ...., name[n-1]   are globals

   ip --> INODE of /

   for (i= 0; i &lt; n; i++){
       inumber = search(ip, name[i])  
       if (inumber == 0) : can't find name[i], BOMB OUT!
       -------------------------------------------------------
       use inumber to read in its INODE and let ip --> this INODE 
   }
  
   // if you reach here, you must have ip --> the INODE of pathname.


8. Extract information from ip --> as required.
   Pat yourself on the back and say: Good Job!

9. EXTRA CREDITS (50%):
   Make your showblock work (CORRECTLY!) for hard disk.

10. SAMPLES SOLUTION in samples/LAB6:
            showblock.bin
    Run it under Linux as
            showblock.bin /dev/XYZ pathname    where XYZ=fd0  for floppy drive,
                                               hda2 for Partition2 of HD, etc.
<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #8</H1>

<Pre>
           CS 360 NOTES #8  Library I/O Functions

1. WHY Library I/O functions?

   Although system calls are the basis for read/write files, they are often
   inconvenient to use. For examples, users may wish to read/write files in 
   logical units most suited to the application, e.g. as lines, chars, etc. 

   Library I/O functions are provided for this purpose. Although not 
   absolutely essential, they provide added convenience and overall 
   efficiency.

2. What are Library I/O functions?

   Almost every OS that supports C also provides Library functions for
   file I/O.  In Unix, Library I/O functions are built on top of the 
   syscall functions. In order to illustrate their intimate relationship, 
   we first list a few of them:
      
    Syscall Functions:  open(),  read(),  write(), lseek(),  close();
    Library Functions; fopen(), fread(), fwrite(), fseek(), fclose();

   From their strong similrities, you can almost guess that every library 
   I/O function has its root in a corresponding syscall function. This is
   indeed the case as fopen() relies on open(), fread() makes use of read(),
   etc. The following C programs illutrate their usage.
       
        System Calls                      Library I/O Functions 
  -----------------------------------|----------------------------------------
   #include &lt;fcntl.h&gt;                |     #include &lt;stdio.h&gt;
                                     | 
   int fd, gd;                       |     FILE *fp, *gp;
   char buf[BLKSIZE];                |     char buf[BLKSIZE];
                                     |
   main()                            |     main()  
   {                                 |     {
     int n, total=0;                 |        int n, total=0;
     fd = open("file1", O_RDONLY);   |        fp = fopen("file1", "r");
     if (fd < 0) exit(1);            |        if (fp == NULL) exit(1); 
     gd = open("file2", O_WRONLY);   |        gp = fopen("file2", "w");
     if (gd < 0) exit(2);            |        if (gp == NULL) exit(2);
     while (n=read(fd, buf, BLKSIZE))|        while (n=fread(buf,1,BLKSIZE,fp))
     {                               |        {
        write(gd, buf, n);           |             fwrite(buf, 1, n, gp);
        total += n;                  |             total += n;
     }                               |        }
     printf("total=%d\n:,total);     |        printf("total = %d\n", total);
                                     |
     close(fd); close(gd);           |        fclose(fp); fclose(gd);
   }                                 |    }  
   ----------------------------------------------------------------------------

    Both programs copy file1 to file2. Since you already know how syscalls
    work, we shall only discuss the program that uses Library I/O functions.

    (1). fopen() uses a string for Mode, where "r" stands for READ, "w" for 
         WRITE. It returns a pointer to a FILE structure. The FILE structure 
         contains a buffer, whose size usually matches that of BLKSIZE. In 
         addition, it also has pointers, counters and status variables for 
         manipulating the buffer.

         fopen() first allocates and initialize a FILE structure in (heap area
         of) the UserImage. It then issues an open() syscall for the file. If 
         the open() syscall succeeds, it records the returned fd in the FILE 
         structure, and returns a pointer to the FILE structure. Otherwise, it
         frees the FILE structure and returns a NULL pointer.

         It is important to note that the FILE structure, which is allocated/
         freed dynamically, is in the process' UserImage. This means that calls
         to Library I/O functions are ordinary function calls, not syscalls.  
         
    (2). The programs terminates if any of the fopen() calls has failed. As 
         mentioned above, fopen() returns a NULL pointer on failure.

    (3). Then it uses a while loop to copy the file.  Each iteration of the
         while loop tries to read BLKSIZE bytes from the source file, and 
         write n bytes to the target file, where n is the returned value from 
         fread().

         The general forms of fread() and fwrite() are

                 n = fread(buffer, size, nitems, FILEptr);
                 n = fwrite(buffer,size, nitems, FILEptr);
         
         where size is the data object size in bytes,  nitems is the number of 
         data objects to be READ or WRITTEN, and n is the actual number of 
         objects read or written. These functions are intended for R/W 
         structured data objects. For example, suppose that the buffer area 
         contains data objects of the type
                     struct OBJECT{.....}
         We may use 
                 n = fwrite(buffer, sizeof(struct OBJEC), M, FILEptr);
         to wirte M objects to a file.  Similarly,
                 n = fread(buffer, sizeof(struct OBJECT), N, FILEptr);
         reads N such objects from a file.

         The above program tries to read/write BLKSIZE bytes at a time. So, it
         has size = 1 and nitems = BLKSIZE. As a matter of fact, any comination
         of size and nitems such that size*nitems = BLKSIZE would also works. 
         However, using a size > 1 may cause problem on the last fread() 
         because the file may have fewer than size bytes left. In that case, 
         the returned n is zero but there are still bytes remaining. To deal 
         with the "tail" part of the surce file, we may add the following 
         lines of code after the while loop:
                 
                 fseek(fp, (long)total, 0);
                 n = fread(buf, 1, size, fp);
                     fwrite(buf,1, n, gp);
                 total += n;
         
         fseek() works in exactly the same way as lseek(). It positions the 
         file's R/W pointer to the byte location total. From there, we read 
         the file as 1-byte objects. This will read all the remaining bytes 
         and write them to the target file.

    (4). After the copying is done, both files are closed by calling fclose().


3. Algorithms of fread(), fwrite() and fclose()

3-1. The algorithm of fread() is as follows:

     (1). On the first call to fread(), the FILE structure's buffer is empty.
          fread() uses the saved file descriptor fd to issue a
                  n = read(fd, fbuffer, BLKSIZE);
          syscall to fill the local fbuffer. Then, it initializes fbuffer's 
          pointers, counters and status variables to indicate that there is a 
          block full of data in the local buffer.
          It then tries to satisfy the fread() call from the local buffer by 
          copying data to the program's buffer area. If the local buffer does 
          not have enough data, it issues additional read() syscalls to fill 
          the local buffer, until the needed number of bytes is satisfied (or 
          end of file is reached). After copying data to the program's buffer 
          area, it updates the local buffer's pointers, counters, etc. getting
          ready for next fread() request.  It then returns the acutal number of
          objects read to the calling place.

     (2). On each subsequent call to fread(), it tries to satisfy the call from
          the FILE structure's local buffer. It issues a read() syscall to 
          refill the local buffer whenever the buffer becomes empty.

          Thus, fopen() accepts calls from user program on one side and issues
          read() syscalls to the Kenrel on the other. Except for the read() 
          syscalls, all processing of fread() are performed in the User Mode. 
          It enters the Kernel mode only when needed and it does so in a way 
          that matches the Kernel's behavior for best efficiency. It provides 
          automatic buffering mechanism so that user programs do not have to 
          worry about such detailed operations.

3-2 fwrite():
 
     The algorithm of fwrite() is similar to that of fread() except for the 
     data movement direction.  Initially the FILE structure's local buffer is 
     empty. On each call to fwrite(), it writes data to the local buffer, and 
     adjust the buffer's pointers, counters and status variable to keep track 
     of the number of bytes in the buffer. If the buffer becomes full, it 
     issues a write() syscall to write the entire buffer to Kernel. 
     
3-3. USE syscalls OR Library Functions?
          
     Based on the above discussion, we can now answer the question of whether 
     to use syscalls or Libray functions to do file I/O?

     fread() relies on read() to copy data from Kernel to the local buffer,
     from which it copies data to the program's buf area. In contrast, read() 
     copies data from Kernel directly to the program's buf area.  Thus, for 
     read/write data in units of BLKSIZEs, read() is inherently more efficient
     than fread() because it only needs one copying operation instead of two. 
     Therefore, in the above C programs, the one that uses syscalls is actually
     more efficient than the other that uses Library I/O functions.  However, 
     if the read/write is not in units of BLKSIZE, fread() and fwrite() may be
     far more efficient. For example, if we insists on R/W one byte at a time,
     fread() and fwrite() would be far better because they enter Kernel Mode 
     only to fill or flush the local buffer, not on every byte. Here, we have 
     implicitly assumed that entering Kernel mode is more expensive than 
     staying in User mode. This is indeed true. 

3-4. Algorithm of fclose():

     fclose() first flushes the local buffer if the file was opened for WRITE.
     Then it issues a close() syscall to close the file descriptor.  Finally 
     it frees the FILE structure and resets the FILE pointer to NULL.

3-5. Other Modes for fopen():

     The Mode parameter in fopen() may be specified as

       "r", "w", "a" : for READ, WRITE, APPEND, or with a +, which means to 
                       create the file if it does not exist.
       "r+" : for R/W, without truncating the file.
       "w+" : for R/W, but truncate the file first.
       "a+" : for R/W by appending.

     However, when a file is fopened for both R/W, there may be restrictions on
     the use of mixed fread() and fwrite() calls. The specification requires 
     that at least one fseek() or ftell() be used between every pair of fread()
     and fwrite(). 

     Example: This program yields different results when run under HP Unix and 
              Linux.

              #include &lt;stdio.h&gt;
              FILE fp; char buf[1024]; 
              main()
              { 
                  fp = fopen("t.c", "r+");   /* for both R/W */
                  fread(buf, 1, 20, fp);     /* read 20 bytes */ 
                  fwrite(buf,1, 20, fp);     /* write to the same file */
              }


     Linux gives the right result, which modifies the bytes from 20 to 39. But
     HP Unix appends 40 bytes to the end of the original file.

     The difference stems from the non-uniform treatment of R/W pointers in the
     two systems.  Recall that fread()/fwrite() issue read()/write() syscalls
     to fill/flush the local buffer.  While read()/write() use the R/W pointer 
     in the file's OFTE, fread()/fwrite() use the local buffer's R/W pointer in
     the FILE structure.  Without a fseek() to synchronize these two pointers,
     the results depend on how are they used in the implementations. In order 
     avoid any inconsistencies, follow the man pages. For the example program, 
     the results become idnetical (and correct) if you insert a line

                  fseek(fp, (long)20, 0);

     between the fread() and fwrite().

4. Additional Library I/O functions:

4-1. Line mode I/O:
          retString = fgets(buf,nchars,fp); 
          retString = fputs(string,fp);
     Examples:
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          char buf[256]; char *s="this is a string";
          main()
          {
             fp = fopen("source", "r");
             gp = fopen("target", "w");
             fgets(buf, 256, fp);    /* read a line of upto 255 chars to buf */
             fputs(buf, 256, gp);    /* write string to target file */

          }
    
     When fp is stdin or stdout, fgets() and fputs() are shortened to
             gets(buf);     /* assume char buf[] is big enough */
             puts(string);  /* print string to stdout */

4-2. Char Mode I/O:
          int c;         /* NOTE the int type */       
          c = getc(fp);  /* get a char from fp, return EOF on end of file */
              ungetc(c, fp); /* push c back to stream */

          putc(c, fp);   /* put a char to fp */
     
     The reason for the int type of c is that the EOF symbol is usually an int
     value. 

   For fp = stdin or stdout,  c = getchar();  putchar(c); may be used instead.
   For run time efficiency, getchar() and putchar() are often NOT the shortened
   versions of getc() and putc(). Instead, they may be implemented as Macros
   in order to avoid an extra function call.
   Examples:

     (1). /* file copy using getc(), putc() */
          #include &lt;stdio.h&gt;
          FILE *fp,*gp;
          main()
          {
            int c;  /* for testing EOF */
            fp=fopen("source", "r");
            gp=fopen("target", "w");
            while ( (c=getc(fp)) != EOF )
               putc(c,gp);
            fclose(fp); fclose(gp);
          }

    (2). /* Linux's man pages contain lots of 0x08 code. It is used as follows:
             0x08TT0x08HH0x08II0x08SS  high light the word THIS.
             t_0x08h_0x08a_0x08t_0x08  display the _ under that.
             However, a _ not immediately followed by 0x08 is part of the text.

             The following program eliminates the 0x08 code from the outputs 
             of man. EXPLAIN HOW DOES IT WORK ? */

             #include &lt;stdio.h&gt;
             main()
             {  int c, nextc;
                while ( (c=getchar()) != EOF ){
                   if (c == 0x08){
                       c = getchar();
                       continue;
                   }
                   if (c == '_'){
                       nextc=getchar();
                       if (nextc == 0x08)
                       continue;
                       ungetc(nextc,stdin);
                   }
                   putchar(c); 
                }
             }


4-3. FORMATTED I/O:
     These are perhaps the most commonly used I/O functions.
     Foratted Inputs: ( FMT=format string )
                      scanf(FMT, &items);    /* from stdin */     
                     fscanf(fp, FMT, &items);
                     sscanf(buf,FMT, &items);  
     Formatted Outputs:     
                      printf(FMT, items);   /* to stdouot */
                     fprintf(fp, FMT, items);
                     sprintf(buf,FMT, items);
     
     Note that sscanf() and sprintf() are not really I/O functions but
     string assemble/extraction funcions.
      

4-4. Other Functions:

     fseek(), ftell(), rewind()
     feof(), ferr(), fileno()

     freopen(), fdopen()
     setbuf(), setvbuf()
     popen()
   





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 HELP #5</H1>

<Pre>
   
            360 PROJECT HELP :  HOWTO_MKDIR_CREATE

make_dir()
{
1. Ask for a pahtname, e.g. /a/b/c  or a/b/c, etc.

2.  if (pathname[0] == '/') 
        dev = root->dev;
     else
        dev = cwd->dev;
3. Let  
     parent = dirname(pathname);   parent= "/a/b"
     child  = basename(pathname);  child = "c"

4. Get the In_MEMORY minode of parent:

         ino  = getino(&dev, parent);
         pip  = iget(dev, ino); 

   Then, verify :
         parent INODE is a DIR AND
         child des NOT exists in the parent directory;
               
5. Call 
          r = mymkdir(pip, child);
 
6.  return(r);

} 


int mymkdir(MINODE *pip, char *name)
{
1. pip points at the parent minode[] of "/a/b", name is a string "c") 

2. allocate an inode and a disk block for the new directory;
       call   inumber=ialloc(dev),      bnumber=balloc(dev)
   where dev=pip->dev, i.e. SAME dev as the parent directory.

3. call mip = iget(dev,inumber) to load the inode into a minode[] (in order to
   wirte contents into the intended INODE in memory).

4. Write contents into mip->INODE, including:
        (same as the root directory in mkfs)
        INOODE.i_block[0] = bnumber; 
        all other INODE.i_block[] = 0;
        mip->dirty = 1;  /* mark dirty */

5. call  iput(mip);  
   which should write the new INODE out to disk.

  // C CODE:
  //**********************************************************************
  mip = iget(dev,inumber);

  mip->INODE.i_mode = 0x41ED;		/* DIR and permissions */
  mip->INODE.i_uid  = running->uid;	/* Owner Uid */
  mip->INODE.i_gid =  running->gid;	/* Group Id */
  mip->INODE.i_size = 1024 ;		/* Size in bytes */

  mip->INODE.i_links_count = 2;	/* Links count */

  mip->INODE.i_atime=mip->INODE.i_ctime=mip->INODE.i_mtime = time(0L); 

  mip->INODE.i_blocks = 2;     	/* Blocks count in 512-byte blocks */
  mip->dirty = 1;               /* mark dirty */

  for (i=0; i<15; i++)
    mip->INODE.i_block[i] = 0;
  mip->INODE.i_block[0] = znumber; 

  iput(mip);
  //**********************************************************************


6. Write the . and .. entries into a buf[ ] of BLOCK_SIZE; 
   write buf[] to the disk block allocated to this directory;

// C CODE:
//****************************************************************  
  dp = (DIR *)buf;

  dp->inode = inumber;		/* Inode number */
  strncpy(dp->name, ".", 1);    /* File name */
  dp->name_len = 1;		/* Name length */
  dp->rec_len = 12;		/* Directory entry length */

  cp = buf; 
  cp += dp->rec_len;            /* advance by rec_len */
  dp = (DIR *)cp;

  dp->inode = parent->ino;      /* Inode number of parent DIR */
  dp->name_len = 2;		/* Name length */
  strncpy(dp->name, "..", 2);   /* File name */
  dp->rec_len = BLOCK_SIZE - 12;/* last DIR entry length to end of block */

  put_block(dev, bnumber, buf);


7. Finally, enter name into parent's directory 
   Read parent's data block into buf[];

     !!! LISTEN TO LECTURE CAREFULLY ON HOW TO DO THESE !!!:

// EXT2 DIR entries: Each DIR entry has rec_len and name_len.
// (1). rec_len = name_len+8 raised to the next multiple of 4 bytes.
//      So,       ideal_len = [(name_len + 8 + 3)/4] * 4
// (2). When deleting an entry, first zero out its inode number, then absorb
        its rec_len to the previous entry's rec_len ==> which effectively
        "hides" the deleted entry.

        If the deleted entry is the first in a data block, then there is no
        previous entry to absorb its rec_len. However, the entry is "deleted"
        since its inode number is zero. The idel_len of such entries is 0.

// (3). (2) ==> when entering a name into DIR, should look for an entry whose
//      rec_len - ideal_len >= new entry's ideal_len. Then, reduce this entry's
//      rec_len to its ideal_len and enter the new entry in the remaining space

//      The new entry's rec_len = remain = this entry's (rec_len - ideal_len).
// (4). When scaning a DIR block, must check for block ending; allocate new
//      data block if needed.


(As said before, you may assume directories only have direct data blocks.)
        
8. Write parent's data block back to disk;

9. inc parent inodes's link count by 1; touch its atime and mark it DIRTY

10. iput(pip);

}  

creat_file()
{
  This is similar to mkdir() except : its inode's mode field is set to
  a REGULAR file, permission bits to (default) rw-r--r--, and no data 
  block is allocated for it.
} 


int mycreat(parent,name) MINODE *parent; char *name;
{
    Same as my_mkdir() except NO data block and do NOT inc parent's link count.
}  




<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 HELP INFO</H1>
<Pre>
   
                 HOWTO_MOUNT_UMOUNT

// ASSUME: newfs  is a file containing an EXT2 filesys image.

mount()    /*  Usage: mount filesys mount_point OR mount */
{

1. Ask for filesys (a pathname) and mount_point (a pathname also).
   If mount with no parameters: display current mounted filesystems.

2. Check whether filesys is already mounted: 
   (you may store the name of mounted filesys in the MOUNT table entry). 
   If already mounted, reject;
   else: allocate a free MOUNT table entry (whose dev == 0 means FREE).

3. open filesys for RW; use its fd number as the NEW dev;
   Check whether it's an EXT2 filesys: if not, reject.

4. find the ino, and then the minode of mount_point:
    call  ino  = get_ino(&dev, pathname);  to get ino:
    call  mip  = iget(dev, ino);           to load its inode into memory;    

5. Check mount_point is a DIR.  
   Check mount_point is NOT busy (e.g. can't be someone's CWD)

6. Record NEW dev in the MOUNT table entry;

   (For convenience, store the filsys name in the Mount table, and also
                     store its ninodes, nblocks)

7. Mark mount_point's minode as being mounted on and let it point at the
   MOUNT table entry, which points back to the mount_point minode.

8. return 0;

}
  

umount(filesys) char *filesys;
{

1. Search the MOUNT table to check filesys is indeed mounted.

2. Check whether any file is still active in the mounted filesys;
      e.g. someone's CWD or opened files are still there,
   if so, the mounted filesys is BUSY ==> cannot be umounted yet.
   HOW to check?      ANS: by checking all minode[].dev

3. Find the mount_point's inode (which should be in memory while it's mounted 
   on).  Reset it to "not mounted"; then 
         iput()   the minode.  (because it was iget()ed during mounting)

4. return(0);

}  
  

                  IMPLICATIONS of mount:

With mounting, you must modify the
 
               ino = get_ino(&dev, pathname)

function to support "cross mounting point" operations.

Assume :    mount newfs /a/b/c   ==> newfs has been mounted on /a/b/c.
 
Case 1: When traversing the pathname /a/b/c/x/y, once you reach /a/b/c,
        you should see that /a/b/c has been MOUNTed on (because its mounted
        flag = 1). You should

        Use the minode's mountTable pointer to locate the MOUNT table entry.
        From newfs's  dev number, you can get its / inode into memory.
        THEN, continue to look for x/y under this / inode.

Case 2: Assume that you are at the directory
               /a/b/c/x/
        and you are trversing upward. e.g.
               cd  ../../
        which will cross mount point at /a/b/c.
        THINK ABOUT HOW TO HANDLE THIS CASE. LISTEN TO LECTURE.

<TITLE>CS360 NOTES#2</Title>
<Body bgcolor="#00CCCC" text="#000000">

<H1>CS360 NOTES #1 : Introduction to Unix</H1>

<Pre>

1. The Unix File System Tree:
   The Unix file system is organized as a tree, as shown below.


            |--> bin 

            |--> dev

            |--> etc

     / ---> |--> lib

            |--> sbin
                           |--> bin
            |--> tmp       |--> include --> .h files 
                           |--> lib
            |--> usr ----->|--> local
                           |--> man
            |--> user      |--> X11 ------>
       
            |--> vmunix 


   Each NODE of the tree is a FILE. Unix files have the following types:

2. Unix File Types:

   (1). Directory files : 
        These are directories. A directory may contain other directories 
        and (non-directory) files.

   (2). Non-directory files : 
        Non-directory files are either REGULAR or SPECIAL files (SEE BELOW).
        Note that Non-directory files can only appear as leaf-nodes in the 
        tree.

        (2).1  REGULAR files : 
               Regular files are also called ORDINARY files. They contain 
               either ordinary text or executable binary codes.

        (2).2  SPECIAL files : 
               Special files are entries in the /dev directory. They represent
               I/O devices, and are further classified as . 

               CHAR  special files, e.g. /dev/tty0, /dev/modem.
               BLOCK special files, e.g. /dev/fd0,  /dev/hda.
               Other types such as Network special files.

   (3). Soft LINK files:
        These are Regular files whose contents are pathnames of other 
        files. As such they are used to reference other files.
        Example: the Unix command
                 ln   -s   aVeryLongFileName   myLink
        sets up  myLink  as a soft-link to  aVeryLongFileName.  Access to 
        myLink will be re-directed to the actual file aVeryLongFileName.

3. Pathname:

   The ROOT node of a Unix file system tree, symbolized by /, is called the 
   "root directory".

   Each node of the tree is represented by a PATHNAME of the form

             /a/b/c/d    OR    a/b/c/d

   So, each Unix file is specified by a pathname.

*   A pathname is ABSOLUTE if it begins with a /.  
*   A pathname is RELATIVE if it does not begin with a /. 
 
    A relative pathname starts from the Current Working Directory (CWD).
    When a user login to Unix, the CWD is usually set to his/hers HOME 
    directory.  The CWD can be changed by using the cd  command.  
    The pwd command prints the absolute pathname of the CWD.
            
4. Contents of Directories Under / :  

   /bin : commonly used system commands, e.g ls, date,...
   /dev : Special files.
   /etc : Unix system maintenance files.
   /lib : Unix system libraries.
   /sbin: Unix system administration commands.
   /tmp : temporary files.
   /usr : /usr/bin:      more executable files such as  cc,  gzip.
          /usr/include : .h files
          /usr/lib:      specific library files.
          /usr/man     : on-line manual directory.
          /usr/X11     : X-Window system.

   /user: user home directories.
   /vmunix : bootable Unix system image file.


5. Login Process:

(1). User Account:
     Each user is assigned an account by the system administrator. In a stand-
     alone Unix system, user accounts are maintained in a file named     
                        /etc/passwd.
     In a network system composed of many Unix machines, such information is 
     usually maintained on a Server machine, which provides other Unix machines
     with a single copy of the user account information. 
 
     A user account typically contains the following fields, separated by :

     root:aXuoPkB4hz:0:0:root:/root:/bin/bash
     kwang:Pir2NYB4Bqi9I:501:100:k.c.wang,cs faculty:/home/kwang:/bin/bash
     ----- ----------------- --- ------------------- ----------- --------------
  username: password :gid:uid:    full name      : HOME dir  : programToExecute

(2). Login Process:
     
     A PROCESS is a sequence of executions regarded as a single entiry by the 
     system. In Unix, every activity is carried out by a process.  
     When Unix starts, it generates a special process, P1, which executes the 
     file   /etc/init.  For this reason, P1 is also called the INIT process. 
     It is the parent of all user processes in the following manner:

     P1 reads some system configuration files to find out the terminals 
     supported by the system.  For each terminal, it generates a child process 
     on that terminal. Then, it waits for any of the terminal process to 
     terminate.  When a terminal process terminates (by user logout), P1 
     regenerates another child process on that terminal. 

     Each child process opens 3 (stream) FILEs on its own terminal. These FILEs
     are known as 

          stdin : the terminal's Keyboard, for inputs;
          stdout: the terminal's Display, for outputs;
          stderr: also the Display, for error outputs;

     Then the child process executes /etc/getty, which displays the message  
          login:  
     on its stdout, awaiting a user to login.  
     At this moment, the login process is not yet associated with any user.

     When a user tries to login, the login process validates his/her username 
     and password in /etc/passwd. If the user has a valid account, the login 
     process takes on the user's uid and gid, thereby becoming the user's 
     process.  It then sets the CWD to the user's HOME directory and executes 
     the program specified in the user's account. That program is usually a 
     version of the Unix shell, e.g. bash, csh, etc.
    
     The Unix shell is a command interpreter.  It displays a prompt
         %     (OR some other symbol, which can be set by the usr)
     and waits for the user to input commands.

     A command is simply an executable program. When the user enters a command,
     the sh process (i.e. the user process that's executing the sh) will

       (1). generate a child process to perform the command;
       (2). wait for the child process to terminate;
       (3). prompt the user for commands again;  
            The sh process terminates when it sees logout or END_OF_FILE.
   
     NOTE that the command is NOT executed by sh itself but by a child process.

     Using this feature of sh, a user can start many processes, each performing
     a different task.  For example, the command (line)

            %   ls & date & a.out  &
                --   ----   ----- ----- 
                C1    C2     C3   NoWait

     will start 3 children processes, C1, C2, C3, which execute ls, date, a.out
     respectively, and cause the sh to prompt again without waiting for any of
     the child processes to terminate.  This is called MULTI-TASKING.

     In this example, all 4 processes will run CONCURRENTLY (which means IN 
     PARALLEL in a logical sense). Among them, the sh runs in the FOREGROUND 
     while others run in the BACKGROUND.  Only the foreground process can 
     receive inputs from stdin.
     The  fg  command can be used to raise a background process to foreground.
     The  ps  command displays all the ProcessId (PID) of a user.


6. REVIEW QUESTIONS:

(1). The   ls -l   command lists the contents of a directory:

drwxr-xr-x   root   bin     2048  Dec 23 09:22 bin/
lrwxrwxrwx   root   root      23  Dec 20 20:15 kwang -> /home/kwang/public_html
-rw-r--r--   root   root  433387  Dec  8 21:52 vmlinuz
-rwxr-xr-x   kwang  kwang  21400  Jan 10 07{30 a.out

EXPLAIN THE MEANING OF EACH field?

(2). What are the permission bits of a file, and what do they do?
     
(3). Each user has a UserId (uid) and a GroupId (gid).  
     How does a user get hid/her uid and gid?
     What are the uid and gid used for? 

(4). The owner of a file can use the Unix command
         chmod  0766  fileName  
     to change the mode of fileName. What are the resulting permissions?

(5). What does the x bits of a directory mean?

(6). Unix has a special user, called the SuperUser or the Root, who can access
     any file. What's the reason for having such a Super user?

(7). How does a user acquire a Unix process?

(8). How many processes will be executing with the sh command?
         %  a & b & c & d &
     Which one is the foreground process?

(9). The Unix command    ls | more
     sets up 2 processes, one executes ls and the other executes more, in such 
     a way that the outputs of the first process ls are PIPEd to the second 
     process more. 
     How many processes will be executing with the sh command?
         %  a | b | c | d 
 








<TITLE>CS360 NOTES#3</Title>
<Body bgcolor="#00FFCC" text="#000000">

<H1>360 NOTES #2 : PROGRAM DEVELOPMENT</H1>

<Pre>

1. OBJECTIVES
   To understand the steps involved in program development.

2. THE STEPS:

(1). Source file : A text editor, such as vi or emacs, may be used to create
     one or more source program files in some language(s). Typical languages
     are C and Assembly.

(2). Consider C programs first. Let the source of a C program be written as
     two files, t1.c and t2.c,  as shown below:

/********  t1.c file *************************************************/
     extern int g;                      /*  IMPORT g    */
     int      sum;                      /* global variable */
     main(int argc, char *argv[ ])      /* main function */
     {
       int a,b;                         /* local variables */
       a = 1;
       b = 2;
       g = 100;                         /* reference extern variable */
       sum = mysum(a,b);                /* call mysum(), passing a,b */
       printf("sum=%d g=%d\n",sum, g);  /* call printf() */
     }
/**********************************************************************/

/*******  t2.c file **************************************************/
     int g;                             /* global variable  */
     int mysum(int x, int y)            /* function heading */
     {
        return x+y+g;                   
     }              
/*********************************************************************/

(3). To convert these source files into an executable, we typically use the 
     cc command (In Linux, cc is linked to gcc, so they are the same).

        cc  t1.c t2.c       =====> this generates an executable file  a.out

(4). WHAT'S cc or gcc?
     cc is a program, which consists of 3 major steps:
     
     1. Convert C source files to Assembly code files:
        The first step of cc is to invoke the C COMPILER, which translates
        the .c files into .s files containing ASSEMBLY code for the 
        target machine.  

     2. Convert ASSEMBLY Code to OBJECT code:
        Every machine has its own set of machine instructions. Users may 
        write programs in an ASSEMBLY language for a specific machine.

        An ASSEMBLER is a program, which translates assembly code into 
        machine code in binary form. The resulting .o files are called 
        OBJECT code. 

        The second step of cc is to invoke the ASSEMBLER to translate the
        .s files into .o files.

        Each .o file consists of 3 parts:
         
              a CODE section consisting of machine instructions;
              a DATA section consisting of all GLOBAL and static variables; 
              a SymbolTable  containing all variable and function names
                             and their attributes.

     3. LINKING: 
        A program may be composed of several pieces of .o files, which are 
        usually dependent on one another.  In addition, the .o files may call
        C library functions (e.g. printf), which are NOT present.

        The last step of cc is to invoke the LINKER, which puts all the .o 
        files and the needed library functions together into a single 
        executable binary file, a.out. More specifically, the LINKER does the 
        following:

        .Combine all the code sections of the individual .o files into a
         single CODE section,

        .Combine all the data sections into a single DATA section,

        .Use the SymbolTables to resolve the cross references among the
         inidvidual .o files. 

         For instance, when the compiler sees sum = mysum(a,b), it does NOT 
         know where mysum is. So it leaves a blank in the .o file for the
         entry address of mysum. When the linker puts t1.o t2.o together, it 
         knows where mysum is since mysum is recorded in the SymbolTable
         of t2.o. So the linker can replace the blank in t1.o with the address
         of mysum. Similarly for other symbols that are cross referenced.

        If everything goes well, the linker will write the resulting combined 
        file as a.out, which is the executable binary.
 
3. STATIC Vs. DYNAMIC Linking:
   There are two ways to create a.out, known as static and dynamic linking.
   In static linking, the linker includes every needed library function in 
   a.out. This makes a.out self-sufficient but usually very large.
     
   In dynamic linking, the library functions are not included in a.out but 
   calls to such functions are recorded in a.out as a directives to the LOADER.
   When a.out is to be executed, the system LOADER will load both a.out and 
   its needed libaray files into memory. 

   The main advantages of dynamic linking are:
       .The size of every a.out is reduced.
       .Once loaded into memory, the library functions can be SHARED.
      . Modifying library functions does not have to re-linking any a.out file.
 
   This kind of libraries are known as Dynamic Linking Libraries (DLLs).

4. WHAT's in a.out?
   a.out is the executable binary file, which usually has the format:
   ---------------------------------------------------------------------------
     header      : The header of a.out contains its sizes in bytes: 
                       tsize = size of Code section;
                       dsize = size of Data section;
                       bss_size=size of bss section;
                       Needed library functions (if dynamic linked).

     Code Section: this is the combined code area of a.out; it always begins
                   with the standard C startup file crt0.o, which calls main. 

     Data Section: The Data section contains INITIALIZED global and static data
                   objects. Examples of static data are static variables and 
                   format strings in printf(fmt, .....).

     bss (Block Started by Symbol) Section: un-initialized statics and globals
   ---------------------------------------------------------------------------
   NOTE that the bss section is NOT included in a.out. However, its size
   is recorded in the header of a.out as bss_size.

5. Execution of a.out
   The sh command
       %  a.out ONE TWO THREE 
   executes a.out with the strings ONE TWO THREE as command-line parameters.
   As explained before, sh will create a child process to execute a.out.
   
   After creation, The child process does the following

   (1). It reads the header of a.out to determine the Total memroy size needed:
             TotalSize = tsize + dsize + bss_size + stackSize
        where the stackSize is usually a default value of say, 4K bytes.

   (2). It then allocates a memory area of TotalSize bytes. Conceptually, we
        may assume that the allocated memory area is a single piece of
        contiguous memory. It then loads a.out (without the header) into this 
        memroy area, with the Code section at the Low address end. The High
        address end will be the stack area. Thus, the stack grows downward.

   (3). The main() function of  a.out  may be written as 
              main(int argc, char *argv[ ], char *env[ ])
        As will be shown later, parameters are passed through the stack. 

   (4). It then starts to execute crt0.o, whcih calls main().
  
   (5). The execution image of a process is shown by the figure:

            LowAddress                                 HighAddress 
                      |  CODE  |  DATA | HEAP | STACK |

        where the HEAP is for dynamic memory allocations (by malloc() in C or
        new() in C++) and STACK is the run-time stack.
        Subject to a certain maximum size limit, both HEAP and STACK may be 
        expanded automatically by the Unix operating system.

   (6). Termination:
        The process that executes a.out may terminate in ONE of 4 ways:

        1. The process calls exit(bye_value), which does some clean-up work 
           (such as flush stdout, close I/O stream FILEs) and then issues an 
           _exit(value) system call, which causes the process to enter the Unix
           Kernel to die. For instance, when the process return from main() to
           crt0.o, it calls exit(0). Alternatively, the process may call
           exit(byte_value) anywhere in a.out to terminate (without going back
           to crt0.o). 

        2. Inside a.out, the process may call _exit(value) anywhere to enter 
           Kernel to die IMMEDIATELY. Reason: if you want to die in a such a 
           hurry, why bother to clean up your room first?
           
           When a process dies, it records the byte_value in the _exit() call
           as the "cause of death" on its body, notifies its parent that it is
           dying and then becomes a ZOMBIE. The parent (either the original 
           parent or P1) will find the ZOMBIE, get its pid and "cause of death"
           value via the 
                         dead_child_pid = wait(&cause_of_death);
           system call, where cause_of_death has 2 bytes containing
                              |exitValue|signal#|
           Naturally, only one of the bytes would be non-zero, WHY?

        3. While executing, the process encounters an error (in YOUR a.out of
           course), which is recognized and "caught" by the CPU. The process is
           forced into the Unix kernel by a "trap". Once in kernel, it converts
           the trap error (type) into a magic number called a SIGNAL number and
           delivers the signal to itself, causing it to die. In this case, the
           ZOMBIE's "cause of death" is the signal number, and we may say that
           the process has died abnormally. 

           Examples: Try to run these C programs
                      int *p;
                      main(){   *p = 1;  }

                      int a,b,c;
                      main(){   c = a/b; }

                      main(){   main();  }

           What do you see and WHY?


        4. Killed by a signal, which may originate from hardware (interrupts)
           or sent by another process via the 
                      kill pid 
           command, which uses the kill(pid, singal#) system call.
           Example:  If you run the C program:
                        main()
                        {
                           while(1);
                        }       
           What would happen and how do you get out the mess?





<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #3</H1>

<Pre>
            360 NOTES #3 Function Calls in C

Consider the program:

         main()
         { int a,b,c;
           a = 1; b = 2; c = 3;
           c = mysub(a,b);
           printf("c=%d\n", c); 
         }

         int mysub(int x, int y)
         {
           int u, v;
           u = 4; v = 5;
           return(x+y+u+v);
         }

The topics here are:
     ----------------------------------------------
     Function call conventions in C and stack usage.
     ----------------------------------------------

(1). When we execute a.out, a process image is created in memory, which looks 
     (logically) like the following:
   
     lowAddress                      HighAddress
          -----------------------------
          | Code | Data |  stack      |
          ----------------------------- 
(2). CPU registers:

     Every CPU has:

        PC register, which points to the next instruction
                     to be executed by the CPU.
        SP register, which points to the current top of 
                     the stack. (esp register)
        FP register, which points to the stack Frame of the
                     current active function (ebp register).
        A register for return value (eax register).

(3). Our main() is called by the C startup code, crt0.o. When crt0.o calls 
     main(), it pushes the return address (its current PC contents) onto stack,
     and enters main(). When main() is entered, the stack contains:

     HighAddress      ---------->              LowAddress
  
       --------------------------------------------- 
       XXXX|PC|
       --------------------------------------------- 
            ^ 
            SP 

     with SP pointing at the returnPC (where crt0.o called main().

(4). Upon entry, every C function does the following
     (4).1  push FP into stack;   this saves the FP register
     (4).2  let  FP point at the stack top, i.e. point at the saved FP.
     (4).3  shift SP downward to allocate space for local variables.
   
     For this example, there are 3 local variables, a,b,c, each 4 bytes long. 
     The stack becomes:

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  |
       --------------------------------------------- 
               ^         ^ 
               FP        SP 
               
(5). a=1; b=2; c=3;  The values 1,2,3 go to the locations of a,b,c, which are
     at -4, -8, -12 bytes from where FP is pointing at, respectively. 
     These are expressed as -4(FP), -8(FP), -12(FP) in assembly code.

(6). main() calls mysub() by  c = mysub(a,b);

     The compiled code for the function call consists of:

         PUSH parameters in reverse order:
              push b's value onto stack, push a's value onto stack,
         CALL mysub
              which pushes the current PC (contents) onto stack and replaces PC
              with the address of mysub, causing the CPU to enter mysub().
 
     When control just enters mysub(), the stack becomes

     HighAddress      ---------->              LowAddress
                  a  b  c 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  | 2| 1|PC|
       --------------------------------------------- 
                                  ^ 
                                  SP 

(7). mysub() is written in C.  Its actions are the same as those of main():
        push FP; 
        let FP point at the saved FP, and
        shift SP downward to allocate locals u,v. 
     Then the stack becomes
         
     HighAddress      ---------->              LowAddress
                  a  b  c               u  v 
       --------------------------------------------- 
       XXXX|PC|FP|  |  |  | 2| 1|PC|FP|  |  |
       --------------------------------------------- 
                                     ^     ^ 
                                     FP    SP 
(8). While in mysub(), 
 
               -----------------------------
               WHERE ARE x,y? WHERE ARE u,v?
               -----------------------------

     For this example, the parameters a, b are at 8(FP) and 12(FP), i.e at 
     where FP points at + 8 bytes, + 12 bytes.  Local variables u, v are at 
     -4(FP) and -8(FP).

     The stack area visible to a function (parameters and locals) is called 
     a stack FRAME (like a frame of movie). Thus, FP is called the stack
     FramePointer.
 
(9). Return from called function:

     When mysub executes return(expression); it puts the value of the 
     expression in the return value register (eax for 486/Pentinum CPUs).
     Then, it deallocates the local variables by

       .copy FP into SP;   stack top now contains the saved FP.
       .pop stack into FP; this restores FP, leaving the return PC on top of 
                           the stack.
       .RET   RET pops the stack top into PC register, causing the CPU to 
              execute from the "return address" saved earlier.

(10). Upon return, the caller function copies the contents of the return value
      register into c, then it pops the parameters a,b off the stack (by adding
      8 to SP). This restores the stack to the same situation before the call.
  
      Then it continues to the next statement.





<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                HOWTO open_close_lseek

int open_file()
{
  1. ask for a pathname and mode to open:
         You may use mode = 0|1|2|3 for R|W|RW|APPEND

  2. get pathname's inumber:
         ino = getino(&dev, pathname);

  3. get its Minode pointer
         mip = iget(dev,ino);  

  4. check mip->INODE.i_mode to verify it's a REGULAR file and permission OK.
     (Optional : do NOT check FILE type so that we can open DIRs for RW)
     
     Check whether the file is ALREADY opened with INCOMPATIBLE type:
           If it's already opened for W, RW, APPEND : reject.
           (that is, only multiple R are OK)

  5. allocate an OpenFileTable (OFT) entry and fill in values:
         oftp = falloc();       // get a FREE OFT
         oftp->mode = mode;     // open mode 
         oftp->refCount = 1;
         oftp->inodeptr = mip;  // point at the file's minode[]

  6. Depending on the open mode 0|1|2|3, set the OFT's offset accordingly:

      switch(mode){
         case 0 : oftp->offset = 0; 
                  break;
         case 1 : truncate(mip);        // W : truncate file to 0 size
                  oftp->offset = 0;
                  break;
         case 2 : oftp->offset = 0;    // RW does NOT truncate file
                  break;
         case 3 : oftp->offset =  mip->INODE.i_size;  // APPEND mode
                  break;
         default: printf("invalid mode\n");
                  return(-1);
      }

   7. find the SMALLEST i in running PROC's fd[ ] such that fd[i] is NULL
      Let running->fd[i] point at the OFT entry

   8. update INODE's time field. 
      for W|RW|APPEND mode : mark Minode[] dirty

   9. return i as the file descriptor
}


truncate(MINODE *mip)
{
  1. release mip->INODE's data blocks;
     a file may have 12 direct blocks, 256 indirect blocks and 256*256
     double indirect data blocks. release them all.
  2. update INODE's time field

  3. set INODE's size to 0 and mark Minode[ ] dirty
}
 
      
int close_file(int fd)
{
  1. verify fd is within range.

  2. verify running->fd[fd] is pointing at a OFT entry

  3. The following code segments should be fairly obvious:
     oftp = running->fd[fd];
     running->fd[fd] = 0;
     oftp->refCount--;
     if (oftp->refCount > 0) return 0;

     // last user of this OFT entry ==> dispose of the Minode[]
     mip = oftp->inodeptr;
     iput(mip);

     fdalloc(oftp);   (optional, refCount==0 says it's FREE)
     return 0; 
}

long lseek(int fd, long position)
{
  From fd, find the OFT entry. 

  change OFT entry's offset to position but make sure NOT to over run
  either end of the file.

  return originalPosition
}

int pfd()
{
  This function displays the currently opened files as follows:

       filename  fd  mode  offset
       --------  --  ----  ------ 
       /a/b/c     1  READ   1234       
  
  to help the user know what files has been opened.
}
<Title>360 Week 1 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
	<H1>360 Course Plan</H1>
	<Pre>                CPTS 360 COURSE PLAN
                    
                    Fall, 2008

COURSE TITLE : CPTS 360 Systems Programming

Reference    : Advanced Programming in the UNIX Environment, 
               W. Richard Stevens, Addison-Wesley, 1992.
CLASS NOTES  : www.eecs.wsu.edu/~cs360/

INSTRUCTORS  : K. C. Wang, Professor of EECS, Sloan 321
                           335-3769, kwang@eecs.wsu.edu
                           Office Hours: MW 9:10-10:00 AM
               TA: To be posted
   
PREQUISITES  : CPTS 250
  Basic knowledge and working experience in Unix commands.
  Ability to program in C or C++.

COURSE CONTENTS:
  Introduction to the Unix Operating System: 
     Files, directories, special files, logical organization of 
     Unix file system; user account, login process and command
     execution.

  Program development
     Source files;  compiler, assembler and object files; 
     linker, library and executable files; loader and execution 
     images. Symbolic debugger and run-time support.

  Execution image of C programs
     Code, data and stack segments; function calling convention, 
     stack frames and parameter passing; long jumps.

  File I/O
     System calls and low-level file I/O; open, close, read, write, 
     lseek, file descriptors and file sharing. Execution of User 
     mode and Kernel mode images, implementation and implications 
     of system calls.

  File Control
     Permissions and access control, fcntl, chown, chmod, hard 
     and soft links, file status and statistics. 
     I/O redirection, pipes, filters and applications.

  Standard I/O Library
     Streams and high-level file I/O; user space buffering, 
     relationship with low-level I/O,  char and line mode I/O. 
     Formatted I/O.

  File system implementation
     Inodes and file representation; mkfs and physical file 
     system layout; traversal of the file system tree; booting 
     system images.

  Processes
     Concept and implementation of processes, process execution 
     environment, user mode and kernel mode images, process
     states transitions. Processes in the Unix system; init, 
     login and user processes.

  Process Control
     fork, vfork, wait, exit, kill, exec operations. traps and 
     signal handling.

  Process Synchronization and Communication
     Signals, pipes, semaphores, messages and shared memory 
     segments. Sockets.
   
  Networking
     Introduction to Internet; host, address resolution, 
     routing; protocols, client and server; ftp, rlogin, nfs, 
     and nis, Socket Programming. 

  Project: Implement an ETX2 File System Simulator

  Misc Topics: sh and Perl programming, Unix system adm. 

COMPUTER SYSTEMS: (Sloan 327) 
     Pentinum based PCs running Linux.
     Other HP Unix systems and work stations for general usage.

LABORATORY: 
     Time : Wed 7:10-10 PM Place: Sloan 233
     (Firt Week: NO LAB)
---------------------------------------------------------------------
GRADING:
   Exam                      %30  (Date and form will be set later).
   Programming Assignments   %30
   Project                   %40   
---------------------------------------------------------------------

</Pre>
</Body>
<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes </H1>

<Pre>
         Lab #4 Pre-work: DUE: Sept 24, 2008 in Lab


Download the server.c andd client.c files for samples/LAB4.
Compile and test run the server and client on IP hosts.
============================================================
MODIFY the programs to do the following :
       client : send 2 numbers to server
       server : return the SUM of the 2 numbers to client
===========================================================
<Title>360 PROJECT FILE</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT</H1>
<Pre>
                    CPTS 360 PROJECT

               Date Assigned: Oct 13, 2008

 *****************************************************************************
  1.   DUE and DEMO: Wednesday to Thursday in Close Week.
       Sign up for demo time slots. Turn in a floppy disk AND a hard copy.
  2.   May work in 2-person teams. However, a comprehensive ORAL exam will 
       be given to EACH individual during the DEMO.  The ORAL exam score 
       will be a major part of your FINAL grade.
 ****************************************************************************

                     A. OBJECTIVE:
   Design and implement a Linux EXT2 file system simulator. 

                     B. SPECIFICATIONS:
1. Files:
   Files are exactly the same as they are in the Linux file system, i.e.
   we shall use the same EXT2 file system data structures for

      SuperBlock, GroupDescriptor, Bit-maps, Inode, Directory

   EXCEPTIONS:
      Only DIR and REG file types; no SPECIAL files.
      File size : No triple-indirect blocks.
      
   
2. Disks:
    Disks are REAL floppy disks OR "virtual disks" simulated by Linux files.  
    Disk I/O are simulated by Linux read()/write() operations on a BLKSIZE 
    basis. You may use Linux's, mkfs (mke2fs) to create EXT2 file systems.

3. File names:
   As in Unix, each file is identified by a pathname, e.g. /a/b/c or x/y/z.

   If a pathname begins with "/",  it's relative to the / directory.
   Otherwise, it's relative to the Current Working Directory (cwd) of the 
   running process (see Processes below). 

4. Processes:
   Every file operation is performed by a process. A process has a unique uid and pid.
   The simulator starts with TWO processes:
       A process P1 with uid=0 (for SUPERUSER), and
       A process P2 with uid=1 (for ordinary user).
   The initial CWD of both processes are initially /
  
   P1 runs first. P2 is in a readyQueue, which contains ALL processes
   that are ready to run.

   All processes executes the same code (i.e. the Simulator), in which it

       loop forever{
            prompt for a command;
            execute the command;
       }
 
   Each command is performed by the current running process. 
   
   Process management commands are:

      switch : switch process (to run another READY process).

      fork : create a child process with the SAME uid (and its own pid).
             As in Unix, the child process shares opened files with its parent.

      kill, exit: cause process to terminate.

5. File System Commands and Operations:
   Unlike Unix (Kernel), file operations will be executed as commands.
   The required commands are listed below. LEVEL 1 is the MINIMUM requirements 
   for passing.
    
              -------  LEVEL 1 ------------ 
               mount_root;
               mkdir, rmdir, ls, cd, pwd;
               creat, rm;       
               stat, chmod, touch;

              -------  LEVEl 2 -------------
               open,  close,  read,  write
               pfd,   lseek
               cat,   cp,     mv

              -------  LEVEl 3 ------------ 
               mount, umount,             
               Process Management Commands 
               File permission checking
              -----------------------------
      
   Unless as noted below, all commands behave exactly the same as they do in 
   Unix.
 
      pfd   : Show the valid fd's of the current process.

      write : Prompt for fd and a string of chars, then write the chars 
              to the file and show the number of chars written.

      read  : Prompt for fd and n, then read the file and DISPLAY the 
              chars that are read.
============================================================================
                       SAMPLE PROGRAMS:
                       ~cs360/samples/
 
       simulator.bin: The File System Simulator for EXT2 FS. 
                        Under Linux, use  
                              mkfs /dev/fd0 1440
                        to make an EXT2 FS on a FD.

                    Then, run the simulator to see what I expect of YOUR work.
============================================================================


<Title>360 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">
<H1>360 PROJECT HELP </H1>
<Pre>
                     EECS 360 PROJECT HELP #1
    
Given: mkfs ======> make an EXT2 file system on /dev/fd0 (or a Linux file).


                     PROJECT ORGANIZATION

1. type.h (samples/type.h file)
          define constants, e.g. BLKSIZE, NPROC, NMINODE, NOFT, etc.
          define types for SUPER, INODE, DIR => same as in Linux
                
            MOUNT ==>   ---------------------------------------
                               dev       : disk identifier (fd number)
                               MinodePtr : pointer to mounted Minode

                               deviceName: pathname of mounted device  
                               MinodePath: pathname of mounted Minode
                          ---------------------------------------

            MINODE ==> In_Memory Inodes = ------
                                           INODE
                                          -------
                                          dev,ino
                                          refCount
                                          dirty
                                          mounted
                                          mountTablePtr
                                          (lock:optional)
                                           -------

            OFT   ===> OpenFileTable = --------- 
                                       mode: R|W|RW|A 
                                       refCount
                                       MinodePtr
                                       offset
                                       file's string name (optional)
                                       -------   

            PROC  ===> Process Structure = ptrs to other PROC's;
                                           pid, ppid, 
                                           uid;
                                           cwd ---> currentWorkingDir
                                           fd[NFD] = openfilePointers
                                           -------------------------- 
                
2. global.c ===> Ths file defines global variables, e.g.
                 MINODE *root;      pointer to root inode in memory.
                 PROC   *running;   pointer to current running process.
                 MINODE minode[100] in-memory inodes
                 etc

3. include.c ==> #include  "type.h"
                 #include  "global.c"
                 #include  "utility.c"
                 #include  "mountroot.c"
 
                 #include  "mkdir_creat.c"
                 #include  "cd_ls_pwd.c"
                 #include  "rmdir_rm.c"
                 #include  "other_level_1.c"

                 #include  "open_close_pfd.c"
                 #include  "write.c"
                 #include  "read.c"
                 #include  "cat_cp_mv.c"

                 #include  "mount_umount.c"
                 #include  "fork_switch_exit.c"
                 #include  "check_permission.c"

4. main.c:

   #include "include.c"

   init(){ 
           initialize the simulator system's data structures:
                MOUNT  mountTable[10];
                MINODE Minode[100];
                OFT    oft[100];
                PROC   proc[10];
            
           mount the rootdevice;  e.g. default to /dev/fd0
           Run porc[0] as the current process P0  with  cwd = /;
   }

             
   main()
   {
     init(); 
     while (1){
       print the current process ID;
       prompt for a commandString; ===>  mkdir, creat, cd, ....
              get paramter strings: e.g. mkdir pathaname

       cmdIndex = findCommand(commandString); ===> return 0,1,2,....

       switch(cmdIndex){
           case 0: mkdir(pathname);         break;
           case 1: creat_file(pathanme);    break;
           .......................................
           default: print INVALID command;
       }
   }

       
5. IMPLEMENT and TEST the commands in successive steps:

6. utility.c:
   This file implements the commonly used functions that are needed
   by the commands. It is suggested that you implement the following: 

(1). get_block(dev, buf, blkno);  read block to buf;
     put_block(dev, buf, blkno);  write block from buf


(2). Alocate/Deallocate functions:

     ialloc()/ idealloc() ===> allocate/deallocate an inode
     balloc()/ bdealloc() ===> allocate/deallocate a  file block;
     
     mialloc()/midealloc() ==> allocate an in memory inode 
     falloc()/fdealloc()   ==> allocate OFTE entry.

(3). ulong search(INODE *ip, char *name)
     search a DIR inode (data blocks) for name; 
     return ino if found, return 0 if not 

(4). THE MOST FUNDAMENTAL FUNCTION IS:

         ino = getino(&dev, char *pathname);

     which returns the ino of pathname.  The beginning dev is either / or
     the running proc's CWD, as in
                if (pathname[0] == '/')
                   dev = root->dev;
                else
                   dev = cwd->dev;
    However, while traversing the pathname, dev may change to that of a 
    mounted device.  So bring in &dev to keep track of the changes. 
    Alternatively, you may write ino = getino(char *pathname) and use a 
    global variable dev to record the CURRENT device number. 

    Upon return from getino(), we have (dev, ino) of the file.

    THIS IS SIMILAR TO YOUR showblock.c


(5). MINODE *iget(dev, ino) ==>   Return ptr to in-memory inode=(dev,ino);
                                  load the inode into a minode[] if necessary.
             iput(minodePtr); ==> Release the inode;  WRITE BACK TO DISK
                                                      IF refCount=0 and dirty.

(6). Others as needed:

     Given ip->inode in memory, find its parent's ino;

     Given a parent ip->inode in memory, and a child stringName,
           search for the childName.
           search for an unused directory entry.



              HOW TO GENERATE THE simulator EXECUTABLE

                       METHOD 1:

As shown above, main.c includes ALL the needed .c files. So
         cc -o simulator main.c
would generate the simulator executable. In this approach, the .h file
can only be included ONCE. 


                    METHOD 2: Use make
The is the preferred method of managing a LARGE set of C programs.
To use the make facility, you need to create a Makefile (or makefile) containing
instructions for make to follow.  make reads the Makefile, compiles the .c 
files (as needed) and link the .o files into an executable.

NOTE: in this approach, each .c file must include the .h file and use
      extern to declare any needed (global) variables.
 
To learn more about makefile contents, read Linux's /usr/info/make.info-1, etc.
Here, we show a makefile for the project.

#            # starts a comment line, which is ignored by make

# ***************************************************************************
#                    Example Makefile
#            Save these as Makfile or makefile Then run  make
# ***************************************************************************

# Variable H defines the head file (string)

H = type.h

# Variable OBJ defines the string containing .o file names
# NOTE: this is ONE line, but splitted into several lines for easier to read

OBJS = global.o alloc_dalloc.o util.o mount_umount.o mkdir_creat.o \
       stat.o cd_ls_pwd.o rmdir_rm.o open_close.o read.o write.o \
       cp_mv.o cs_fork.o main.o

# simulator:  is a rule, which says simulator DEPENDS on $(OBJ), the (string)
# value of the OBJ variable
    
simulator : $(OBJS)

# This rule tell make how to generate simulator: by    cc $(OBJ s.s
# NOTE !!! Each ACTION rule must begin with a TAB char, NOT a bunch of spaces.

	cc  -o simulator $(OBJS) s.s


# These tell make how to generate each .o file from a corresponding .c file.
# Each .o file DEPENDs on $(H), whcih means: The .o file will be generated 
# again if $(H) are changed. This certainly makes sense since each .c file
# depends on the TYPEs in type.h.

global.o : $(H)

alloc_dalloc.o : $(H)

util.o :  $(H)

mount_umount.o :  $(H)

mkdir_creat.o : $(H)

stat.o : $(H)

cd_ls_pwd.o : $(H)

rmdir_rm.o : $(H)

open_close.o : $(H)

read.o : $(H)

write.o : $(H)

cp_mv.o : $(H)

cs_fork.o : $(H)

main.o : $(H)


# make clean  ==>  remove the executable and all the .o files
clean :
	rm simulator *.o



<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                      HOWTO read

int read_file()
{
  Preparations:
   ask for a fd  and  nbytes to read
   verify that fd is indeed opened for READ or RW

   return(myread(fd, buf, nbytes));
}
 

// myread() behaves exactly the same as Unix's read(fd, buf, nbytes) syscall
// it tries to read nbytes from fd to buf[ ], and returns the actual number of
// bytes read.

int myread(int fd, char *buf, int nbytes)
{
 1. size = fileSize - OFT's offset //number of bytes remain in file.

 2. while (nbytes > 0 && size > 0){
     compute LOGICAL BLOCK lbk and startByte in that block from offset;
           lbk       = oftp->offset / BLOCK_SIZE;
           startByte = oftp->offset % BLOCK_SIZE;
     
     // I only show how to read DIRECT BLOCKS. YOU do INDIRECT and D_INDIRECT
 
     if (lbk < 12){              // direct block
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12) { 
          //  indirect blocks 
     }
     else{ 
          //  double indirect blocks
     } 

     /* get the data block into readbuf[] */
     get_block(mip->dev, blk, readbuf);

     /* copy from startByte to buf[], at most remain bytes in this block */
     char *cp = readbuf + startByte;   
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in readbuf[]

     while (remain > 0){
            *cq++ = *cp++;             // cq points at buf[ ]       
             oftp->offset++; 
             count++;                  // count=0 for counting
             size--; nbytes--;  remain--;
             if (nbytes <= 0 || size <= 0) 
                 break;
     }
 
     // if one data block is not enough, loop back to OUTER while for more ...

 }

 show ("myread : read %d char from file %d\n", count, fd);  

 return count;    // count is a actual number of bytes read
}
<html>
<body>
<pre>

                 360 Review Questions

1. What happens when you login to Unix?

2. Write C statements for a struct containing
         ---------------------------------------    
         NEXT  : a pointer to the SAME struct
         ID    : an integer                         
         NAME  : an array of 256 chars              
         ---------------------------------------    
   Write C statements to print the contents of a list.

3. What's cc? (Steps and what does each step do)
   Dynamic Vs. static linking?

4. Given a C program,

        int g;
        int h = 1;

        main(int argc, char *argv[])      int A(        )
        {                                 {                            
           int a,b,c;                        int u,v;
           a = 2; 
           b = 3;                            HERE:       
           c = A(a,b,"hello");      
        }                                 }  

   (0). Complete the function heading of A(....)
   (1). Which variables are global? local?   
   (2). Which variables are in a.out?
   (3). In the run-time memory of a.out, where are the variables?

   (4). Execution is at HERE:  Show the stack contents from HERE to main()'s 
                               argc and argv.

5. A simple function in assembly:
            .global sub
   sub:

   ENTRY:   pushl   %ebp
            movl    %esp, %ebp
   
   BODY:
            movl    $1234, %eax
            movl     1234, %eax            

   EXIT:
            movl    %ebp, %esp
            popl    %ebp
            ret

   (0). What's purpose of .global sub ?
   (1). What's the purpose of the statements at ENTRY?
   (2). What's the difference between the 2 statements in BODY?
   (3). What does the EXIT part do?

6. int pid, dead, how;

   pid = fork();              What does it do?

   if (pid){ // do this }     which process does this?
   else{     // do that }     which process does that?

   dead = wait(&how);         IF CALLED BY THE ABOVE 2 processes, dead=? how=?

7. What does  int   r = execve("a.out", argv, env);    do?
   How does the system find a.out?
   Draw a diagram to show exactly what's argv?
   What's the value of r? (It can only have ONE possible value !!!)

8. a.out is the binary executable of the C program
     main(int argc, char *argv[], char *env[])
     {
       execve(argv[0], argv, env);
     }
   What would happen?
   HOW TO GET OUT THE MESS?

9. When run  a.out > outfile, how does sh do the I/O re-direction?

10. You can use the Unix command  mkdir /a/b/c  to make a directory.
    Write a C statement for the mkdir command.
    
11. open,  read,  write are system calls
   fopen, fread, fwrite are library I/O functions.

   What's their RELATIONSHIP? 
   WHY do wee need lib I/O functions?

   Write C code to
     open a file for READ; read the SECOND block of 1024 bytes into a buf[]
     open a file for WRITE (CREAT if needed); write a string of chars to it.

12. stat():
    What does it do?
    HOW TO determine a files's type, e.g. REG or DIR?
    HOW TO get the file size, creation time?
    How to print creation time in calendar form?
    How to tell whether 2 pathnames are really the SAME file?

13. HOW TO use opendir(), readdir()?

14. Network Programming using TCP
    What's IP? what's TCP? HOW DOES TCP achieve reliable data transfer?
    What's an IP address, a Port Number?
    Network (bytes) order Vs. host order?
    Compare a socket (number) with a file descriptor?

    In a TCP Server-Client model, to establish a "virtual" connection,

       What should the Server do?   |    What should the Client do? 
            
          (After Server accepted a Client connection)                      
       How does the Server know where is the Client?
            HOW DO THEY communicate with each other?

    HOW TO let the Server deal with multiple Clients?

15. mkfs:
    What's a bit map?
    Assume : char buf[1204], block 4 of a FD contains a bit map for inodes.
             INODE my_inode is an INODE struct.

    Write C code for the following:
   (1). read disk block 4 into buf[].
   (2). serach for a FREE inode (number) in the bit map, change it to BUSY
        and return the inode number.
   (3). copy the inode on disk to my_inode.


16. showblock:

    ASSUME: char buf[1024] contains a data block of a directory, such as that of /
    Write C code to 
      (1). search for a name string "abcde" in that data block.
      (2). while searching, print the names of the DIR entries in that block.









<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP : HOWTO rmdir_rm</H1>

<Pre>

int rmdir()
{
  1. ask for a pathname to rmdir
  2. get its inumber :  
         ino = getino(&dev, pathname) 
  3. get a pointer to its Minode[] :   
         mip = iget(dev, ino);

  4. check DIR type */
       if NOT : iput(mip); retunr -1;
 
  5. check ownership 
       super user : OK
       not super user: uid must match

  5. check for BUSY or mounted on ?
       test refCount and mounted flag

  6. check whether it's empty
     First, check link count (inks_count > 2 means not empty);
     However, links_count == 2 may still have FILEs, so go through its data 
     block(s) to see whether it has any entries in addition to . and ..

  7. Assume empty:
       get parent DIR's ino and Minode (pointed by pip);
       remove child's entry from parent directory:

       rm_child(pip, me, child);   pip->parent Minode, me=my_inumber
                                   child = nameString to remove

  8. deallocate its block and inode
     for (i=0; i<12; i++){
         if (mip->INODE.i_block[i]==0)
             continue;
         bdalloc(mip->dev, mip->INODE.i_block[i]);
     }
     idalloc(mip->dev, mip->ino);
     mip->refCount = 0;

     decrement pip's link_count by 1; 
     touch pip's atime, mtime fields;
     mark pip dirty;
     iput(pip);
     return(0);
}


int rm(pathname) char *pathname;
{
   1. get its ino and inode */
          ino = getino(&dev, temp);

   2. get its Minode pointer
          mip = iget(dev, ino);

   3. check busy:
          check refCount

   4. check FILE type */

   5. check ownership

   6. get parent's ino and Minode pointer
          pino = getino(&dev, parent);
          pip  = iget(dev, pino);

   7. remove name from parent directory */
          rm_child(pip, ino, child);

   8 deallocate direct and indirect data blocks */
     for (i=0; i<12; i++){
        if (mip->INODE.i_block[i]) 
            bdalloc(mip->dev, mip->INODE.i_block[i]);
      }
    
     deallocate indirect data blocks AND the indirect blocks themselves 
     NOTE: you MUST allow files to have DOUBLE indirect blocks

   9. deallocate its inode :
         idalloc(mip->dev, mip->ino);
   
   10. mip->refCount = 0;

   11. dispose of parent's Minode
       touch pip; mark pip dirty;
       iput(pip);
   
   return(0);
}



// rm_child() is common to both rmdir and rm. It remove an entry [me, child]
   from the parent's data block. WATCH the clever tricks used here.

int rm_child(parent, me, child)
    MINODE *parent; unsigned long me; char *child;
{
   1. Search parent INODE's data block(s) for an entry eqaul to me
   2. Erase my name from parent directory:
       if first entry in block ==> set my ino to 0;   
       if NOT first entry in block ==> absorb my rec_len to the previous entry;
          (this effectively makes my_entry disappear;
           no need to change parent's fileSize)
   3. Write the parent's data block back to disk
}




<Title>360 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 NOTES #10 Sh Programming</H1>

<Pre>
1. sh scripts:
   A sh script is a text file containing sh statements for sh to execute.
   Example: Text edit a file, mysh,  containing
            -----------------------------------
            #! /bin/bash
            # comment line
            echo hello
            -----------------------------------
   Use chmod +x mysh to make it executable. Then run mysh. It will print hello.

2. Command-line parameters:
   Similar to running C programs, sh scripts can be invoked with parameters, 
   as in      mysh one two three

   $# = the number of such parameters, which are known as $1 to $9. $0 is the
        program name itself.
   $* = ALL command-line parameter (strings) $1 $2 ....
   
   Example:
            ------------------
            echo $#
            echo $1 $2
            echo $*
           -----------------
   mysh                      ====> print  0 
                 
   mysh one two three        ====> print  3
                                           one two
                                           one two three
2. sh Statements

2-1. sh statements include all Unix commands, with I/O re-directions.
     Examples:    ls           ; ls > outfile 
                  date         
                  cp f1 f2
                  mkdir new
                  cat filename

2-2. Simple sh (built-in) statements
     echo This is a line              # display This is a line
     echo "This is     a   line"      # display This is    a   line
     echo -n hi                       # display hi without NEWLINE  
     echo    there                    # display hithere
     
     shift, eval (will be explained later).

2-3. Command Substitution:
     When sh sees $(cmd), it executes cmd first, and SUSTITUTEs $(cmd)
     with the RESULT (string) of the execution.

     echo $(date)       ==> display current date string
     echo $(ls)         ==> display the result of ls command 


3. Sh Variables:
   Sh has many built-in variables, e.g. PATH, HOME.
   You may use any symbol as sh variable. No declaration is necessary.
   sh variable values are STRINGs !!! If A is a variable, $A is its value.
   Examples
      echo A   ==>  A
      echo $A  ==>        (null string if A is not set)
      A="this is fun"     # set A value
      echo $A  ==> this is fun
      B=A
      echo $B   ==> A     (B was assigned the string "A")
      B=$A                (B takes the VALUE of A)
      echo $B   ==> this is fun

      echo -n "enter yes or no "
      read ANS            # sh reads an input line from stdin; try read A1 A2 with "one two three"
      echo $ANS

      local X             # X is local to this sh; not available in child sh
      export Y            # variable Y will be passed to child sh process

4. Quotes:
   Sh has many special chars, such as $, /, *, >, <, etc.  
   To use these as ordinary chars, use \ to quote them, as in
         echo \$A     ==> $A
     OR  echo '$A'    ==> $A    (NO substitution within SINGLE quotes)

         echo " this is $A"     (DOUBLE quotes will substitute $A !!!)

5. sh statements
5-1. if-else-fi statement
     if [ condition ]
       then
          statements
       else                # as usual, the else part is optional
          statements
     fi

Example:
echo ------------------------------
echo This sh script copies f1 to f2
echo "     then removes f2"        # Use double-quotes " " to include spaces
echo ------------------------------

# $# is the number of command line parameters, which are known as 
# $1,$2,$3,...., $9    As usual, $0 is the name of the execcutable itself.
# Here, $# must be 2. If not show Usage and exit

# By default, all values in sh are strings, so they can be compared by
#  if [ s1 = s2 ];  if [ s1 != s2 ];   if [ s1 \< s2 ]; if [ s1 \> s2 ]; etc.
# Note the spaces between the tokens

# In contrast, the operators -eq, -ne, -lt, -gt compare them as (integer)
# NUMBERS, thus
#  if [ "123" = "0123" ]  is false (since they differ as strings)
#  if [ "123" -eq "0123" ] is true. Since everything is string, you may use
#  if [ 123 -eq 0123 ] OR  if ["123" -eq 0123 ]

# Here we compare them as STRINGs; 
if [ $# != 2 ] 
then
     echo Usage: copy file1 file2
     exit 1
fi

# $1 is the first parameter string, $2 the second, etc.

echo You are copying $1 to $2 
echo in the directory $(pwd)     # COMMAND SUBSTITUTION

echo copying $1 to $2 ....
     cp  $1  $2                 # this is the actual copy operation
echo done

echo show $2 has been created ....
  ls -l $2
echo now try to remove $2

# if $2 exists as a file:
if [ -e $2 ]  
 then 
   echo removing $2 .....
   rm $2
fi
echo
echo all done
echo Let\'s go on .....      # QUOTE the special char ' by \ 

# ***************** DO THESE:  ****************************
# In sh, the following tests can be used:
# if [ -e name ]      test whether file name exists
# if [ -f name ]      test whether name is a (REG) file
# if [ -d name ]      test whether name is a DIR
# if [ -r name ]      test whether name is readable; also -w,-x
# if [ f1 -ef f2 ]    test whether f1, f2 are the SAME file
#.........................................................

                   EXERCISES:

# MODIFY the above sh program to do these:

#1. Check whether f1 exists. If not, echo a message and exit;

#2. Check whether f2 exists.  
#      If f2 already exists:
#         echo a message:     OK to over-write f2 (y/n)?
#         read user's response by    read ANS
#         if $ANS = "y" ===> go on, else exit.

#3. Ask for a directory name (relative to user's $HOME)
#   DIR to do the copying. Then copy f1 to f2, all in that 
#   directory.

#   read DIR
#   cd $DIR  will cd to that directory
#   (cd $DIR; sh commands; .....)  ==> commands grouping
#                                   
#   Alternatively, you may stay in the current directory 
#   but generate the right file names from $1 and $2.
#   basename a/b/c/d  ====> d 
    
# ******************************************************

5-2. for statement in sh:

       for VARIABLE in string1 string2,...., stringn
         do
            commands
         done

   Examples:
      for FRUIT in  apple  orange  banana  cherry
        do
           echo $FRUIT     ===> apple  orange  banana  cherry 
        done 

      for NAME in $* 
        do
          echo $NAME      ==>  all command-line param strings
          if [ -f $NAME ]; then
             echo $NAME is a file
          fi
          if [ -d $NAME ]; then
             echo $NAME is a DIR
          fi
        done


5-3. while [ condition ]
       do
          commands
       done

  -------------------------------------------------------------------
                  Example:
   echo '$#' = $#         # echo the number of parameters 
   I=0                    # set I to "0" (STRING !!!!) 
   while [ $1 ]           # while $1 is not the empty string
   do
      echo $1             # echo current $1
      I=$(expr $I + 1)    # use expr to change I from "0" to "1"
      shift               # shift once, $2 becomes $1, $3 becomes $2, ... etc.
   done
          
   echo I = $I            # total number of parameters 
  --------------------------------------------------------------------

5-4 Other Flow-Control statements:

    until [ "$ANS" = "give up" ]
    do
        echo -n "enter your answer : "
        read ANS
    done
   
    case statement (SELF-STUDY)

5-5. break and continue statements:
     They work exactly the same as they do in C

6 sh Processing Steps:

  Assume:   A='$B'    B='new.*'    C=newdir
   For each command line, e,g,
        cp  $A `pwd`/$C
   sh evaluates the variables in the following order:

   (1). Parameter substitution: (only scan ONCE) ==>
        cp  $A `pwd`/$C          Replace $A, $C ===> becomes  
        cp  $B `pwd`/newdir      NOTE that $A is replaced only ONCE.
    
   (2). Command substitution:
        cp  $B `pwd`/newdir     Perform `pwd` ===>   becomes
        cp  $B /a/b/c/newdir    (assuming CWD=/a/b/c)

   (3). Blank Interpretation:
        Use the value of $IFS (usually space,tab and newline) to
        break up the chars into non-blank words. ==> 
        cp  $B /a/b/c/newdir    NO change here.
       
   (4). File name generation:
        Each word is scanned for file pattern characters *, ?, [..]
        to generate a list of filenames, which replace the word.

        cp  $B /a/b/c/newdir    There are no file pattern chars, so no change.
                                This is the final command to sh.
        ------------------------------------------------------------- 
                         
7. eval  is a sh built-in command, which is executed by sh itself without
   forking a new process.   Each  eval  evaluates the input string ONCE 
   and use the results as inputs to sh. 

   Example 1: Assume execution of do_it generates output lines
                   A=a\nB=b\nC=c\n

            Then,  eval $(do_it)

            generates A=a\nB=b\C=c\n as inputs to sh AS IF you have
            entered the lines
                               A=a  
                               B=b
                               C=c
            Thus, sh will set the variables A,B,C to a,b,c, respectively.
             
   Example 2: Assume: A='$B'     B='new.*'     C=newdir
            Then    eval echo $A  ==> generates  
                         echo $B      to sh, resulting   ===>  new.*

   Now, consider this command:

        eval cp $A `pwd`/$C     ===> eval  first converts this to
             cp $B `pwd`/newdir ===> and uses this as inputs to sh.
   
   With these inputs, sh will do the substitutions of Steps (1) to (3).
   The command at Step (4) is

             cp new.* /a/b/c/newdir 

   Step 4 : The command line has a file wild-card char *.
            sh will replace the word  new.* by the filenames 
            new.X, new,Y,... (assuming they exist) and finally 
            executes

            cp new.X new.Y ...  /a/b/c/newdir

4. Within a pair of double quotes, parameter and command substituions occur 
   but blank interpretation and file name generation do not.
 
8. sh FUNCTIONS (by examples)
    --------------------------------------------------------
     # check_file() is a function, NOT the entry point

              check_file()     
              {
                local A=localVariable    # A is local to this function

                if [ -f $1 ]; then
                   return 0
                fi
                return 1
              }

     # Here is the entry point of the program
     # Usage : thisFile  f1 f2  f3 ......

              for FILE in $*             # for FILE in $1 $2 ....
              do
                  check_file  $FILE      # call check_file() 
                  if [ $? = 0 ]          # returnCode == 0 ?
                     then
                         echo $FILE is a regular file
                     else
                         echo $FILE is not regular
                  fi
              done
     -------------------------------------------------------------

9. Utility Programs and sh Programming
   
   expr is a utility program. It is used as
        expr x Operator y
   It evaluates the the expression (x Operator y), where Operator is
   any valid operator in C, e.g.
         expr 3 + 5  ==>  8
         expr 3 \* 5 ==> 15   #NOTE: * must be quoted 
         expr 5 % 3  ==>  1   etc

   There are many utility programs, such as basename, grep, sed, cut, etc. 
   which are used so often that they have become almost an indispensible part 
   of sh programming. You are free to develop your own utility programs and,
   if they prove to be useful enough, include them in the Unix command set.
   Many Unix commands originated this way. As they say: Necessity is the
   Mother of all inventions.

   For example, suppose you want to have a myinc operator, which
   increments a sh (COUNTing) variable by one.  You may write it as

       main(int argc, char *argv[])
       {  
          int i = 0;
          if (argc > 1)
             i = atoi(argv[1]) + 1;;
          printf("%d",i);
       }

   Then, use myinc to replace  expr  for incrementing $I by 1.

10. I/O Redirection:

   When entering a sh command, we may instruct sh to re-direct I/O
   to files other than the default stdin, stdout, sterr. I/O redirections
   have the following form and meaning:
      -------------------------------------------------
      >  file   stdout goes to file, which will be created if non-existing.
      >> file   stdout append to file
      <  file   use file as stdin; file must exist and have r permission.
      << word   take inputs from "here" file until a line containing only 
                "word" is encountered. 
                Try these:
                ---------------------------------------------
                echo << END    
                  keep entering lines until a line with only
                  END
                --------------------------------------------
                cat << DONE
                  keep entering lines until
                DONE
                -------------------------------------------

      >&2      dup (see below) the fd=2 and use the result as stdout.

      <&3      dup fd=3 and use the result as stdin
      --------------------------------------------------
      A digit may preceed any of these to mean: use that fd instead of 
      stdin or stdout.  Examples:
                2> file           stderr to file
                2>> file          stderr append to file
                2>&1              dup 1 and use it as 2 ==> merge 1 and 2

8-1. dup and dup2 syscalls:

     int dup(int fd);
     
     dup() duplicates a file descriptor by creating a new fileDescriptor
     using the lowest fd number. It returns the new fd,  or -1 if failed.

     -------------------------------------------------------------      
     Example 1:  int fd = open("infile", 0);  /* open for READ */
                   close(0);    /* This frees fd[0]*/
                   dup(fd);     /* dup fd into fd[0] */

               /*** from here on stdin is the same as fd */
                   sscanf(FMT, &items);  will input from infile.

     ------------------------------------------------------------
     Example 2:  int gd = creat("outfile", 0644);
                     close(1);  /* this frees  fd[1] */
                     dup(gd);   /* dup gd into fd[1] */
               /** from here on stdout is really gd ***/
                     printf("hello world\n");  will go to outfile.
     ------------------------------------------------------------

     int dup2(int old_fd, int new_fd);

         duplicates  old_fd  into  fd[new_fd].  It closes new_fd first, 
         if necessary.  dup2(gd, 0) is equivalent to  close(0); followed
         by  dup(gd);

     ------------------------------------------------------------
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                 HOWTO STAT_CD_LS_PWD

1. HOW TO stat:

   struct stat mystat; 
   char *pathname = "/a/b/c/d";
 
   r = do_stat(pathname, &mystat); 

int do_stat(char *pathname, struct stat *stPtr)
{
  1. Get inode of pathname into an MINODE:
         ino = getino(&dev, pathname); 
         mip = iget(dev, ino);          // iget() returns a pointer to minode[]
         
  3. Copy entries of INODE into stat struct;

     As you can see, everything needed by the stat struct is in MINODE.
     Write C statements to copy from mip->INODE to stPtr->fields.

       struct ext2_inode {
	i_mode;		/* File mode */
	i_uid;		/* Owner Uid */
	i_size;		/* Size in bytes */
	i_atime;	/* Access time */
	i_ctime;	/* Creation time */
	i_mtime;	/* Modification time */
	i_dtime;	/* Deletion Time */
	i_gid;		/* Group Id */
	i_links_count;	/* Links count */
	i_blocks;	/* Blocks count */
        .................................
        i_block[15];    // Allocated disk blocks 
      }

      struct stat {
        st_dev;      // dev
        st_ino;      // ino

        st_mode;     // i_mode
        st_nlink;    // i_links_count
        st_uid;      // i_uid
        st_gid;      // i_gid
        st_rdev;     // IGNORE THIS
        st_size;     // i_size
        st_blksize;  // 1024
        st_blocks;   // i_blocks
        st_atime;    // i_atime
        st_mtime;    // i_mtime
        st_ctime;    // i_ctime
      };

  4. Print the entries of the stat struct;
  5. iput(mip);      // dispose of the in memory inode; see NOTE below.
     return 0 for success;
}
============================================================================
NOTE: In general,   mip = iget(dev, ino); and
                          iput(mip);
      should occur in pairs, with only a few exceptions:

       cd()   : iget(new CWD) but iput(old CWD)
       open() : iget() but close() does iput().
       mount(): iget() but umount() does input().
============================================================================
2. HOW TO ls:

int do_ls(char *pathname) 
{
 
  1. If pathname==NULL, ls CWD.

  2. YOU MAY USE do_stat() OR work on the INODE of pathname directly.
  
  3. In either case, USE YOUR myls LAB program here.

  4. return 0 for SUCCESS

}


3. HOW TO cd:

int do_cd(char *pathname)
{
  1. if pathname==NULL ==> cd to root (default HOME dir) AS SHOWN:

     if (pathname[0] == 0){
        iput(rnning->cwd);                 // dispose of CWD
        running->cwd = iget(rootdev, 2);   // OR running->cwd = root; 
                                           //    root->refCount++;
        return 0;
     }
     

  2. Get INODE of pathname into a MINODE:
         ino = getino(&dev, pathname);     // return BAD if ino==0

  3. Get inode into an MINODE slot.
         mip = iget(dev, ino);

  4. Check DIR type ==> if NOT DIR: 
                           iput(mip); YELL at user; return BAD;

  5. Dispose of original running->cwd (by iput(running->cwd) ); 
     Change running->cwd to point at this Minode in memroy;
     return 0 for OK;
}


3. HOW TO pwd:

int do_pwd()
{ pwd(running->CWD); }

pwd(wd) MINODE *wd;
{ 
   Write this function as a recursive fucnction, which

   1. if wd is already the root:
         print /; return;

   2. Get parent's MINODE pointer wd; 
          (HOW? get i_block[0]; then iget(dev, ino of ..))
      Call pwd(wd) again with parent's MINODE pointer;

   3. Print wd's name followed by a /;
          (HOW TO get the name string of a MINODE?)

          2 ways: if you recorded the pathname of a file in its MINODE,
                  then it's the basename() of that string.
          OR    : You have this guy's ino and its parent's MINODE.
                  Search the parent DIR for an entry with this ino. Then, you
                  have its name. I PREFER THIS method !!!

   4. FOR LEVEL-3: If you implement MOUNTing, make sure your recursion can
                     cross mounting points.
}


<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>360 Notes #7</H1>

<Pre>

         360 Notes #7 System Calls for File Operations

1. What are syscalls?

   Syscall is a mechanism that allows a process to enter Kernel mode to 
   perform operations not allowed in User mode. Operations such as open files,
   read/write files, fork, exec, even termination, must all be done in Kernel.
   In this set of notes, we shall focus on Unix syscalls for file operations.
   
2. Where to find these information:

   Under Linux, the man pages of all syscalls are listed in /usr/man/man2/.
   The Unix command man 2 NAME displays the man pages of NAME in man2/. 
   Similarly, man 8 mkfs displays the man pages of mkfs in /usr/man/man8/. 

   DO: practice using man to read Linux's man pages.
 
3. How to use these functions?

   Include them in your C program, just like ordinary function calls. A return 
   value >=0 means OK, -1 means BAD. An implicitly defined global int variable,
   errno, records the error code.  Each error code number has a corresponding
   string description, as the following program shows.

            #include &lterrno.h&gt
            main()
            {
              if (mkdir("newdir", 0777) < 0){
                 printf("errno=%d : %s\n", errno, strerror(errno));
              }
            }

    If you run the program twice, the second time it will print
                   errno=17 : File exists
    as it should.
    ************************************************************** 
                 EXERCISES: (Some already in LAB#2)
       Write a C program to test :  
               mkdir, rmdir, chdir, creat, unlink, rename, chmod
    **************************************************************

4. READ and LEARN how to use these syscalls on your own:

   access : check user's permissions for a file : R_OK,W_OK,X_OK,F_OK. 
            int access(const char *pathname, int mode);

   chdir  : change directory
            int chdir(const char *path);

   chmod  : change permissions of a file
            int chmod(const char *path, mode_t mode);

   OTHERS : chown, chroot, setuid


   mkdir  : create a directory
            int mkdir(const char *pathname, mode_t mode);

   rmdir  : remove a directory (must be empty)
            int rmdir(const char *pathname);

   link   : make a new name for a file
            int link(const char *oldpath, const char *newpath);


   unlink : delete a name and possibly the file it refers to
            int unlink(const char *pathname);

   symlink: create a symbolic link for a file
            int symlink(const char *oldpath, const char *newpath);

   rename : change the name of a file
            int rename(const char *oldpath, const char *newpath);
  
                       SPECIAL ONES:

   mount  : int  mount(const  char  *specialfile, const char * dir , 
                       const char *filesystemtype, unsigned long mountflags , 
                       const void * data);

   umount : int umount(const char *dir);

   mknod  : make special files, e.g.  mknod /dev/fd2 b 2 2


5. To be covered in details in class:

      open, creat, umask
      read, write, lseek
      close

      opendir : DIR *opendir(const char *name);
      readdir : int readdir(unsigned int fd, struct dirent *dirp, unsigned int count);
      readlink: int readlink(const char *path, char *buf, size_t bufsiz);

      stat :  int stat(const char *file_name, struct stat *buf);
              int fstat(int filedes, struct stat *buf);
              int lstat(const char *file_name, struct stat *buf);


6. The stat Systen Call

6-1. Link Files:
   In Unix, every file has a pathname, such as /a/b/c. However, Unix allows 
different pathnames to represent the same file. These are known as LINK files.
There are two kinds of LINKs, HARD link and SOFT link. 

HARD Links: 
     The command    ln  oldpath  newpath 

creates a HARD link from newpath to oldpath. The corresponding syscall is

          link(char *oldpath, char *newpath)

NOTE: Hard links can only be applied to non-DIR files. 
      (What would happen if DIRs could  be hard linked ?) 

Hard linked files share the same inode, whose nlink field records the number of
hard links to the inode. Converse to link, the syscall
 
        unlink(char *pathname)

finds the inode of pathname and decrements its nlink by 1. The file is truly 
removed only if nlink becomes 0. This is what the rm command does.
    
SOFT Links:  
     The command   ln -s  oldpath newpath  

creates a SOFT or Symbolic link from newpath to oldpath. The corresponding
syscall is 
             symlink(char *oldpath, char *newpath)

The newpath is (almost a regular) file, which contains the oldpath string. It
acts like a detour road sign, which directs the traffic to the real destination
(oldpath). Unlike hard links, soft links can be applied to any file, such as

             ln -s   aVeryLongPathname                 a
             ln -s   aFileWhichMayBeChangedOften       b

One drawback of soft link is that the target file may NOT exist. If so, the
detour would direct the poor driver to fall off a cliff. In Linux, such death
traps are displayed in (the appropriate color of) RED under the ls -l command.

Also, if foo -> /a/b/c is a soft link file, the open("foo", 0) syscall, as 
implemented, will open the target file /a/b/c, not the link file foo itself. 
So, the open()/read() syscalls would NOT read any soft link file. Instead, the
syscall, readlink(), must be used to read the contents of a soft link file. 

 
A Brief Summary about Links:
           Command                               Syscall used
  =======================================================================
    ln     oldpath newpath             link(char *oldpath, char *newpath)
    ln -s  oldpath newpath          symlink(char *oldpath, char *newpath)
  =======================================================================

6-2. File Status:
   Every file has a UNIQUE inode, whcih contain ALL the information about the
file. The syscalls, stat/lstat/fstat, return the info of a file. (

9-2-1. INODE:
     Every file is represented by a unique INODE data strucutre, which is shown
here for reference.:

struct ext2_inode {
  unsigned short i_mode;
  unsigned short i_uid;
  unsigned long  i_size;
  unsigned long  i_atime;
  unsigned long  i_ctime;
  unsigned long  i_mtime;
  unsigned long  i_dtime;
  unsigned short i_gid;
  unsigned short i_links_count;
  unsigned long  i_blocks;
  unsigned long  i_flags;
  unsigned long  i_reserved1;
  unsigned long  i_block[15];
  // several other unimportant fields
};

6-2.2  The man pages of stat:
    Use  man stat  to read the man pages of the stat system call, which is 
shown below.
=============================================================================
STAT(2)                    System calls                   STAT(2)

NAME
       stat, fstat, lstat - get file status

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;

       int stat(const char *file_name, struct stat *buf);
       int fstat(int filedes, struct stat *buf);
       int lstat(const char *file_name, struct stat *buf);

DESCRIPTION
       These  functions  return  information  about the specified
       file.  You do not need any access rights to  the  file  to
       get  this  information  but  you need search rights to all
       directories named in the path leading to the file.

       stat stats the file pointed to by file_name and  fills  in
       buf.

       lstat  is  identical to stat, except in the case of a sym-
       bolic link, where the link itself is stat-ed, not the file
       that it refers to.

       fstat  is identical to stat, only the open file pointed to
       by filedes (as returned by open(2)) is stated in place  of
       file_name.


       They  all return a stat structure, which contains the fol-
       lowing fields:

            struct stat {
                dev_t         st_dev;      /* device */
                ino_t         st_ino;      /* inode */
                mode_t        st_mode;     /* protection */
                nlink_t       st_nlink;    /* number of hard links */
                uid_t         st_uid;      /* user ID of owner */
                gid_t         st_gid;      /* group ID of owner */
                dev_t         st_rdev;     /* device type (if inode device) */
                off_t         st_size;     /* total size, in bytes */
                unsigned long st_blksize;  /* blocksize for filesystem I/O */
                unsigned long st_blocks;   /* number of blocks allocated */
                time_t        st_atime;    /* time of last access */
                time_t        st_mtime;    /* time of last modification */
                time_t        st_ctime;    /* time of last change */
            };

       The value st_size gives the size of the file (if it  is  a
       regular file or a symlink) in bytes. The size of a symlink
       is the length of the pathname it contains, without  trail-
       ing NULL.

       The value st_blocks gives the size of the file in 512-byte
       blocks.  (This may be smaller than st_size/512  e.g.  when
       the file has holes.)  The value st_blksize gives the "pre-
       ferred" blocksize for efficient file system I/O.  (Writing
       to a file in smaller chunks may cause an inefficient read-
       modify-rewrite.)

       Not all of the Linux filesystems implement all of the time
       fields.   Some  file system types allow mounting in such a
       way that file accesses do  not  cause  an  update  of  the
       st_atime field. (See `noatime' in mount(8).)

       The  field  st_atime  is changed by file accesses, e.g. by
       exec(2), mknod(2), pipe(2), utime(2) and read(2) (of  more
       than zero bytes). Other routines, like mmap(2), may or may
       not update st_atime.

       The field st_mtime is changed by file modifications,  e.g.
       by  mknod(2),  truncate(2), utime(2) and write(2) (of more
       than zero bytes).  Moreover, st_mtime of  a  directory  is
       changed  by  the  creation  or  deletion  of files in that
       directory.  The st_mtime field is not changed for  changes
       in owner, group, hard link count, or mode.

       The  field  st_ctime  is  changed by writing or by setting
       inode information (i.e., owner, group, link  count,  mode,
       etc.).

       The  following  POSIX macros are defined to check the file
       type:

              S_ISREG(m)  is it a regular file?

              S_ISDIR(m)  directory?

              S_ISCHR(m)  character device?

              S_ISBLK(m)  block device?

              S_ISFIFO(m) fifo?

              S_ISLNK(m)  symbolic link? (Not in POSIX.1-1996.)

              S_ISSOCK(m) socket? (Not in POSIX.1-1996.)

       The following flags are defined for the st_mode field:

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit (see below)
       S_ISVTX    0001000   sticky bit (see below)

       S_IRWXU    00700     mask for file owner permissions
       S_IRUSR    00400     owner has read permission
       S_IWUSR    00200     owner has write permission
       S_IXUSR    00100     owner has execute permission
       S_IRWXG    00070     mask for group permissions
       S_IRGRP    00040     group has read permission
       S_IWGRP    00020     group has write permission
       S_IXGRP    00010     group has execute permission
       S_IRWXO    00007     mask for permissions for others (not in group)
       S_IROTH    00004     others have read permission
       S_IWOTH    00002     others have write permisson
       S_IXOTH    00001     others have execute permission

RETURN VALUE
       On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.


SEE ALSO
       chmod(2), chown(2), readlink(2), utime(2)
=============================================================================

6-2.3 File Type and Permissions:
    Among the fileds of the stat structure, only the st_mode field needs
    some explanation:

       mode_t        st_mode;     /* copied from i_mode of INODE */

    The TYPE of st_mode is unsigned short (2 bytes or 16 bits). 
    The 16 bits have the following meaning:

       |Type|   |permissions|
       ----------------------
       |tttt|fff|uuu|ggg|ooo| 
       ----------------------

    The leading 4 bits are file types, which can be interpreted as (Octals)

       S_IFMT     0170000   bitmask for the file type bitfields
       S_IFSOCK   0140000   socket
       S_IFLNK    0120000   symbolic link
       S_IFREG    0100000   regular file
       S_IFBLK    0060000   block device
       S_IFDIR    0040000   directory
       S_IFCHR    0020000   character device
       S_IFIFO    0010000   fifo
 
    The next 3 bits are flags, which indicate special usage of the file 

       S_ISUID    0004000   set UID bit
       S_ISGID    0002000   set GID bit 
       S_ISVTX    0001000   sticky bit 

    The remaining 9 bits are PERMISSION bits for file protection:

        owner  group  other
         rwx    rwx    rwx
    
    By interpreting these bits, YOU may disaplay the st_mode field as
       -rwxr-xr-x             (REG file) 
       drwxr-xr-x             (DIR)
       lrw-r--r--             (LNK file)

==============================================================================
6-3. HOW TO read DIR Entries:
   Read the man pages of   
            opendir, readdir, readlink  
to learn how to use these syscalls to open a DIR file for read, and then read 
the contents of a DIR file (as DIR entry strings). Alos, learn how to read the
contents of a (soft) LNK file itself.
<Title>360 Week 3 Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>type.h for Project</H1>

<Pre>

/*	type.h for CS360 Project             */

#include &lt stdio.h >
#include &lt fcntl.h>
#include &lt linux/ext2_fs.h>
#include &lt libgen.h>
#include &lt string.h>
#include &lt sys/stat.h>

// define shorter TYPES, save typing efforts
typedef struct ext2_group_desc  GD;
typedef struct ext2_super_block SUPER;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

#define BLOCK_SIZE        1024
#define BITS_PER_BLOCK    (8*BLOCK_SIZE)
#define INODES_PER_BLOCK  (BLOCK_SIZE/sizeof(INODE))

// Block number of EXT2 FS on FD
#define SUPERBLOCK        1
#define GDBLOCK           2
#define BBITMAP           3
#define IBITMAP           4
#define INODEBLOCK        5
#define ROOT_INODE        2

// Default dir and regulsr file modes
#define DIR_MODE          0040777 
#define FILE_MODE         0100644
#define SUPER_MAGIC       0xEF53
#define SUPER_USER        0

// Proc status
#define FREE              0
#define BUSY              1
#define KILLED            2

// Table sizes
#define NMINODES          50
#define NMOUNT            10
#define NPROC             10
#define NFD               10
#define NOFT              50

// Open File Table
typedef struct Oft{
  int   mode;
  int   refCount;
  struct Minode *inodeptr;
  long  offset;
} OFT;

// PROC structure
typedef struct Proc{
  int   uid;
  int   pid;
  int   gid;
  int   ppid;
  struct Proc *parent;
  int   status;

  struct Minode *cwd;
  OFT   *fd[NFD];
} PROC;
      
// In-memory inodes structure
typedef struct Minode{		
  INODE    INODE;               // disk inode
  ushort   dev;
  unsigned long ino;
  ushort   refCount;
  ushort   dirty;
  ushort   mounted;
  struct Mount *mountptr;
  char     name[128];           // name string of file
} MINODE;

// Mount Table structure
typedef struct Mount{
        int    ninodes;
        int    nblocks;
        int    dev, busy;   
        struct Minode *mounted_inode;
        char   name[256]; 
        char   mount_name[64];
} MOUNT;
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HOWTO #3</H1>

<Pre>
   The util.c file contains utility functions that are needed by most other  
   functions.  It is suggested that you implement the following.

1. get_block(dev, blk, buf) 
   put_block(dev, blk, buf)    These require no explanation.


2. token_path(char *pathname)
{
  This function breaks up a pathname, such as /a/b/c/d, into components
  a   b   c   d  and  determines the number of components n.
  The components will be used to search for the inode of pathname. 
}


3. dirname() and basename():
   Use these functions to divide a pathname into dirname and basename
   NOTE: They are in clib but both functions destroy the parameter string
  
4. unsigned long getino(int *dev, char *pathname)
{
  This is the most important function of the project. It converts
  a pathname, such as /a/b/c/d OR x/y/z, into its (dev, inumber), i.e. 
  the returned value is its inumber and dev is its dev number. 

  NOTE: while traversing a pathname, the starting dev number is the dev of / 
  OR the dev of (running's) CWD. If you have only one device, the dev number 
  will not change. But when crossing MOUNTed file systems (for Level-3), the
  dev number may change. The dev parameter is used to keep the CURRENT dev 
  number.

  This function depends on search(), which searches an DIR's data block for 
  a component name, and returns the component's inmuber. Modify *dev if the
  dev number changes.
  
  You have already done these in showblock.c
}   

5. unsigned long search(MINODE *mip, char *name)
{
   This function searches the data blocks of a DIR inode (inside an Minode[])
   for name. You may assume DIRECT data blocks only.
}


6. MINODE *iget(int dev, unsigned long ino)
{
  Once you have the (dev, ino) of an inode, you may load the inode into a slot
  in the Minode[] array. To ensure uniqueness, you must search the Minode[] 
  array to see whether the needed INODE is already loaded.

  If you find the needed INODE already in a Minode[] slot, just inc its 
  refCount by 1 and return the Minode[] pointer.

  If you do not find it in memory, you must allocate a FREE Minode[i], load
  the INODE from disk into that Minode[i].INODE, initialize the Minode[]'s
  other fields and return its address as a MINODE pointer,
}


7. iput(MINODE *mip)
{
  This function releases a Minode[]. Since an Minode[]'s refCount indicates
  the number of users on this Minode[], releasing is done as follows:
    First, dec the refCount by 1. If (after dec) refCount > 0 ==> return;
    else:
      if Minode[].dirty == 0 ==> no need to write back, so return;
      Otherwise, (dirty==1) ==> must write the INODE back to disk.
   
  To write an INODE back to disk:
     Use Minode's (dev, ino) to determine which dev and which INODE on disk,
  i.e. which disk block and which inode in that block.
  Read that block in, copy Minode's INODE into the INODE area in that block
  and write the block back to disk.
} 


8. int findmyname(MINODE *parent, unsigned long myino, char *myname) 
{
   Given the parent DIR (MINODE pointer) and my inumber, this function finds 
   the name string of myino in the parent's data block. This is similar to 
   SERACH() mentioned above.
}


9. int findino(MINODE *mip; unsigned long *myino, *parentino)
{
  For a DIR Minode, extract the inumbers of . and .. 
  Read in 0th data block. The inumbers are in the first two dir entries.
}
<Title>360 PROJECT HELP</Title>
<Body bgcolor="#ffffca" text="#000000">

<H1>360 PROJECT HELP</H1>

<Pre>
                     HOWTO write    

int write_file()
{
  1. Preprations:
     ask for a fd   and   a text string to write.

  2. verify fd is indeed opened for W or RW or APPEND mode

  3. copy the text string into a buf[] and get its length as nbytes.

     return(mywrite(fd, buf, nbytes));
}



// mywrite behaves exactly the same as Unix's write(fd, buf, nbytes) syscall.
// it writes nbytes from buf[] to the file fd

int mywrite(int fd, char *buf, int nbytes) 
{
  while (nbytes > 0 ){

     compute LOGICAL BLOCK (lbk) and the startByte in that lbk:
          lbk       = oftp->offset / BLOCK_SIZE;
          startByte = oftp->offset % BLOCK_SIZE;

    // I only show how to write DIRECT data blocks, you figure out how to 
    // write indirect and double-indirect blocks.

     if (lbk < 12){                         // direct block
        if (ip->INODE.i_block[lbk] == 0)    // if no data block yet
            mip->INODE.i_block[lbk] = balloc(mip->dev);
        blk = mip->INODE.i_block[lbk];
     }
     else if (lbk >= 12 && lbk < 256 + 12){ 
            // indirect blocks
     }
     else{
            // double indirect blocks */
     }

     /* all cases come to here : write to the data block */
     get_block(mip->dev, blk, wbuf);   // read disk block into wbuf[ ]  
     char *cp = wbuf + startByte;      // cp points at startByte in wbuf[]
     remain = BLOCK_SIZE - startByte;  // number of bytes remain in this block

     while (remain > 0){               // write as much as remain allows  
           *cp++ = *cq++;              // cq points at buf[ ]
           nbytes--; remain--;         // dec counts
           oftp->offset++;             // advance offset
           if (offset > i_size)        // especially for RW|APPEND mode
               mip->INODE.i_size++;    // inc file size (if offset>filesize)
           if (nbytes <= 0) break;     // if already nbytes, break
     }
     put_block(mip->dev, blk, wbuf);   // write wbuf[ ] to disk
     
     // loop back to while to write more .... until nbytes are written
  }

  mip->dirty = 1;       // mark mip dirty for iput() 
  show ("wrote %d char into file fd=%d\n", nbytes, fd);           
  return nbytes;
}
